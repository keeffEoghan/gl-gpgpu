{"mappings":"uitHAAAA,EAEA,SAAeC,EAAOC,EAAKC,GACzB,OAAOD,EAAMC,EACRF,EAAQC,EAAMA,EAAMD,EAAQE,EAAMA,EAAMF,EACxCA,EAAQE,EAAMA,EAAMF,EAAQC,EAAMA,EAAMD,C,ECDxC,MAAMG,EAAQ,CACjBC,KAAM,IAAKC,GAAI,IAAK,IAAG,IACrBC,MAAK,EAAG,IAAG,EACXC,IAAG,IAAK,IAAG,KAGJC,EAAUL,EAAMC,KAChBK,EAAW,EACXC,EAAS,CAAG,CAAAP,EAAMC,MAAOO,KAAKC,IAAM,CAAAT,EAAMI,KAAM,IAAI,IAyEjE,IAAAM,EAzBgB,SAAMC,EAAOF,EAAKG,EAAMD,GAEpC,MAAQE,KAAMC,EAAKR,EAAQS,KAAEA,EAAOV,EAASI,IAAKO,GAAML,EAE7C,IAAAM,EAAX,MAAMC,EAAe,QAAVD,EAAAjB,EAAMe,UAAK,IAAXE,IAAeF,EACpBd,EAAQiB,IAAMlB,EAAMC,KACf,IAAAkB,EAAAC,EAAX,MAAMC,EAAyB,QAApBD,EAAQ,QAARD,EAAAV,UAAOO,SAAC,IAARG,IAAYZ,EAAOW,UAAE,IAArBE,IAAyBF,EAM9BI,EAAQJ,GAAWjB,EAAO,EAAIa,IAAMS,MAAMF,GAAKA,IAAMA,GAAzCP,EACZZ,EAAKoB,EAAGR,EAGd,OAAIF,GAEJA,EAAIC,KAAOS,EACXV,EAAIV,GAAKA,EACTU,EAAIG,KAAOA,EAEJH,GANaX,EAAOC,EAAKoB,C,EC5EpC,MAAME,EAAIC,MAAMC,UAAUC,OAiBbC,EAAS,CAACC,EAAGC,EAAGC,SAEhBC,IAARD,EAAoBP,EAAES,KAAKH,EAAGD,GAAKL,EAAES,KAAKH,EAAGD,EAAGE,G,IAErDG,EAAeN,E,ICMfO,EAPmB,CAACN,EAAGC,EAAGC,EAAK,KAAOH,GAAO,CAACG,EAAIK,EAAGC,KAC7CN,EAAGM,GAAKR,EAAEO,EAAGC,EAAGP,EAAGC,GAEZA,IAEXD,EAAIC,GAAMD,GCzBd,MAAMQ,EAAIb,MAAMC,UAAUa,Q,IAkB1BC,EANoB,CAACX,EAAGC,KACpBQ,EAAEL,KAAKH,EAAGD,GAEHC,GCfX,MAAMW,KAAEC,GAASjB,MAAMC,WACjBiB,SAAEC,GAAaC,QACfC,MAAEC,GAAUC,K,IAmBlBC,EAHqB,CAACC,EAAI,EAAGrD,EAAOsD,EAAOC,IACvCV,EAAKT,KAAMW,EAAUM,GAAKzB,MAAMsB,EAAMG,IAAMA,EAAIrD,EAAOsD,EAAOC,G,ICFlEC,EAFyB,CAAChB,EAAGa,KAAOb,EAAGa,EAAGA,GAAGA,E,ICK7CI,EAHoB,CAACjB,EAAGa,EAAGE,EAAMF,EAAEK,SAC9BH,GAAiB,IAARA,EAAaF,EAAEG,EAAUhB,EAAGe,IAAQC,EAAUhB,EAAGa,GCZxD,MAAMM,EAAW,CAAC,EAAC,GAAI,GAAK,EAAC,EAAI,GAAI,CAAC,GAAG,IAcnCC,GAZQD,EAASD,OAYLC,EAASE,QCT3B,MAAMC,EAAUC,ECXR,6bDmBFC,EAAkB,IAC7B,CAAC,oBAAqB,4BAGXC,EAAsB,IACjC,CAAC,yBAA0B,+BAGhBC,EAAqB,IAAM,CAAC,sBAG5BC,EAAS,SAQTC,EAAiB,EAQjBC,EAAiB,EAGjBC,EAAgB,EAMhBC,EAAW,EAqBXC,EAAW,EAGXC,EAAY,IAAM,CAACJ,GAEnBK,EAAe,IAAM,IAAId,GAKzBe,EAAU,QAEVC,EAAS,UAETC,EAAS,UAETC,EAAU,QAEVC,GAAW,EAEXC,GAAa,EAEbC,GAAW,EAGXC,EAAW,G,IEiSpBC,EAAMC,EAyBJC,EAAMC,EAANC,EAAoBC,EApY1B,MAAMC,UAAEC,GAAc1C,OAGT2C,EAAQ,CAAEC,OAAQ,IAWlBC,EAAa,CAAC7F,EAAO8F,EAAczB,IAC7C,GAAMrE,GAAWA,GAAS8F,KACvBC,QAAQC,MAAM,kCAAkChG,qDACV8F,kBACtC9F,EAAO8F,GAiCN,SAASG,EAAWC,EAAQJ,EAAczB,EAAgBnC,EAAK,IACpEI,GAAI,CAAC6D,EAAG3D,IAAMA,GAAG0D,EAAQhE,GAAIwB,OAASwC,EAAOxC,OAG7C,IAAI0C,EAAWN,EAEXF,EAAS,EAETS,EAAW,EACXC,EAAUC,IAEd,IAAI,IAAI/D,EAAI,EAAGoD,EAASM,EAAOxC,QAAS,CACtC,MAAMnB,EAAIqD,EAAOpD,EACXxC,EAAQkG,EAAOhE,EAAGK,IAExB,IAAIsD,EAAW7F,EAAO8F,GAAgB,OAAO5D,EAG7C,MAAMsE,EAAMJ,EAASpG,EAQrB,GANGwG,GAAQ,GAAOA,EAAMF,IACtBA,EAAUE,EACVH,EAAW9D,GAIG,IAAb+D,GAAoB/D,EAAI2D,EAAOxC,OAAO,IAAQlB,MAC5C,CAEH,MAAMiE,EAAOvE,EAAGmE,GAEhBnE,EAAGmE,GAAYnE,EAAG0D,GAClB1D,EAAG0D,GAAUa,GAGXL,GAAYF,EAAOO,IAAS,IAAOL,EAAWN,GAEhDO,IAAaT,EACbU,EAAUC,IACV/D,EAAI,C,EAIR,OAAON,C,CAiQF,SAASwE,EAAWC,EAAMzE,EAAKyE,GACpC,MAAMC,EAAUD,aAAA,EAAAA,EAAMC,QAEtB,IAAIA,EAAW,OAAO1E,EAEtB,MAAM2E,OAAEA,EAAMC,SAAEA,EAAQC,eAAEA,GAAmBJ,EACvCK,EAAQ9E,EAAG8E,MAAQ,GACnBC,EAAQ,G,MAEd/E,EAAG0E,QAAUA,EAEb,MAAMM,EAAM,CAAChG,EAAO,IACP,QAAXI,GAAA6D,EAAA8B,GAAM7B,EAAAlE,UAAK,IAAAI,IAAX6D,EAAMC,GAAU9C,GAAI,CAACd,EAAGe,IAAM,CAACrB,EAAMqB,IAAIwE,GAErCI,EAAe,CAACC,EAAMpH,IAAU,SAASO,EAAI8G,EAAKC,EAAQC,GAC9D,IACIC,EADAtG,EAAO,EAGX,IAAc,IAAXoG,EAAmB,OAAOjF,EAAO9B,EAAK2G,EAAIhG,GAAOmG,GAC/C,GAAG3B,EAAU4B,GAAWE,EAAUT,EAAeO,OACjD,KAAiB,IAAdA,EAAO,GAAe,OAAOjF,EAAO9B,EAAK2G,EAAII,EAAO,IAAKD,GAE/DnG,EAAOoG,EAAO,GACdE,EAAUT,EAAeO,EAAO,G,CAGlC,IAAK5B,EAAUxE,KAASwE,EAAU8B,GAChC,OAAOzB,QAAQC,MAAM,uCACnBY,EAASD,EAAMS,EAAMpH,EAAOsH,EAAQC,EAAGrG,EAAMsG,GAIjD,MAAMtF,EAAMmF,GAAO,GAEb7E,EAAIN,EAAGuF,WAAU,EAAEpG,EAAGG,KAAOH,IAAOH,GAAUM,IAAMgG,I,QAO1D,OAJ4B,QAA3BjG,GAACgE,EAAW,QAAXjE,GAAA+D,EAAA2B,GAAM1B,EAAA8B,UAAK,IAAA9F,IAAX+D,EAAMC,GAAU,IAAIE,EAAAxF,UAAM,IAAAuB,IAA1BgE,EAAoBC,GAAW,IAE9BkC,KAAKlF,EAAK,EAAIN,EAAGwF,KAAK,CAACxG,EAAMsG,IAAU,EAAIhF,GAEvCN,C,EAiBT,OALAA,EAAGyF,QAAUrF,GAAI,CAAC8E,EAAMQ,IAAMvF,GAAO,CAACgF,EAAKG,IACrCnF,EAVgB,CAAC+E,GAAS,CAACC,EAAKrH,KACpC,MAAM6H,GAA6B,IAAbjB,EAAoBA,EAAUA,EAAQ5G,GAE5D,OAAU6H,GAAkC,IAAjBA,GACH,IAAnBA,GAA4BnC,EAAUmC,GACvCV,EAAaC,EAAMpH,EAAnBmH,CAA0BE,EAAKQ,GAC/BxF,EAAO8E,EAAaC,EAAMpH,GAAQ6H,EAAcR,GAHHA,CAGO,EAI7CS,CAAcF,GAAId,EAASU,GAAUH,IAC9CD,EAAM,OACRP,EAAQ,IAEH3E,C,CAkBF,MAAM6F,EAAY,CAACpB,EAAMzE,EAAKyE,IACnCD,EAAWC,EAlON,SAAmBA,EAAO,GAAIzE,EAAKyE,GACxC,IAAIA,EAAQ,OAAOzE,EAEnB,MAAMgE,OACFA,EAASzB,IAAWqB,YACpBA,EAAczB,EAAc2D,WAAEA,EAAa1D,EAAasB,OAExDA,EAASK,EAAWC,EAAQJ,EAAaH,EAAMC,SAC7Ce,EAENzE,EAAGgE,OAASA,EACZhE,EAAG8F,WAAaA,EAChB9F,EAAG4D,YAAcA,EACjB5D,EAAG0D,OAASA,EAEZ,MAAMiB,EAAS3E,EAAG2E,OAAS,CAAC,IACtBC,EAAW5E,EAAG4E,SAAW,CAAC,IAC1BC,EAAiB7E,EAAG6E,eAAiB,GACrCkB,EAAc/F,EAAG+F,YAAc,GAC/BC,EAAgBhG,EAAGgG,cAAgB,GAEzC,IAAI9B,EAAW,EAEf,MAAM+B,EAAYvC,EAAW,CAACO,EAAG3D,IAAM0D,EAAO1D,GAAQD,GAAMA,EACtD6F,EAAYxC,EAAYpD,GAAMoD,EAAOpD,GAAQA,GAAMA,EAEzD,OAAOH,GAAO,CAACH,EAAIK,EAAGC,KAClB,MAAM6F,EAAQD,EAAS5F,GACjBxC,EAAQmI,EAAS5F,EAAG8F,GAE1B,IAAIxC,EAAW7F,EAAO8F,GAAgB,OAAO5D,EAE7C,IAAI0F,EAAIf,EAAOnD,OAAO,EAClB0D,EAAOP,EAAOe,GACdpG,EAAIsF,EAASpD,OAAO,EACpB8D,EAAUV,EAAStF,GAkBvB,OAhBI4E,GAAYpG,GAAS8F,GACvBM,EAAWpG,EACXwB,EAAIsF,EAASY,KAAKF,EAAU,IAAI,EAC/BJ,EAAK1D,QAAUsE,IAAgBJ,EAAIf,EAAOa,KAAKN,EAAO,IAAI,GAC3DA,EAAKM,KAAKlG,GACV0G,EAAcR,KAAKE,IAEG,IAAhBR,EAAK1D,SACX0D,EAAKM,KAAKlG,GACV0G,EAAcR,KAAKE,IAGrBJ,EAAQE,KAAKW,GACbtB,EAAesB,GAAS7G,EACxByG,EAAYI,GAAST,EAEd1F,CAAE,GAEXgE,EAAQhE,E,CA2KOoG,CAAU3B,EAAMzE,IC/bnC,MAAMY,SAAEyF,GAAQ9C,UAAE+C,IAAcxF,OAqBzB,SAASyF,GAASzI,GACvB,MAAM0I,MAAEA,EAAKC,EAAEA,EAACC,EAAEA,EAACC,MAAEA,EAAKC,KAAEA,EAAIC,KAAEA,EAAM,EAAGC,GAAOhJ,E,IAE3CsB,EAAAC,EAAA0H,EAAAC,EAAAC,EAAAC,EAAP,OAEY,QAFLA,EAED,QAFCD,EACiD,QADjDD,EACqB,QADrBD,EAAe,QAAf1H,EAAU,QAAVD,EAAAoH,UAASC,SAAC,IAAVrH,IAAcsH,SAAC,IAAfrH,IACJsH,GAASJ,GAASI,UAAO,IADrBI,IAC0BH,GAAQL,GAASK,UAAM,IADjDI,IAELH,SAAI,IAFCI,IAEGH,SAAE,IAFLI,IAEUb,GAAUvI,GAASA,EAAQ,I,CAsBvC,SAASqJ,GAAUrJ,GACxB,MAAMsJ,OAAEA,EAAMC,EAAEA,EAACC,EAAEA,EAACX,MAAEA,EAAKC,KAAEA,EAAIC,KAAEA,EAAM,EAAGU,GAAOzJ,E,IAE5CsB,EAAAC,EAAA0H,EAAAC,EAAAC,EAAAC,EAAP,OAEY,QAFLA,EAED,QAFCD,EACmD,QADnDD,EACsB,QADtBD,EAAgB,QAAhB1H,EAAW,QAAXD,EAAAgI,UAAUC,SAAC,IAAXjI,IAAekI,SAAC,IAAhBjI,IACJsH,GAASQ,GAAUR,UAAO,IADtBI,IAC2BH,GAAQO,GAAUP,UAAM,IADnDI,IAELH,SAAI,IAFCI,IAEGM,SAAE,IAFLL,IAEUb,GAAUvI,GAASA,EAAQ,I,KAsB5B0J,GAAsBC,GAAtCC,GADK,MAYMC,GAAkBf,GAASxG,GAAI,CAAC6D,EAAG3D,IAAMA,GACpDY,EAAMoF,GAAUM,GAAOA,EAbO,EAACA,EAAO,EAAGQ,EAAS,IACvC,QAAXM,GAAAd,aAAA,EAAAA,EAAMgB,aAAK,IAAXF,OAA8B,QAAdF,GAAAjB,GAASK,UAAK,IAAdY,MAAkB,IAAqB,QAAjBC,GAAAN,GAAUC,UAAO,IAAjBK,MAAqB,GAY7BI,CAAiBjB,IAAQ,GAS5CkB,GAAaC,GAAW1B,GAAU0B,GAAS,GAAGA,EAAQ,K,ICyVtCC,GAASC,GAiDNC,GAAOC,GA3dvC,MAAM5E,UAAE6E,IAActH,OAgUf,SAASuH,IAAS/C,QAAEA,EAAOgD,YAAEA,GAAe1J,EAAQ,GAAIoB,EAAKpB,GAClE,MAAM2J,MACFA,EAAQjG,EAAQkG,QAAEA,EAAOC,QAAEA,EAAOhE,KAAEA,EAAIiE,MAAEA,EAAQ3F,EAAQgF,MAAEA,EAAKY,KAEjEA,EAAOlG,EAAO1E,IAAEA,EAAM2E,EAAMkG,IAAEA,EAAMjG,EAAMkG,KAAEA,EAAOjG,EAAOkG,MAC1DA,EAAQjG,EAAQkG,QAAEA,EAAUjG,GAC1BlE,EAEAoK,EAASlB,GAAUC,G,IACA3I,EAAAC,EAAzB,MAAMmH,EAAQvF,KAAKF,MAA+B,QAAzB1B,EAAe,QAAfD,EAAAmH,GAAS3H,UAAM,IAAfQ,IAAmB4J,SAAM,IAAzB3J,IJ7RH,K,II8RI0H,EAAAC,EAA1B,MAAMI,EAASnG,KAAKF,MAAgC,QAA1BiG,EAAgB,QAAhBD,EAAAI,GAAUvI,UAAM,IAAhBmI,IAAoBiC,SAAM,IAA1BhC,IJxRH,KI0RvBhH,EAAGyE,KAAOA,EACVzE,EAAGwI,QAAUA,EACbxI,EAAGyI,QAAUA,EAEb,MAAMzE,OACFA,EAASzB,IAAW0G,YAAEA,EAAc/G,EAAgB0C,SAAUsE,GAC5DzE,EAENA,EAAKwE,YAAcA,EACnBxE,EAAKT,OAASA,EAMd,MAAMmF,EAAe,CAACjE,EAAMnH,IAC1BoC,GAAO,CAACpC,EAAKuB,IACT2B,KAAKjD,IAAID,EAAKoC,GAAO,CAACiJ,EAAK/I,IAAM+I,EAAIpF,EAAO3D,IAAI6I,EAAY5J,GAAI,KAClE4F,EAAMnH,GASJsL,EAAmBX,EACrBvI,GAAO,CAACpC,EAAK2H,IAAMyD,EAAazD,EAAG3H,IAAM0G,EAAKE,OAAQsE,GADzB,K,IAMxBK,EAFT,MAAM1C,EAAO5G,EAAG4G,KAAO,C,KACrB+B,E,MAAMG,E,QAAOC,EAASE,YAAaI,UAAiBJ,EACpDV,MAAmB,QAAZe,EAAAf,EAAM/G,cAAM,IAAZ8H,IAAgBf,EACvB5D,OAAQ,EAAG4E,aAAc,EAAG3E,SAAU,EAAG4E,OAAQ,E,MACjDhD,E,OAAOY,EAAQT,MAAO,CAACH,EAAOY,GAASQ,MAAOpB,EAAMY,GAIhDxC,EAAW5E,EAAG4E,SAAW,GAEzBD,EAAS3E,EAAG2E,OAAS,GAE3B,IAAI8E,EAMJ,MAAMC,EAAa,CAACxF,EAAUuC,EAAGY,EAAGrI,EAAMkG,IAAS,CAACiB,EAAOwD,EAAG1F,EAAG2F,KAE/D,MAAM5J,EAAK,C,SAAEkE,EAAUsC,MAAOC,EAAGW,OAAQC,E,KAAGsB,E,IAAM5K,E,IAAK6K,E,KAAKC,GAS5D,IAAIgB,EAAQF,EACRrK,EAAIsK,aAAA,EAAAA,EAAQC,GAGZvK,IACFA,EAAIgG,aAAA,EAAAA,EAAUtF,GACd6J,EAAQjD,EAAKhC,YAMf,MAAMzF,EAAIiJ,GAAUpJ,GACd0G,EAAI0C,GAAUlD,GACd5E,EAAI8H,GAAUjC,G,MAoBpB,OAjBAnG,EAAGsF,QAAUhG,EAEbU,EAAG6J,MAAQA,EAEX1K,IAAMa,EAAGhB,KAAOA,GAEb0G,IAED1F,EAAG4J,MAAQhD,EAAK4C,SAChBxJ,EAAGkF,KAAOA,GAGZ5E,IAAMN,EAAG8J,IAAMZ,EAAYlJ,EAAGmG,MAAQA,IAK9BhH,GAAMuG,GAAKpF,IAAoB,QAAdlB,GAAA4I,GAAApD,GAASqD,GAAAjJ,UAAK,IAAAI,IAAd4I,GAASC,IAAU,IAAI9B,GAASnG,GAAIsF,QAAUtF,CAAE,EAOrE+J,EAAU,CAAC/K,EAAM4K,IAAU,CAAC1E,EAAMiB,K,IAKrB/G,EAAjB,MAAM8E,EAAiC,QAAtB9E,EAAAwK,UAASP,SAAa,IAAtBjK,IACd8F,EAAQiE,EAAajE,EAAM+D,GAAeA,EAKvCjJ,EAAK,C,MACT8I,E,QAAOC,E,MAASvC,E,OAAOY,EAEvBwC,MAAOA,UACLxJ,EAAIsJ,EAAWxF,EAAUsC,EAAOY,EAAQpI,EAAMmH,GAAQjB,EAGnDwD,EAAUe,YAAc,GAAM,KAIrCzJ,EAAGsI,YAAcA,aAAA,EAAAA,EAActI,GAK/BA,EAAG6J,MAAQjD,EAAK2C,eAEbrE,IACDlF,EAAG8J,IAAM5E,EACTlF,EAAGkF,KAAO0B,EAAKjC,UAGjB,MAAMxF,EAAIiJ,GAAUpJ,GACdsB,EAAI8H,GAAUjC,G,MAOpB,OALAhH,IAAMa,EAAGhB,KAAOA,GAChBsB,IAAMN,EAAGmG,MAAQA,GAITjB,GAAS/F,GAAKmB,IAAkB,QAAZjB,GAAA6I,GAAAvD,GAAOwD,GAAAnJ,UAAK,IAAAK,IAAZ6I,GAAOC,IAAU,IAAIhC,GAASnG,GAAIsI,YAE1DtI,CAAE,EAWR,GAJAA,EAAGuI,MAAQnI,GAAI,CAACuE,EAAQ3F,IAAS2F,GAAUvE,EAAI2J,EAAQ/K,GAAOyF,EAAKE,SAChEyD,GAAWG,GAASrH,EAAMqH,GAASA,EAAQ,IAG1CG,EAAS,OAAO1I,EAKpB,MAAMgK,EAAUlC,GAAUY,EAAMX,O,IAErBd,EAAAC,EAAX,MAAM+C,EAA+B,QAA1B/C,EAAe,QAAfD,EAAAV,GAASmC,UAAM,IAAfzB,IAAmB+C,SAAO,IAA1B9C,IAA8BzC,EAAKG,SAASpD,OAAOgF,E,IACnD0D,EAAAC,EAAX,MAAMC,GAAgC,QAA3BD,EAAgB,QAAhBD,EAAA/C,GAAUuB,UAAM,IAAhBwB,IAAoBF,SAAO,IAA3BG,IAA+BvD,EAAK2B,MAAMnB,E,IAI9CiD,GAECC,GAKR,OATAtK,EAAG0I,MAAQ,CAET1D,IAAc,QAATqF,GAAA3B,EAAM1D,WAAG,IAATqF,MAAaX,EAAWL,EAAeY,EAAIG,GAA9BV,GAElBa,KAAgB,QAAVD,GAAA5B,EAAM6B,YAAI,IAAVD,MAAcP,EAAQ,MAAM,EAAdA,IAGtBnD,EAAK8B,MAAQ,CAAElC,MAAOyD,EAAI7C,OAAQgD,GAAIzD,MAAO,CAACsD,EAAIG,IAAKxC,MAAOqC,EAAGG,IAE1DpK,C,CClhBT,OAASwB,OAAQgJ,KAAUhJ,OAAQiJ,KAAS,kBAAkBC,MAAM,UAWvDC,GAAQjE,GAAMkE,SAAS1K,KAAKwG,GAAGmE,MAAML,IAAQC,I,IC6yBpCK,GAAMC,GA/xBrB,MAAMC,GAAK,QAELC,GAAO,OAEdC,GAAKC,KAAKC,UAGHC,GAEA,OAFAA,GAIE,SAJFA,GAIyB,SAJzBA,GAKG,UALHA,GAKyB,OAmD/B,SAASC,GAAUC,EAAOC,EAAKC,EAAK,GAAIC,GAASH,aAAA,EAAAA,EAAOG,SAC7D,IAAwB,KAApBA,YAA4B,OAAO,KAClC,IAAIA,EAAU,MAAO,GAE1B,MAAMpM,EAAIqL,GAAKe,GAEf,MAAe,aAAPpM,EAAoBoM,EAAOH,EAAOC,EAAKC,EAAIC,GACvC,WAAPpM,EAAkBoM,EAClBA,aAAoBC,QAAYH,KAAOE,EACxCJ,GAAUC,EAAOC,EAAKC,EAAIC,EAAOF,IAChCC,EAAMH,GAAUC,GAAQC,EAAOA,EAAI,IAAM,IAAIC,EAAI,GAAIC,GACtD,I,KA+B6BE,GAJ5B,MAAMC,GAAkB,CAAClD,EAAMmD,EAAM/L,EAAGgM,EAAU,GAAIC,EAAOrD,IAClE,aAAamD,SAAY/L,EAAEyB,UAC3BrB,GAAO,CAAChB,EAAGkB,EAAGC,K,IAEmBjB,EAD7B,OAAAF,EAAE6L,IAAIe,GAAWA,EAAQ,KAAKpD,EAC5B,IAAImD,KAAQxL,OAAO0L,KAAsB,QAAdJ,GAAM,QAANvM,EAAAgB,EAAE4L,YAAI,IAAN5M,OAAA,EAAAA,EAAAa,KAAAG,EAAS,aAAK,IAAduL,MAAkBvL,KAAK,GACtDN,EAAG,IA6BMmM,GAAmB,CAACvD,EAAMmD,EAAM/L,EAAGgM,EAAU,GAAIC,EAAOrD,IACnEkD,GAAgBlD,EAAMmD,EAAM/L,EAAGgM,EAASC,GAAM,KAG9C,oBAAoBF,iBAAoBA,0BACtC,oBAAoBA,wBACtB,WAAWA,UAAa3L,GAAO,CAAChB,EAAGkB,EAAGC,IACjCA,EAAK,UAAUA,OAAOwL,KAAQxL,OAAOnB,KAAO,GAAG2M,KAAQxL,KAC1DP,EAAG,QA+BMoM,GAAoB,CAACxD,EAAMmD,EAAM/L,EAAGgM,EAAU,GAAIC,EAAOrD,IACpEkD,GAAgBlD,EAAMmD,EAAM/L,EAAGgM,EAASC,GAAMhB,IAC7Ce,GAAWA,EAAQ,KAAKpD,EAAK,IAAImD,KAAQA,QAC1C3L,GAAO,CAAChB,EAAG8E,EAAG3D,IAAMnB,EAAE6L,GAAGc,EAAK,IAAIxL,QAAQwL,KAAQxL,MAAMP,EAAG,IAAI,KAC/D,WAAW+L,UAAaA,SA2BbM,GAAe,CAACzD,EAAMmD,EAAM/L,EAAGgM,EAAU,GAAIC,EAAOrD,IAC/DkD,GAAgBlD,EAAMmD,EAAM/L,EAAGgM,EAASC,GAAMhB,IAC7Ce,GAAWA,EAAQ,KAAKpD,EAAK,IAAImD,KAAQA,UAAaE,KAAQF,QAC7D3L,GAAO,CAAChB,EAAG8E,EAAG3D,KAAOnB,GAAKA,EAAE,MAAM2M,EAAK,IAAIxL,GAAGP,EAAG,UACnD,WAAW+L,UAAaA,SAqDbO,GAAc,CAAC1D,EAAMmD,EAAM/L,EAAGgM,EAAU,GAAIO,EAAO,EAAGN,KAChEM,GAAS,EAAIF,GACS,UAApBL,EAASQ,OAAqBL,GAAmBC,IACjDxD,EAAMmD,EAAM/L,EAAGgM,EAASC,G,IA+yB3BQ,GADK,MAAMC,GAAY,CAAC7N,EAAO6M,IACM,QAArCe,GAAAlB,GAAU1M,EAAOyM,GAAiBI,UAAG,IAArCe,MAzsBK,SAAqB5N,EAAO6M,GACjC,MAAMD,EAAMH,GACNqB,EAAOpB,GAAU1M,EAAO4M,EAAKC,GAEnC,GAAY,OAATiB,EAAiB,OAAOA,EAE3B,MAAMjI,KAAEA,EAAI8D,MAAEA,EAAKoE,MAAEA,EAAQtK,EAAQuE,KAAEA,EAAMgG,IAAK3N,EAAIgD,GAAWrD,GAC3DmG,MAAEA,EAAQ/B,GAAapE,GACvBoF,OAAEA,EAAMY,SAAEA,EAAUD,QAAUnD,OAAQqL,IAAcpI,E,IAC3C6E,EAAf,MAAMwD,EAAqB,QAAZxD,EAAAf,EAAM/G,cAAM,IAAZ8H,IAAgBf,EACzBX,EAAQhB,aAAA,EAAAA,EAAMgB,MAEd+B,EAAI5E,GACR,SAASyG,KACPvM,KAAK0N,KAASzB,GAAGlH,MAAWkH,GAAGtG,MAAakI,KAAUD,KAAWjF,I,IAE1DxI,EAAX,MAAMY,EAAe,QAAVZ,EAAA2F,aAAA,EAAAA,EAAQ4E,UAAE,IAAVvK,IACTe,GAAO,CAAChB,EAAGmG,EAAShG,EAAG2E,EAAG3D,EAAI,IAAMH,GAAO,CAAChB,EAAGkB,IACzClB,EAAE,WAAWF,YAAYoB,KAAKf,MAC9B,WAAWL,aAAaoB,KAAK4K,GAAKJ,MAAMvK,EAAGA,GAAK0D,EAAO3D,WACzDiF,EAASnG,IACXyF,EAAU,KACXgD,EAAS,iBAAiBA,MAAY,IACvC,WAAW3I,aAAa2F,EAASpD,WACjC,WAAWvC,WAAW4N,MACtB,WAAW5N,cAAc6N,EAAOH,MAChC,WAAW1N,UAAU6N,MACrB,WAAW7N,UAAU0N,QAEvB,OAAQ5H,EAASA,EAAM4E,GAAK3J,EAAKA,C,CA6qB/B+M,CAAYnO,GA9kBT,SAAqBA,EAAO6M,GACjC,MAAMD,EAAMH,GACNqB,EAAOpB,GAAU1M,EAAO4M,EAAKC,GAEnC,GAAY,OAATiB,EAAiB,OAAOA,EAE3B,MAAQjE,QAAS/C,EAACjB,KAAEA,EAAMmI,IAAK3N,EAAIgD,EAAM8C,MAAEA,EAAQ/B,GAAapE,GAC1DoF,OAAEA,EAAMY,SAAEA,EAAQD,OAAEA,GAAWF,EAC/BS,EAAOP,EAAOe,GAEdiE,EAAI5E,GACR,SAASyG,KAAOvM,KAAKyG,KAAKwF,GAAGlH,MAAWkH,GAAGtG,MAAasG,GAAGvG,K,IAElDvF,EAAX,MAAMY,EAAe,QAAVZ,EAAA2F,aAAA,EAAAA,EAAQ4E,UAAE,IAAVvK,IACT,WAAWH,YAAYyG,MACvBvF,GAAO,CAAChB,EAAGmG,EAASqH,EAAO1I,EAAG3D,EAAI,IAAMH,GAAO,CAAChB,EAAGkB,IAC7ClB,EAAE,KACF,WAAWF,UAAUoB,KAAKiF,MAC1B,WAAWrG,WAAWoB,KAAKsM,MAC3B,WAAW1N,WAAWoB,iBAAiBpB,WAAWoB,MAChD4K,GAAKJ,MAAMvK,EAAGA,GAAK0D,EAAO3D,SAC9BuE,EAASU,GAAUnG,IACrB+F,EAAM,IAAI,KAEd,OAAQH,EAASA,EAAM4E,GAAK3J,EAAKA,C,CAsjBZgN,CAAYpO,GA7a5B,SAAsBA,EAAO6M,GAClC,MAAMD,EAAMH,GACNqB,EAAOpB,GAAU1M,EAAO4M,EAAKC,GAEnC,GAAY,OAATiB,EAAiB,OAAOA,EAE3B,MAAQjE,QAAS/C,EAAI,EAACjB,KAAEA,EAAI6H,KAAEA,EAAMM,IAAK3N,EAAIgD,GAAWrD,GAClDmG,MAAEA,EAAQ/B,GAAapE,GACvB6G,QAAEA,EAAOX,MAAEA,GAAUL,EACrBwI,EAAcxH,aAAA,EAAAA,EAAUC,GACxBwH,EAAYpI,aAAA,EAAAA,EAAQY,GAEpBiE,EAAI5E,GACR,SAASyG,KAAOvM,KAAKyG,KAAKwF,GAAG+B,MAAgB/B,GAAGgC,MAAcZ,I,IAErDlN,EAAX,MAAMY,EAAe,QAAVZ,EAAA2F,aAAA,EAAAA,EAAQ4E,UAAE,IAAVvK,KACN6N,EACD,WAAWhO,cAAc+L,GACvBqB,GAAY,QAASpN,EAAE,UAAWgO,EAAa,QAASX,OAF3C,KAGdY,EACD/M,GAAO,CAAChB,EAAG2F,EAAOzE,IACd,GAAGlB,YAAYF,aAAaoB,IAAI2K,GAC9BqB,GAAY,MAAOpN,EAAE,SAASoB,EAAGyE,EAAO,QAASwH,QACrDY,EAAW,IAJA,IAMjB,OAAQnI,EAASA,EAAM4E,GAAK3J,EAAKA,C,CAoZOmN,CAAavO,GA5ThD,SAAmBA,EAAO6M,G,IAQXrM,EAPpB,MAAMoM,EAAMH,GACNqB,EAAOpB,GAAU1M,EAAO4M,EAAKC,GAEnC,GAAY,OAATiB,EAAiB,OAAOA,EAE3B,MAAQjE,QAAS/C,EAAI,EAACjB,KAAEA,EAAIiE,MAAEA,EAAK4D,KAAEA,EAAMM,IAAK3N,EAAIgD,GAAWrD,GACzDmG,MAAEA,EAAQ/B,GAAapE,EACvBqO,EAA0B,QAAZ7N,EAAAqF,EAAKgB,eAAO,IAAZrG,OAAA,EAAAA,EAAesG,GAC7BS,GAASuC,EAETiB,EAAI5E,GACR,SAASyG,KAAOvM,KAAKyG,KAAKwF,GAAG+B,MAAgB9G,KAASmG,IAExD,IAAItM,EAAK+E,aAAA,EAAAA,EAAQ4E,GAEjB,GAAS,MAAN3J,EAAc,OAAOA,EAExB,MAAMoN,EAASd,GAAQ,EAEjBhH,EAAU,WAAW8H,EAAS,GAAK,MAEnCtN,EAAIb,EAAE,WACNoO,EAAM,WAAWvN,EAEjBwN,EAAK,oBAELC,EAAM,WAAWzN,QAAQkL,GAAGlL,IAC5B0N,EAAQ,WAAW1N,WAAWwN,KAAMtC,GAAGlL,IAEvC2N,EAAKxO,EAAE,WAEPK,EAAI,IAAIL,E,MAEd,MAAMyO,EAAuC,QAAzBrO,GAAAyL,GAAA/F,GAAMgG,GAAAS,EAAI,uBAAe,IAAAnM,IAAzByL,GAAMC,IAAwB,G,IACfhE,EA2JnC,OAxJA/G,GAAMmG,EAAS,GAAK,WAAWlH,uBAHjByO,EAAYlM,OAA4B,QAAnBuF,EAAAkG,aAAA,EAAAA,EAAazL,cAAM,IAAnBuF,IAAuB,IAKrDZ,EAKD,wKAAYlH,oCAAoCK,eAChD+N,EAAI,0BAA0BrC,GAE5B,aAAa1L,wBAAwB0L,GACrC,QAAQ1L,mBAAmB0L,GAE3BqB,GAAY,OAAQpN,EAAE,OACpBmB,GAAI,CAAC6D,EAAG3D,IAAMgF,EAEV,gBAAgBmI,EAAGnN,QAAQhB,aAAamO,EAAGnN,UAAUhB,SACvD2N,EAAaS,GACf,GAAIpB,GAdR,6DAgBA,oDAAoDgB,SACpD,YAAYrO,oCAAoCK,eAChD+N,EAAI,6BAA6BC,KAAMtC,GAErC,aAAa1L,yBAAyB0L,GACtC,SAAS1L,iBAAiBgO,MAAOtC,GACjC,QAAQ1L,oBAAoB0L,GAE5BqB,GAAY,OAAQpN,EAAE,OACpBmB,GAAI,CAAC6D,EAAG3D,IACJgF,EAAQ,WAEJ,SAASmI,EAAGnN,QAAQhB,YAAYA,UAEhC,OAAOmO,EAAGnN,QAAQhB,UACpB,MAAMA,UACV2N,EAAaS,GACf,GAAIpB,GAjCR,sEAmCAiB,EAAI,SAAStO,YAAYA,eACzBuO,EAAM,WAAWvO,YAAYA,cAAcqO,OAK3C,6JAAYrO,oCAAoCK,eAChD+N,EAAI,0CAA0CrC,GAE5C,QAAQ1L,+BAA+B0L,GACvC,QAAQ1L,mBAAmBA,OAAO0L,GAElC,QAAQ1L,qBAAqBA,OAAO0L,GAIpC,QAAQ1L,qCAAqC0L,GAE7CqB,GAAY,OAAQpN,EAAE,OAEpBmB,GAAI,CAAC6D,EAAG3D,IACJgF,EAAQ,YAEN,SAAShG,oBAAoBmO,EAAGnN,SAAShB,QAAQA,UACrD2N,EAAaS,GACf,GAAIpB,GAtBR,6DAwBA,YAAYrN,oCAAoCK,eAChD+N,EAAI,6CAA6CC,KAAMtC,GAErD,QAAQ1L,gCAAgC0L,GACxC,QAAQ1L,oBAAoBA,QAAQ0L,GAEpC,QAAQ1L,sBAAsBA,QAAQ0L,GAItC,QAAQ1L,eAAegO,qCAAsCtC,GAE7DqB,GAAY,OAAQpN,EAAE,OAEpBmB,GAAI,CAAC6D,EAAG3D,IACJgF,EAAQ,YAEN,SAAShG,qBAAqBmO,EAAGnN,SAAShB,SAASA,WACvD2N,EAAaS,GACf,GAAIpB,GAAM,MACXc,EAaD,+QAAYnO,oCAAoCK,eAChD+N,EAAI,0CAA0CrC,GAG5C,QAAQ1L,+BAA+B0L,GACvC,QAAQ1L,mBAAmBA,OAAO0L,GAElC,SAAS1L,cAAcA,SAAS0L,GAEhC,SAAS1L,yBAAyB0L,GAClC,SAAS1L,eAAeA,OAAO0L,GAE/BqB,GAAY,OAAQpN,EAAE,OAEpBmB,GAAI,CAAC6D,EAAG3D,IACJgF,EAAQ,uBAEN,GAAGhG,iBAAiBmO,EAAGnN,QAAQhB,UAAUA,WAGzC,UAAUmO,EAAGnN,QAAQhB,QAAQA,WACjC2N,EAAaS,GACf,GAAIpB,GA1BR,+DA4BA,YAAYrN,oCAAoCK,eAChD+N,EAAI,6CAA6CC,KAAMtC,GAGrD,QAAQ1L,gCAAgC0L,GACxC,QAAQ1L,yCAAyCA,QAAQ0L,GAEzD,SAAS1L,eAAeA,UAAU0L,GAElC,SAAS1L,uCAAuC0L,GAChD,SAAS1L,gBAAgBA,QAAQ0L,GAEjCqB,GAAY,OAAQpN,EAAE,OAEpBmB,GAAI,CAAC6D,EAAG3D,IACJgF,EAAQ,uBAEN,GAAGhG,kBAAkBmO,EAAGnN,QAAQhB,WAAWA,YAG3C,UAAUmO,EAAGnN,QAAQhB,SAASA,YAClC2N,EAAaS,GACf,GAAIpB,GAlDR,kEAoDAiB,EAAI,SAAStO,YAAYA,aAAaA,WAAWA,eACjDuO,EACE,WAAWvO,YAAYA,aAAaA,WAAWA,cAAcqO,OA9D/D,+DACAC,EAAI,SAAStO,YAAYA,aAAaA,WAAWA,eACjDuO,EACE,WAAWvO,YAAYA,aAAaA,WAAWA,cAAcqO,SA4D9D,KArJM,IAuJLvI,EAASA,EAAM4E,GAAK3J,EAAKA,C,CA8H2B2N,CAAU/O,GCllCjE,MAEMgP,GAAQ,CAAC/O,EAAK6H,EAAGY,EAAGuG,EAAGpH,MAAQ5H,IAAQA,EAAM,IACrDA,EAAI,GAAK6H,EACT7H,EAAI,GAAKyI,EACTzI,EAAI,GAAKgP,EACThP,EAAI,GAAK4H,EACV5H,G,ICsGoCiP,GAAjC,SAASC,GAAYnP,EAAOoB,GAAmB,QAAd8N,GAAAlP,EAAMoP,gBAAQ,IAAdF,MAAkB,KACxD,MAAQlB,IAAK3N,EAAIgD,EAAMsG,MAAEA,EAAK9D,KAAEA,EAAIkI,MAAEA,EAAQtK,GAAazD,GACrDgG,SAAEA,GAAaH,E,IACN6E,EAAf,MAAMwD,EAAqB,QAAZxD,EAAAf,EAAM/G,cAAM,IAAZ8H,IAAgBf,EACzB0F,EAAYrJ,EAASpD,OACrB0M,EAAa,GACbC,EAAY,G,IAUkB/O,EASTC,EAjB3BW,EAAGf,EAAE,WAAa,CAACgF,EAAG9E,IAAMA,EAAEqJ,QAO9BxI,EAAGf,EAAE,cAAgB,CAACgF,GAAK2C,MAAQD,MAAOxH,EAAGuJ,MAAO0F,MACjDjP,EAAKyO,GAAMM,KAAe/O,KAAe,QAARC,EAAAgP,aAAA,EAAAA,EAAGzH,aAAK,IAARvH,IAAYD,GAAMyO,GAAMM,GAE5DlO,EAAGf,EAAE,aAAe,EAAGoP,mBAAoB5H,EAAG6H,oBAAqBjH,MACjE,ODhIuBX,ECgIND,EDhISa,ECgIND,IDhIFxI,ECgIZsP,KDhIoCtP,EAAM,IAAMA,EAAI,GAAK6H,EAAK7H,EAAI,GAAKyI,EAAIzI,EAAhE,IAACA,EAAK6H,EAAGY,CCgIJ,EAMxBtH,EAAGf,EAAE,UAAY,CAACgF,EAAG9E,K,IAAMC,EAAO2H,EAAP,OAAY,QAAZ1H,EAAO,QAAPD,EAAAD,EAAEuJ,aAAK,IAAPtJ,GAAY,QAAZ2H,EAAA3H,EAAS4F,WAAG,IAAA+B,OAAZ,EAAYA,EAAEzB,eAAO,IAArBjG,IAAyB,IAAI,EAMxD,MAAMkP,EAAeC,GAMnB/N,GAAK,CAACwD,EAAG3E,IAAMU,EAAGf,EAAE,UAAUuP,EAAKP,EAAW3O,MAC1C,CAAC2E,GAAKyE,MAAO0F,EAAG5F,QAASrJ,EAAGwN,MAAO8B,EAAI9B,EAAO/H,SAAU8J,M,IACzCtP,EAAiBC,EAA7B,OAAA+O,EAAK,KAAwB,QAAjBhP,EAAAmC,EAAKpC,EAAEsP,EAAED,EAAKE,UAAG,IAAjBtP,GAAsB,QAAtBC,EAAAD,EAAoBE,UAAE,IAAAD,OAAtB,EAAsBA,EAAEiG,OAAO,GAChDV,GAGJ,IAAI,IAAI4J,EAAM,EAAGG,EAAK7B,EAAOH,EAAO6B,EAAMG,IAAMH,EAAOD,EAAYC,GAEnE,OAAOxO,C,KC2CS4O,GAAMC,GACNC,GAAMC,GAoCZC,GA1NZ,MAAMC,GAAQ,CAAEC,KAAM,IAETC,GAAQ,CACnBC,UAAW,CAAExF,MAAO,CAAC,EAAG,EAAG,EAAG,GAAId,MAAO,EAAGC,QAAS,GACrDsG,UAAW,CAAEzF,MAAO,MAAQ0F,UAAW,CAAEC,MAAM,IAepCC,GAAU,EAAG7K,OAAQ8K,EAAIjH,QAASrJ,EAAGsJ,QAAS/C,M,IACzDtG,EAAA,OAAW,QAAXA,EAAAmC,EAAKpC,EAAGsQ,UAAG,IAAXrQ,OAAA,EAAAA,EAAcsG,EAAE,EA6BV,SAASgK,GAAY9Q,GAC3B,MAAMgL,MAAEA,EAAOE,IAAK5E,GAASsK,GAAQ5Q,IAC/B8J,MAAEA,EAAOF,QAASrJ,EAACyH,KAAEA,GAAShI,GAC5BoG,KAAOM,QAAStF,GAAMuK,MAAQjC,YAAaxI,IAAQ4I,EAG3D,KAAK1I,GAAMF,GAAK8J,GAAS1E,KAAS/F,GAAY,IAANA,EAAc,OAAOa,EAE7D,MAAQuI,MAAOoH,EAAIhJ,OAAQF,EAAGY,IAAOT,EAE/BU,EAAInI,EAAGwQ,EAAItI,GACTgI,UAAWO,EAAIN,UAAWO,GAAOV,GAOzC,OAJA1O,GAAK,CAACkJ,EAAGrJ,KACHsP,EAAGhG,MAAQD,IAAM7J,EAAE8P,GAAIE,KAAI,IAAM9P,EAAG+P,SAASF,EAAI3K,EAAK5E,GAAGmG,EAAGa,MAChEsC,GAEK5J,C,KAsFgCgQ,GAAlC,SAASC,GAAQC,EAAKtR,EAAOoB,GAAe,QAAVgQ,GAAApR,EAAMI,YAAI,IAAVgR,MAAc,KACrD,MAAMG,OAAEA,EAAMC,MAAEA,EAAKC,QAAEA,EAAUH,GAAQA,GACjCzL,MAAME,OAAEA,GAAQ+D,MAAEA,EAAOkE,IAAK3N,EAAIgD,EAAMjD,KAAEA,EAAOgB,GAAOpB,EAChE,IAAI0R,UAAEA,EAAY9N,KAAmBxD,E,IAIzBuR,EAFZ,MAAMC,YACFA,EAAWC,KAAEA,EAAO7O,EAAO8O,MAAEA,EAAKC,KAAEA,EAAIC,MAAEA,EAAK5C,SAAEA,EAAQpG,MACzDA,GAAuB,QAAf2I,EAAAD,EAAU1I,aAAK,IAAf2I,IAAmBD,EAAU9O,OAAOyN,GAAMC,OAChDlQ,EASN,GAPAgB,EAAGyQ,KAAOA,EACVzQ,EAAG2Q,KAAOA,EACV3Q,EAAGgO,SAAWD,GAAYnP,EAAOoP,GACjChO,EAAG4H,MAAQA,EACX0I,EAAYtQ,EAAGsQ,UAAYH,EAAOG,GAG/BI,GAASE,EAAO,CAEjB,MAAMnI,QAAEA,GAAY7J,EAEpB8R,IAAU1Q,EAAG0Q,MAAQA,GACrBE,IAAU5Q,EAAG4Q,MAAQA,GAErBnQ,GAAK,CAACyE,EAAMQ,K,QAER9G,EAAM6J,QAAU/C,EAEhBgL,IAAkB,QAARtR,GAAAwP,GAAA8B,GAAM7B,GAAAnJ,UAAE,IAAAtG,IAARwP,GAAMC,IAAOpC,GAAU7N,EAAO,QAAQ6R,IAChDG,IAAkB,QAARvR,GAAAyP,GAAA8B,GAAM7B,GAAArJ,UAAE,IAAArG,IAARyP,GAAMC,IAAOtC,GAAU7N,EAAO,QAAQ+R,GAAI,GAEtDhM,GAGF/F,EAAM6J,QAAUA,C,KAqBoBoI,E,EAuCtC,OAxDA7Q,EAAGkF,KAAOmL,EAAQrQ,EAAGwQ,YAAc,CAEjCC,KAAKxM,EAAG9E,EAAIP,GACV,MAAQ6J,QAAS/C,EAAC1G,KAAEA,GAASG,GACrBsR,KAAMpQ,EAAIoQ,EAAMC,MAAOI,EAAKJ,GAAU1R,E,IAGvCI,EAAP,OAAc,QAAPA,EAAA0R,aAAA,EAAAA,EAAKpL,UAAE,IAAPtG,IAAWqN,GAAUtN,EAAG,aAAakB,C,EAE9CsQ,KAAK1M,EAAG9E,EAAIP,GACV,MAAQ6J,QAAS/C,EAAC1G,KAAEA,GAASG,GACrBwR,KAAM7Q,EAAI6Q,EAAMC,MAAOG,EAAKH,GAAU5R,E,IAGvCI,EAAP,OAAc,QAAPA,EAAA2R,aAAA,EAAAA,EAAKrL,UAAE,IAAPtG,IAAWqN,GAAUtN,EAAG,aAAaW,C,EAE9CkR,WAAY,CACV,CAAC/R,EAAE,YAAa,CAACgF,EAAG9E,EAAIP,IAA0B,QAAhBiS,EAAA1R,EAAEH,KAAKsR,iBAAS,IAAhBO,IAAoBP,G,SAExDtC,E,MAAUpG,EACVkB,MAAO,CAAEmI,QAAQ,GAEjB3I,YAAa,CAACrE,EAAG9E,EAAIP,K,IAAUQ,EAAA,OAAU,QAAVA,EAAAoQ,GAAQrQ,UAAE,IAAVC,OAAA,EAAAA,EAAYkJ,WAAW,KACnDkI,IAIL9H,IAAsB,QAAZwI,GAAAlC,GAAAtG,GAAMyI,cAAM,IAAAD,IAAZlC,GAAMmC,OAAWzB,KAG3B1P,EAAGoR,IAAM,CAACjS,EAAIP,KACZ,MAAM2J,MAAEA,EAAKvJ,KAAEA,EAAI0J,MAAEA,GAAUvJ,EACzBqJ,EAAUrJ,EAAEqJ,QAAUrJ,EAAEqJ,QAAQ,GAAK,EACrC6I,EAAc3I,aAAA,EAAAA,EAAOyI,QACrBjM,KAAEA,EAAIoM,OAAEA,EAAMC,OAAEA,GAAWvS,E,IACfI,EAAlB,MAAMoS,EAA6C,QAAjCpS,EAAAmS,aAAA,EAAAA,EAASpS,EAAGoC,EAAKiH,EAASD,WAAO,IAAjCnJ,IAAqCD,GACjDiQ,UAAEA,GAAcD,GAiBtB,OAfA1O,GAAK,CAACiF,EAAGpF,K,IAMqBlB,EAHRC,EAFlBmS,EAAU/I,QAAUnI,EAEpB,MAAMmR,EAAkC,QAAtBpS,EAAAiS,aAAA,EAAAA,EAASE,EAAW9L,UAAE,IAAtBrG,IAA0BmS,GAG1CpC,EAAU9G,YAAgC,QAAlBlJ,EAAAoQ,GAAQiC,UAAU,IAAlBrS,OAAA,EAAAA,EAAoBkJ,cAC5C8H,EAAMhB,GAERlK,EAAKuM,GAELJ,WAAcI,EAAU,GAE1BD,EAAU/M,KAAKE,QAEVxF,CAAC,EAGHa,C,KC3MS0R,GAKIC,G,IAKtBC,GAnBO,SAAe1B,EAAKtR,EAAQ,GAAIoB,EAAKpB,G,IAKrBQ,EAJYyS,EAAjC,MAAMC,eAAEA,EAAcxF,KAAEA,GAAmB,QAAVuF,EAAA3B,EAAI6B,cAAM,IAAVF,IAAc3B,GACzCzL,KAAEA,EAAO,IAAO7F,GAChBkH,WAAEA,GAAerB,E,QAavB,OAXAzE,EAAGsM,KAAO0F,WAAiC,QAAtB5S,EAAAkN,EAAK2F,MAAK,mBAAY,IAAtB7S,OAAA,EAAAA,EAAyB,GAAI,IAGlDqF,EAAKqB,WAAaA,UAAcgM,EAChCjM,EAAUpB,EAAa,QAAPyN,GAAAR,GAAA1R,GAAGyE,YAAI,IAAAyN,IAAPR,GAAGjN,KAAS,IAC5BA,EAAKqB,WAAaA,EAGlBuC,GAAS6H,EAAKtR,EAAOoB,GACrBiQ,GAAQC,EAAKtR,EAAc,QAAPM,GAAAyS,GAAA3R,GAAGhB,YAAI,IAAAE,IAAPyS,GAAG3S,KAAS,IAEzBgB,C,MCnCTmS,GAH0B,CAACC,EAAS,EAAGC,EAAO,EAAGC,EAAU,IACzDrR,KAAKjD,IAAI,EAAGoU,EAAQC,EAAM,GAAGA,EAAKC,ECJpCC,KAAKC,MAAQZ,GACbW,KAAKE,UAAYhG,GACjB8F,KAAKG,UAAY7M,EACjB0M,KAAKI,YAAc5E,GACnBwE,KAAKK,eAAiBjL,GACtB4K,KAAKM,WAAaV,GAElB,MAAMW,GAASC,SAASC,cAAc,UAGhCC,GAAS,IAAMC,YAAW,IAAMJ,GAAOK,gBAAe,IAAO,GAInE,SAASC,GAAYC,GACnBN,SAASC,cAAc,UAAUM,UAAUD,EAAK,SAAW,OAAO,QAClEP,GAAOQ,UAAUD,EAAK,MAAQ,UAAU,QACxCJ,I,CALFA,KAUA,MAAMM,GAAW,CAACC,EAASC,SAASD,SAAW,IAAIE,gBAAgBF,GAEnE,SAASG,GAASrB,EAASsB,EAAQL,MAIjC,OAHA9S,GAAK,EAAEoT,EAAGxT,EAAI,QAAkB,OAAPA,EAAcuT,EAAME,OAAOD,GAAKD,EAAMzO,IAAI0O,EAAGxT,IACpEiS,GAEKsB,C,CAGT,IAAIG,GAAQR,KACZ,MAAMS,GAAmC,SAAvBD,GAAME,IAAI,SAItBC,GAAS,CACbC,UAAW,MAAApS,OAAA,EZvCX,CAAC,yBAA0B,+BYwC3BqS,MAAO,MAAAtS,OAAA,EZ5CP,CAAC,oBAAqB,4BY6CtBuS,MAAO,MAAArS,OAAA,EZtC+B,CAAC,sBYuCvC8G,MAAOkL,IAAa,kBAGhBM,GAAarT,KAAKjD,IAAIuW,iBAAkB,MAAQ,IAEhDC,GAAOjC,KAAKkC,KAAO5S,EAAA6S,EAAA,CAAQ,C,OAC/B5B,G,WAAQwB,GACRK,WAAYT,GAAOU,SAAWV,GAAOC,UAErCU,mBAAoBX,GAAOY,SAAYd,GACnC,IAAIE,GAAOE,SAAUF,GAAOG,MAAOH,GAAOpL,OAC1C,IAAIoL,GAAOE,SAAUF,GAAOG,OAEhCU,OAAQ3B,KAGVvP,QAAQmR,MAAM,cAEdnR,QAAQoR,IAAI,WACTf,GAAOU,UACNzU,GAAO,CAAC+U,EAAG7B,IAAM6B,GAAGA,GAAK,MAAM7B,EAAE,KAAKmB,GAAKW,aAAa9B,IACtDa,GAAOU,SAAU,KAEvB/Q,QAAQoR,IAAI,WACTf,GAAOY,UACN3U,GAAO,CAAC+U,EAAG7B,IAAM6B,GAAGA,GAAK,MAAM7B,EAAE,KAAKmB,GAAKW,aAAa9B,IACtDa,GAAOY,SAAU,KAEvBjR,QAAQuR,WAOR,MAAMC,IAAY,IAAKC,KAEpBnQ,IAAI,WAAY,GAEhBA,IAAI,SAAU,GAEdA,IAAI,OAAQ,GAEToQ,GAAS,GACTC,GAAc,GAEpBH,GAAU7U,SAAQ,CAACH,EAAGwT,IAAM2B,GAAY3B,GAAK0B,GAAO/P,KAAKnF,GAAG,IAC5DwD,QAAQoR,IAAIM,GAAQ,YAGpB,MAAME,gBAAEC,GAAeC,eAAEC,GAAcC,cAAEC,GAAaC,cAAEC,IACtDxB,GAAKzC,OAGDkE,GAAWlC,GAAME,IAAI,SAUrBiC,IAASD,IAA0B,UAAbA,GAStBE,GAAS,CAAEpO,MAAO,CAAC,EAAG9G,KAAKmV,KAAKR,MAEhCS,GAAYxU,EAAAhE,EAAA,CAAM,KAAMsY,GAAOpO,OAG/BuO,GAAQzU,EAAAhE,EAAA,CAAOmU,WAAW+B,GAAME,IAAI,SAAU,KAAOoC,MACtDF,GAAOpO,OAGZoO,GAAO5N,MAAQ,CACb,EACC2N,GAEGjV,KAAKF,MAAM6U,GAAgB,GAAGU,IAE9BrV,KAAKF,OAAO2U,GArBJ,GAqB2BvV,GAAO,CAAChB,EAAGkB,IAAMlB,EAAEkB,GAAGkV,IAAQ,IAGvE1R,QAAQoR,IAAI,SAAUkB,GAAQ3B,GAAKzC,QAMnC,MAAMwE,GAAQtV,KAAKF,MAAMc,EAAAhE,EAAA,CAAMmU,WAAW+B,GAAME,IAAI,SAAU,KAAO,KAChEkC,GAAO5N,QAGNiO,GAAYD,GAlCJ,EAoCRE,GAAYD,GAAY,EAMxBE,GAAOzV,KAAKF,MAAMiR,WAAW+B,GAAME,IAAI,QAAS,KAAO,GAGvD0C,GAAO3E,WAAW+B,GAAME,IAAI,QAAS,KAAO,KAAKK,GAMjDsC,GAAc7C,GAAM8C,IAAI,YAGxBC,GAAYF,GAAe5E,WAAW+B,GAAME,IAAI,YAAa,KAAO,KACtE,IAAI,GAERpQ,QAAQoR,IAAIxB,SAASD,OAAO,SAAW,IAAIO,GAAMzB,WAAW3Q,OAAS,KACnE,SAAU4U,GAAO,SAAUD,GAAO,QAASI,GAAM,QAASC,GAC1D,SAAU3C,GAAW,YAAa8C,GAAU,SAAUZ,IAIxDnD,SAASC,cAAc,WAAW+D,KAAO,IACvCpD,GAAS,CAAC,CAAC,QAAS,GAAU,CAAC,QAAS,GAAI,CAAC,QAAS,CAAC,oBAEzDZ,SAASC,cAAc,UAAU+D,KAAO,IACtCpD,GAAS,CAAC,CAAC,QAAS,GAAU,CAAC,QAAS,GAAI,CAAC,QAAS,CAAC,mBAEzDZ,SAASC,cAAc,SAAS+D,KAAO,IACrCpD,GAAS,CAAC,CAAC,QAAS,IAAU,CAAC,QAAS,GAAI,CAAC,QAAS,CAAC,kBAEzDZ,SAASC,cAAc,UAAU+D,KAAO,IACtCpD,GAAS,CAAC,CAAC,QAAS,KAAM,CAAC,QAAS,GAAI,CAAC,QAAS,CAAC,mBAErDZ,SAASC,cAAc,WAAW+D,KAChC,IAAIpD,GAAS,CAAC,CAAC,OAAS+C,IAAUA,GAAK,GAAG,GAAK,KAAQ,cAEzD3D,SAASC,cAAc,aAAa+D,KAClC,IAAIpD,GAAS,CAAC,CAAC,WAAaiD,GAAe,KAAO,gBAEpD7D,SAASC,cAAc,UAAU+D,KAC/B,IAAIpD,GAAS,CAAC,CAAC,UACVsC,KAAkC,UAAdA,IAA+B,iBAS1D,MAAMe,GAAU,GAGhBA,GAAQxB,GAAYyB,UAAY,CAE9B,CAAC1V,EAAK,EAAGiV,IAAYhB,GAAYyB,UAEjCzB,GAAYyB,SAEZzB,GAAY0B,OAEZ1B,GAAY2B,MAIdH,GAAQxB,GAAY0B,QAAU,CAE5B1B,GAAY0B,OAEZ1B,GAAY2B,KAEZ3B,GAAYyB,UAIdD,GAAQxB,GAAY2B,MAAQ,CAE1B,CAAC5V,GAAK,EAAIiV,IAAYhB,GAAY2B,MAElC3B,GAAY2B,MAGdtT,QAAQoR,IAAI+B,GAAS,aAGrB,MAAMI,GAAQxF,GAAM4C,GAAM,CAExB/P,KAAM,C,OAEJ8Q,G,QAEAyB,I,MAGFT,G,MAxIY,E,MA6IZD,G,MAEAJ,GAGAvN,KAAOuL,GAAQE,MAAMiD,MAAM7C,GAAKW,cAAgB,QAAU,aAE1DzJ,OAAQ,CAEN4L,WAAW,GAGb1K,IAAK,GAEL5N,KAAM,CAGJ2R,KAAM9O,ECnSK,4qXDqSX+O,MAAO,GAEP5C,SAAU,CACR7P,GAAI,CAAC8F,GAAKsH,OAASgM,MAAOjY,EAAGkY,KAAMC,MAAUnY,EAAEnB,GAAGsZ,EAClDC,IAAK,CAACzT,GAAKsH,OAASgM,MAAOjY,EAAGkY,KAAMC,MAAUnY,EAAEqY,IAAI,GAAGF,EACvDG,IAAK,CAAC3T,GAAKsH,OAASgM,MAAOjY,EAAGkY,KAAMC,MAAUnY,EAAEqY,IAAI,GAAGF,EACvD3Y,KAAM,CAACmF,GAAKsH,OAASgM,MAAOjY,EAAGkY,KAAMC,MAAUnY,EAAER,KAAK2Y,EAEtDI,KAAM,CAAC5T,GAAKsH,OAASgM,MAAOjY,EAAGuY,KAAM1W,MACnCF,KAAK6W,IAAIxY,EAAER,KAAKqC,EAAEF,KAAK8W,IAAI5W,EAE7B6W,SAAUxD,GAAKyD,KAAK,kBACpBC,UAAW1D,GAAKyD,KAAK,mBACrBE,QAAS3D,GAAKyD,KAAK,iBACnBG,QAAS5D,GAAKyD,KAAK,iBACnBI,OAAQ7D,GAAKyD,KAAK,gBAClBK,KAAM9D,GAAKyD,KAAK,cAChBM,EAAG/D,GAAKyD,KAAK,WACblQ,MAAOyM,GAAKyD,KAAK,eAGjBO,MAAO,CAACvU,GAAKsH,OAASiN,MAAOC,EAAIP,UAAWQ,MAAUD,GAAIC,KAK9DnN,MAAO,CAELgM,MAAO5Y,EAAMmY,GAET,CAAE9X,KAAM8X,GAAUa,IAAKzW,EAAM,EAAG,IAEhC,CAAElC,KAAM,IAAKN,IAAK,IAAiB,IAAX8V,GAAK9V,MAAWiZ,IAAKzW,EAAM,EAAG,KAG1DsW,KAAM,EAENK,KAAM,IAENG,SAAU,CAAC,IAAK,IAAK,GAErBE,WAAYzB,GAEZ0B,QAAS,KAETC,QAAS,IAETO,QAAQ,EAERN,OAAQ,CAAC,EAAG,EAAG,IAEfC,KAAM,CAEJ,EAAG,EAAG,GAEN,oBAGFC,EAAG,CAED,GAAG,QAAU,EAEb,GAGFxQ,MAAO,CAAC,GAAG,GAKXyQ,MAAO,CAAC,CAAC,EAAG,KAAM,CAAC,EAAG,SAM1B3U,QAAQoR,IAAI1C,KAAK3T,MAAQwY,IAEzBvT,QAAQmR,MAAM,iEACdnR,QAAQoR,IAAImC,GAAM3S,KAAKT,OAAQ,mCAC/BH,QAAQoR,IAAImC,GAAM3S,KAAKf,OAAQ,+BAC/BG,QAAQoR,OAAOmC,GAAM3S,KAAKG,SAAU,iCACpCf,QAAQoR,IAAImC,GAAM3S,KAAKI,eAAgB,yCACvChB,QAAQuR,WAQR,MAAMwD,KAAe1C,GAEf2C,GAAYtC,GAAMqC,GAClBE,GAAW5C,IAAU2C,GAAY,EAEvChV,QAAQoR,IAAI,YAAa4D,GAAW,WAAYC,IAOhD,MAAMC,GAAa3Y,GAAI,CAAC6D,EAAGnE,IAAMqS,GAAW0G,GAAW/Y,EAAGsX,GAAMxQ,KAAKgB,QACnE1G,EAAM,EAAE4X,IAAW,GAEfE,GAAY,EAAG3K,mBAAoB5H,EAAG6H,oBAAqBjH,KAC/DpG,KAAKlD,IAAI0I,EAAGY,GAGR4R,GAAY,IACb7B,GACHzK,MAAOiM,GAEPlN,OAAQ,CAAEwN,OAAQ,EAAGvI,KAAM,GAC3BwI,UAAW,CAET9G,KAAMxQ,EAAAhE,EAAA,CAAM6Y,IAAQ,EAAG,EAAG,EAAEoC,IAE5BlR,MAAO,KACPwR,OAAQL,GAERM,UAAW,KACXC,WAAY,C,CAAG,SAAU,S,KAEzB3C,GAKA4C,KAAM,CAAC,CAAC,KAAM,IAAM,CAAC,IAAK,MAI5B9U,KAAMoB,EAAU,IACXuR,GAAM3S,KAET+U,YAAa9D,GAYbhR,QAAS,CAAC,EAAC,EAAM,CAACnD,EAAK,EAAGsX,IAAYrD,GAAYyB,eAKhDwC,GAAc,CAElBhJ,KAAMhE,GAAUwM,IAAWpX,EEjcd,osfFkcb8O,KAAM9O,EGlcO,4wBHocbmP,WAAY,CAAE7K,MAAOwB,GAAe1G,KAAKjD,OAAO+a,MAEhD/K,SAAUD,GAAYkL,GAAW,IAC5BA,GAAUja,KAAKgP,SAClBjG,MAAOyM,GAAKyD,KAAK,eAEjB5F,KAAMmC,GAAKyD,KAAK,kBAChBsB,KAAM,CAACtV,GAAKkV,UAAWO,EAAInO,MAAO7F,KAAQgU,EAAGH,MAAM7T,EAAEwS,WACrDyB,UAAW,CAAChQ,EAAGjE,IAAM7D,EAAAhE,EAAA,CAAM6H,EAAEyT,UAAUS,KAAKZ,GAAUrP,MAAOqM,MAE/D6D,UAAW,CAAClQ,EAAGjE,IAAM7D,EAAAhE,EAAA,CAAM6H,EAAEyT,UAAUS,KAAKZ,GAAUrP,MAAOmM,IAE7DlO,MAAO,CAAC3D,GAAKkV,WAAavR,MAAO+B,EAAGyP,OAAQU,EAAIzH,KAAMvS,MAAU6J,UAAKmQ,EAAGha,GACxEgJ,MAAO,CAAEmI,QAAQ,GACjB8I,MAAO,CAAE9I,QAAQ,EAAM+I,KAAM,CAAEC,IAAK,MAAOC,IAAK,wBAEhDb,UAAW,CAACpV,GAAKkV,WAAaE,UAAW3T,EAAG4T,WAAY7J,EAAI4C,KAAMvS,MAChE4F,UAAK+J,EAAG3P,IAGZ+D,QAAQoR,IAAK1C,KAAK4H,UAAYlB,GAAa1G,KAAK6H,YAAcX,IAG9D,MAAMY,GAAO7F,GAAKiF,IAWlB,MAAMa,GAAY,CAAE1Q,MAAO,CAAC,EAAG,EAAG,EAAG,GAAId,MAAO,GAchD,SAASyR,GAAUlH,GACjBA,EAAEmH,kBACFnH,EAAEoH,gB,CAIJ,IAAIC,GA+DJ,SAASC,KACP7H,GAAOtM,MAAQoU,WAAWtG,GAC1BxB,GAAO1L,OAASyT,YAAYvG,E,CAnF9BE,GAAKsG,OAAM,KACT,KAZF,SAAkBlc,GAChB,MAAM+Y,IAAEA,GAAQ/Y,EAEhB+Y,EAAI,GAAKA,EAAI,GACbA,EAAI,GAAKhZ,EAAMC,GAAOT,E,CASpB4c,CAAS3D,GAAM7L,MAAMgM,OAErBH,GAAMpY,KAAKoS,MACX6H,GAAUzQ,QAAU4O,GAAO5O,QAAQ,EAAGoQ,GACtCpE,GAAKpE,MAAMkK,IACXD,GAAKpB,G,CAEP,MAAM5F,GAAKD,GAAYC,E,KAYzBP,GAAOkI,iBAAiB,eAAgB3H,IAEtC+D,GAAM7L,MAAMyM,SAAS,GAAK,EAC1B0C,IAAO,EACPH,GAAUlH,EAAE,IAIdP,GAAOkI,iBAAkB,gBAAkBzI,KAAO,YAC3C,eAAiBA,KAAO,WAAa,WACzCc,IAEC,MAAM4H,EAAU7D,GAAM7L,MAAMyM,SAAS,GAC/BkD,EAAOR,GAQb,GALAtD,GAAM7L,MAAMyM,SAAS,GAAK,EAC1B0C,IAAO,EAIJQ,IAASD,GAAyB,IAAb5H,EAAE8H,OAAiB,OAI3C,MAAQ5P,MAAO7F,EAAGyT,UAAW9T,GAAM4T,GAC7B5Y,EAAIoW,KAAc/Q,EAAEwS,UAAY,EAAExS,EAAEwS,WACpCpY,EAAI4W,KAASrR,EAAEgN,KAAO,GAAGyG,KAAarC,GAAapW,EAAIgF,EAAEgN,KAAK,KAEpExO,QAAQoR,IAAI,YAAa5U,EAAG,OAAQP,EAElC,QAAS2Z,GAAY7R,MAAM,EAAGqR,IAC9B,YAAaQ,GAAYJ,UAAU,EAAGJ,IAAW,IAIvDnG,GAAOkI,iBAAkB,kBAAoBzI,KAAO,cAC7C,gBAAkBA,KAAO,YAAc,aAC3Cc,IACC,MAAQ+H,QAAS1U,EAAG2U,QAAS/T,EAACqB,KAAEA,EAAI2S,YAAEA,EAAWC,UAAEA,GAAY,GAASlI,GAClEmI,KAAEA,EAAIC,IAAEA,EAAKjV,MAAOC,EAAGW,OAAQC,GAAMyL,GAAO4I,yBAC1CrD,OAAQ/X,EAAGgY,KAAMpD,EAACyD,OAAEA,GAAWvB,GAAM7L,MACvCoQ,EAAmB,cAAVhT,GAA2C,UAAhB2S,EAEpCtb,EAAMub,EAAc5C,EAAUzD,EAAI5U,EAAMqY,EAAUrY,EAAI4U,EACtDtO,EAAO3F,KAAKlD,IAAI0I,EAAGY,GAEzBrH,EAAG,IAAQ0G,EAAY,IAARD,EAAEG,GAAW4U,GAAM5U,EAAM,EAAG,EAC3C5G,EAAG,MAAUsH,EAAY,IAARD,EAAET,GAAW6U,GAAK7U,EAAM,EAAG,GAE5C+U,IAAUjB,IAAO,EAAI,IAIzB5H,GAAOkI,iBAAiB,YAAa3H,IACnC+D,GAAM7L,MAAMoN,QAAUvB,GAAM7L,MAAMoN,OAClC4B,GAAUlH,EAAE,IASd2H,iBAAiB,SAAUL,IAC3BA,I","sources":["node_modules/clamp/index.js","node_modules/@epok.tech/fn-time/dist/es/index.js","node_modules/@epok.tech/fn-lists/reduce.js","node_modules/@epok.tech/fn-lists/map.js","node_modules/@epok.tech/fn-lists/each.js","node_modules/@epok.tech/fn-lists/range.js","node_modules/@epok.tech/fn-lists/wrap-index.js","node_modules/@epok.tech/fn-lists/wrap.js","node_modules/@epok.tech/gl-screen-triangle/dist/esm/index.js","src/const.js","src/index.vert.glsl","src/maps.js","src/size.js","src/state.js","node_modules/@epok.tech/is-type/type.js","src/macros.js","node_modules/@thi.ng/vectors/setc.js","src/inputs.js","src/step.js","src/index.js","src/index-forms/index.js","demo/particles-regl/index.js","demo/particles-regl/step.frag.glsl","demo/particles-regl/draw.vert.glsl","demo/particles-regl/draw.frag.glsl"],"sourcesContent":["module.exports = clamp\n\nfunction clamp(value, min, max) {\n  return min < max\n    ? (value < min ? min : value > max ? max : value)\n    : (value < max ? max : value > min ? min : value)\n}\n","/**\n * Simple time-stepping - frame, real-time, constant-step - via any API.\n */\n\nexport const steps = {\n    diff: '-', dt: '-', '⏳': '-',\n    pause: 0, '⏸': 0,\n    add: '+', '⏭': '+'\n};\n\nexport const stepDef = steps.diff;\nexport const startDef = 0;\nexport const nowDef = { [steps.diff]: Date.now, [steps.add]: 1e3/60 };\n\n/**\n * Sets up properties needed to track time, starts/steps time in various ways:\n * - Time-difference or time-advance stepping.\n * - Step forwards or backwards in time or pause it.\n * - Current time can be a number or function; or the object's fixed time-step.\n * - Override property, pass the result to new objects.\n *\n * @example\n *     // Initial call sets up properties.\n *     const diff0 = timer({ step: '-' }, 200);\n *     // => { step: '-', time: 200, dt: 200 };\n *     const add0 = timer({ step: 200 });\n *     // => { step: 200, time: 200, dt: 200 };\n *\n *     // Subsequent calls advance time and track difference.\n *\n *     // No time difference here.\n *     timer(diff0, 200); // => { step: '-', time: 200, dt: 0 };\n *     timer(add0, 0); // => { step: 200, time: 200, dt: 0 };\n *\n *     // Time-difference here with a change or step, into a new result target.\n *     const diff1 = timer(diff0, 300, {});\n *     // => { step: '-', time: 300, dt: 100 };\n *     const add1 = timer(add0, null, {});\n *     // => { step: 200, time: 400, dt: 200 };\n *\n *     diff1.time-diff0.time === diff1.dt; // => true;\n *     add1.time-add0.time === add1.dt; // => true;\n *\n * @param {object} state The state being tracked.\n * @param {number} [state.time=startDef] The initial time.\n * @param {string|number} [state.step=stepDef] How time advances:\n *     - Difference since last `time`: `'diff'`/`'dt'`/`'-'`/`'⏳'`.\n *     - Pause: `'pause'`/`'⏸'`, or number zero (`0`).\n *     - Add `time` step: `'add'`/`'+'`/`'⏭'`, or non-zero number (step size).\n * @param {number|function} [now] The time now (clock/frame/step/etc), or a\n *     function giving it; if not given, uses `state.step` if numeric or\n *     `nowDef[state.step]` otherwise.\n * @param {object|false} [out=state] The state to set up; modifies `state` if\n *     not given.\n *\n * @returns {object|number} The given `out` set up with its initial `time`; or\n *     if `out` is falsey, returns the relevant calculated unknown value:\n *     - The difference since last `time` for `diff` step.\n *     - The updated `time` for `add` or `pause` step.\n */\nexport function timer(state, now, out = state) {\n    // Get the initial time and step-step.\n    const { time: t0 = startDef, step = stepDef, now: n } = state;\n    // Get the step mode - from a key into `steps` or a numerical value.\n    const s = (steps[step] ?? step);\n    const diff = (s === steps.diff);\n    const t = (now ?? n ?? nowDef[s] ?? s);\n\n    // Step by `s`:\n    // - `0` or falsey to `pause`\n    // - `steps.diff` for difference since last `time`\n    // - `steps.add` or a number to add a `time` step\n    const t1 = ((!s)? t0 : ((diff)? 0 : t0)+((isNaN(t))? t() : t));\n    const dt = t1-t0;\n\n    // If only returning a value, return the relevant calculated unknown.\n    if(!out) { return ((diff)? dt : t1); }\n\n    out.time = t1;\n    out.dt = dt;\n    out.step = step;\n\n    return out;\n}\n\nexport default timer;\n","const r = Array.prototype.reduce;\n\n/**\n * Reduce an array-like list.\n * Similar to native, but with iteratee-first arguments.\n * Supports the native single-argument behaviour.\n *\n * @see Array.prototype.reduce\n *\n * @param {function} f Iteratee function, called as `Array`'s `reduce` does.\n * @param {array|*} a List to reduce over, array or array-like.\n * @param {*} [to] The initial accumulator, if any; handled like `Array`'s\n *     `reduce` does, given or not.\n *\n * @returns {*} The result of running the reducer iteratee function over all\n *     elements of the list.\n */\nexport const reduce = (f, a, to) =>\n    // Needs separate `call` because native detects even `undefined` parameter.\n    ((to === undefined)? r.call(a, f) : r.call(a, f, to));\n\nexport default reduce;\n","import { reduce } from './reduce';\n\n/**\n * Map an array-like list.\n * Similar to native, but with iteratee-first arguments; and allows the object\n * into which properties will be mapped to be defined (a new array, by default),\n * avoiding always creating new arrays.\n *\n * @see Array.prototype.map\n * @see [reduce]{@link ./reduce.js}\n *\n * @param {function} f The iteratee function, given standard `Array.map`\n *     arguments, and any given `to`.\n * @param {array|*} a The list to map over, array or array-like.\n * @param {false|*} [to=[]] The initial accumulator, if given; `a` if falsey; or\n *     a new array if not given.\n *\n * @returns {*} The result of mapping `to` through the iteratee function over\n *     the `a` list.\n */\nexport const map = (f, a, to = []) => reduce((to, v, i) => {\n        to[i] = f(v, i, a, to);\n\n        return to;\n    },\n    a, (to || a));\n\nexport default map;\n","const e = Array.prototype.forEach;\n\n/**\n * Iterates a function over every element of a list, returning the list.\n *\n * @see Array.prototype.forEach\n *\n * @param {function} f The iteratee function.\n * @param {array|*} a List to iterate over, array or array-like.\n *\n * @returns {array|*} The given list.\n */\nexport const each = (f, a) => {\n    e.call(a, f);\n\n    return a;\n}\n\nexport default each;\n","const { fill } = Array.prototype;\nconst { isFinite } = Number;\nconst { floor } = Math;\n\n/**\n * Fills list with the given items filled via `Array`'s `fill`.\n *\n * @see Array.constructor\n * @see Array.prototype.fill\n * @see Number.isFinite\n *\n * @param {number|array|*} [l=0] How many items to create, or existing list.\n * @param {*} [value] A value to fill the array with; for `Array`'s `fill`.\n * @param {number} [start] Start index, inclusive; for `Array`'s `fill`.\n * @param {number} [end] End index, exclusive; for `Array`'s `fill`.\n *\n * @returns {array|*} List with items filled as given.\n */\nexport const range = (l = 0, value, start, end) =>\n    fill.call(((isFinite(l))? Array(floor(l)) : l), value, start, end);\n\nexport default range;\n","/**\n * Wraps an index over a given length, so that indexes greater than the length\n * loop back past `0`, and indexes less than `0` loop backward from the length.\n * Similar to the indexing behaviour of `Array`'s `slice`.\n * Indexing is the equivalent of a true _modulo_ operator, where JavaScript's\n * `%` operator is actually a _remainder_ operator.\n *\n * @see Array.prototpye.slice\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder\n *\n * @param {number} i Index to wrap.\n * @param {number} l Length to wrap the index over.\n *\n * @returns {number} The index wrapped over the length.\n */\nexport const wrapIndex = (i, l) => ((i%l)+l)%l;\n\nexport default wrapIndex;\n","import wrapIndex from './wrap-index';\n\n/**\n * Gives an index wrapped over a given length, or the entry at the wrapped\n * index in a given list; wrapped backwards, forwards, never exceeding bounds.\n *\n * @see [wrapIndex]{@link ./wrap-index.js}\n *\n * @param {number} i The index to wrap.\n * @param {number|array|*} l List to index, array or array-like; or numeric\n *     length for a numeric `wrapIndex` result instead.\n * @param {number} [end=l.length] Length to wrap the index over; allows wrapping\n *     over a sub-range of a list; if not given, tries the list's length.\n *\n * @returns {number|*} The index wrapped over the given length by `wrapIndex`;\n *     or the list entry at the wrapped index, if given a list.\n */\nexport const wrap = (i, l, end = l.length) =>\n    ((end || (end === 0))? l[wrapIndex(i, end)] : wrapIndex(i, l));\n\nexport default wrap;\n","/**\n * The 3 vertices of a 2D triangle covering the viewport in NDC coordinates ([-1, 1]).\n *\n * @export\n * @type {array.<array.<number>>}\n */\nexport const vertices = [[-1, -1], [-1, 4], [4, -1]];\n\nexport const count = vertices.length;\nexport const dim = 2;\n\n/**\n * The flat array of the above triangle, to be bound as a WebGL attribute buffer for\n * rendering the triangle in the vertex shader.\n * These positions will result in clipped NDC coordinates ([-1, 1]) over the\n * viewport's width and height.\n *\n * @export\n * @type {array.<number>}\n */\nexport const positions = vertices.flat();\n\nexport default positions;\n","/**\n * Default properties for `gpgpu` and `GL` capabilities and resources.\n *\n * @module\n * @category JS\n */\n\nimport { positions } from '@epok.tech/gl-screen-triangle';\nimport vertGLSL from './index.vert.glsl';\n\n/** Default vertex shader `GLSL` code. */\nexport const vertDef = vertGLSL;\n\n// The required and optional `GL` extensions for a `gpgpu` state.\n\n/** Default required extensions; none. */\nexport const extensions = () => [];\n\n/** Default required extensions to draw to `float` buffers. */\nexport const extensionsFloat = () =>\n  ['oes_texture_float', 'webgl_color_buffer_float'];\n\n/** Default required extensions to draw to `half float` buffers. */\nexport const extensionsHalfFloat = () =>\n  ['oes_texture_half_float', 'ext_color_buffer_half_float'];\n\n/** Default optional extensions; update more data in one render pass. */\nexport const optionalExtensions = () => ['webgl_draw_buffers'];\n\n/** Prefix namespace to avoid naming clashes; recommended. */\nexport const preDef = 'gpgpu_';\n\n/**\n * Default minimum allowable channels for `framebuffer` attachments.\n * This avoids `RGB32F` `framebuffer` attachments, which errors on Firefox.\n *\n * @see [Firefox `RGB32F` bug](https://bugzilla.mozilla.org/show_bug.cgi?id=1448632)\n */\nexport const channelsMinDef = 4;\n\n/**\n * Default minimum allowable channels for `framebuffer` attachments.\n * This avoids `RGB32F` `framebuffer` attachments, which errors on Firefox.\n *\n * @see [Firefox `RGB32F` bug](https://bugzilla.mozilla.org/show_bug.cgi?id=1448632)\n */\nexport const channelsMaxDef = 4;\n\n/** Default maximum `texture`s bound per pass. */\nexport const buffersMaxDef = 1;\n\n/**\n * Default how many steps are bound as outputs, unavailable as input; for\n * platforms forbidding read/write of same buffer.\n */\nexport const boundDef = 1;\n\n/**\n * Default length of the data `texture`s sides to allocate; gives a square\n * power-of-two `texture` raising 2 to this power.\n */\nexport const scaleDef = 9;\n\n/**\n * Default width of the data `texture`s sides to allocate; gives a square\n * power-of-two `texture` raising 2 to the default scale.\n */\nexport const widthDef = 2**scaleDef;\n\n/**\n * Default height of the data `texture`s sides to allocate; gives a square\n * power-of-two `texture` raising 2 to the default scale.\n */\nexport const heightDef = 2**scaleDef;\n\n/** Default number steps of state to track. */\nexport const stepsDef = 2;\n\n/** Default values to track. */\nexport const valuesDef = () => [channelsMaxDef];\n/** Default vertex positions `attribute`; 3 points of a large flat triangle. */\nexport const positionsDef = () => [...positions];\n\n// `GL` resource format defaults.\n\n/** Default `texture` data type. */\nexport const typeDef = 'float';\n/** Default `texture` minification filter. */\nexport const minDef = 'nearest';\n/** Default `texture` magnification filter. */\nexport const magDef = 'nearest';\n/** Default `texture` wrap mode, avoid `WebGL1` needing power-of-2 `texture`. */\nexport const wrapDef = 'clamp';\n/** Default `framebuffer` depth attachment. */\nexport const depthDef = false;\n/** Default `framebuffer` stencil attachment. */\nexport const stencilDef = false;\n/** Whether states merge into one `texture`; one merged `texture` by default. */\nexport const mergeDef = true;\n\n/** Simple shared cache for temporary or reusable objects. */\nexport const cacheDef = {};\n","/**\n * Default `gpgpu` vertex shader.\n *\n * @see [@epok.tech/gl-screen-triangle/uv-texture.vert.glsl](https://github.com/keeffEoghan/gl-screen-triangle/tree/master/uv-texture.vert.glsl)\n */\n\nprecision highp float;\n\nattribute vec2 position;\n\nvarying vec2 uv;\n\nvoid main() {\n  // Texture coordinates, range `[0, 1]`, y-axis points upwards.\n  uv = (position*0.5)+0.5;\n  gl_Position = vec4(position, 0, 1);\n}\n","/**\n * The `gpgpu` mappings for step/draw shaders input/output.\n *\n * These maps show shaders how to make use of a system's supported features, how\n * to pack/unpack their data from `framebuffer`s/`texture`s, perform minimal\n * needed samples to retrieve any past values they must derive from, etc.\n *\n * Shaders may declare values they output, values they derive from, groupings of\n * in/dependent values - without handling how these concerns map to the\n * particular system resources they're using.\n *\n * System limits/features/extensions are accounted for, to produce the most\n * efficient mappings available with the least I/O when it comes to drawing\n * (draw passes, texture samples, etc).\n *\n * @module\n * @category JS\n *\n * @todo Allow passes within/across textures; separate data and texture shapes.\n */\n\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport each from '@epok.tech/fn-lists/each';\n\nimport { valuesDef, channelsMaxDef, buffersMaxDef } from './const';\n\nconst { isInteger } = Number;\n\n/** Cache for optimisation. */\nexport const cache = { packed: [] };\n\n/**\n * Determines whether a given value is valid and can be stored within the\n * channels available.\n *\n * @param {number} value A value to validate.\n * @param {number} [channelsMax] The maximum channels available to store values.\n *\n * @returns {boolean} Whether the given `value` is valid.\n */\nexport const validValue = (value, channelsMax = channelsMaxDef) =>\n  ((1 <= value) || (value <= channelsMax) ||\n    !!console.error(`\\`gl-gpgpu\\`: the given value (${value}) exceeds the `+\n      `range of channels available, \\`[1, ${channelsMax}]\\` inclusive.`,\n      value, channelsMax));\n\n/**\n * Minimise resource usage, order `values` to pack into blocks of `channelsMax`;\n * interpreted as indexes into the given `values`.\n *\n * @see {@link mapGroups}\n *\n * @example ```\n *   packValues([1, 2, 3], 4, []); // =>\n *   [2, 0, 1];\n *\n *   packValues([3, 2, 1], 4, []); // =>\n *   [0, 2, 1];\n *\n *   packValues([4, 3, 2], 4, []); // =>\n *   [0, 1, 2];\n *\n *   packValues([1, 1, 4, 2], 4, []); // =>\n *   [2, 3, 0, 1];\n * ```\n *\n * @param {array.<number>} values Each entry is how many interdependent channels\n *   are grouped into one texture in one pass, separate entries may be across\n *   one or more textures/passes. See `mapGroups`.\n * @param {number} [channelsMax=channelsMaxDef] The maximum number of channels\n *   per texture. See `mapGroups`.\n * @param {array} [to=[]] An array to store the result; a new array by default.\n *\n * @returns {array.<number>} `to` The indexes of the given `values`, reordered\n *   to pack into the fewest buckets of `channelsMax` size or less; stored in\n *   the given `to` array.\n */\nexport function packValues(values, channelsMax = channelsMaxDef, to = []) {\n  map((_, i) => i, values, to).length = values.length;\n\n  /** Counts the number of empty channels in the current group. */\n  let channels = channelsMax;\n  /** How many values have already been packed. */\n  let packed = 0;\n  /** Tracks the value that best fits the free channels (fills it tightest). */\n  let fitIndex = 0;\n  let fitSize = Infinity;\n\n  for(let i = 0; packed < values.length;) {\n    const v = packed+i;\n    const value = values[to[v]];\n\n    if(!validValue(value, channelsMax)) { return to; }\n\n    // Check how value fits the channels - valid is >= 0, perfect is 0.\n    const fit = channels-value;\n\n    if((fit >= 0) && (fit < fitSize)) {\n      fitSize = fit;\n      fitIndex = v;\n    }\n\n    // Not a perfect fit and can keep searching for better fits - continue.\n    if((fitSize !== 0) && (v < values.length-1)) { ++i; }\n    else {\n      // Got a perfect fit or the search ended - swap in best fit value.\n      const pack = to[fitIndex];\n\n      to[fitIndex] = to[packed];\n      to[packed] = pack;\n\n      // Reduce the free channels by the best value, reset if needed.\n      ((channels -= values[pack]) > 0) || (channels = channelsMax);\n      // Start the search again over the remaining unpacked entries.\n      fitIndex = ++packed;\n      fitSize = Infinity;\n      i = 0;\n    }\n  }\n\n  return to;\n}\n\n/**\n * Groups the `values` of `gpgpu` data across draw passes and data textures.\n *\n * @see {@link packValues}\n *\n * @example ```\n *   const x = 2;\n *   const y = 4;\n *   const z = 1;\n *   const maps = { values: [x, y, z], channelsMax: 4 };\n *\n *   // No optimisations - values not packed, single texture output per pass.\n *   mapGroups({ ...maps, buffersMax: 1, packed: false }); // =>\n *   {\n *     ...maps, packed: false,\n *     textures: [[0], [1], [2]], // length === 3\n *     passes: [[0], [1], [2]], // length === 3\n *     valueToTexture: [0, 1, 2], valueToPass: [0, 1, 2],\n *     textureToPass: [0, 1, 2]\n *   };\n *\n *   // Automatically packed values - values across fewer textures/passes.\n *   mapGroups({ ...maps, buffersMax: 1 }); // =>\n *   {\n *     ...maps, packed: [1, 0, 2],\n *     textures: [[1], [0, 2]], // length === 2\n *     passes: [[0], [1]], // length === 2\n *     valueToTexture: [1, 0, 1], valueToPass: [1, 0, 1],\n *     textureToPass: [0, 1]\n *   };\n *\n *   // Can bind more texture outputs per pass - values across fewer passes.\n *   mapGroups({ ...maps, buffersMax: 4 }); // =>\n *   {\n *     ...maps, packed: [1, 0, 2],\n *     textures: [[1], [0, 2]], // length === 2\n *     passes: [[0, 1]], // length === 1\n *     valueToTexture: [1, 0, 1], valueToPass: [0, 0, 0],\n *     textureToPass: [0, 0]\n *   };\n *\n *   // Custom packed values - fuller control.\n *   mapGroups({ ...maps, buffersMax: 4, packed: [0, 2, 1] }); // =>\n *   {\n *     ...maps, packed: [0, 2, 1],\n *     textures: [[0, 2], [1]], // length === 2\n *     passes: [[0, 1]], // length === 1\n *     valueToTexture: [0, 1, 0], valueToPass: [0, 0, 0],\n *     textureToPass: [0, 0]\n *   };\n *\n *   // Merge dependent values - fuller control, but no map for merged values.\n *   mapGroups({ ...maps, values: [x+z, y], buffersMax: 4 }); // =>\n *   {\n *     ...maps, packed: [1, 0],\n *     textures: [[1], [0]], // length === 2\n *     passes: [[0, 1]], // length === 1\n *     valueToTexture: [1, 0], valueToPass: [0, 0],\n *     textureToPass: [0, 0]\n *   };\n * ```\n *\n * @param {object} [maps=\\{\\}] Initial maps settings; new `object` if not given.\n *\n * @param {array.<number>} [maps.values=valuesDef()] An `array` where each\n *   `number` denotes how many value channels are grouped into one data-texture\n *   in one draw pass (where any value map logic isn't handled here); each\n *   separate number may be computed across one or more data-textures/passes.\n *\n *   Each value denotes the number of dependent channels to compute together;\n *   separate values denote channels that are independent, and may be drawn in\n *   the same or separate passes, depending on settings/support.\n *\n *   The order may affect the number of textures/passes needed; can maintain\n *   order as-is, or use a more efficient `packed` order. See `packValues`.\n *\n * @param {number} [maps.channelsMax=channelsMaxDef] Maximum channels per\n *   texture.\n * @param {number} [maps.buffersMax=buffersMaxDef] Maximum textures bound per\n *   pass.\n * @param {array.<number>} [maps.packed] An `array` of indexes into `values`\n *   packed into an order that best fits into blocks of `channelsMax` to\n *   minimise resources; or `false`y to use `values` in their given order; uses\n *   `packValues` if not given.\n * @param {object} [to=maps] An `object` to contain the results; modifies `maps`\n *   if not given.\n *\n * @returns {object} `to` The given `to` `object`; how `values` are grouped\n *   per-texture per-pass per-step, meta information, and given parameters.\n * @returns {array.<array.<number>>} `to.passes` Textures grouped into passes,\n *   as `arrays` corresponding to `framebuffer`s in separate draw passes; whose\n *   values are indexes into `to.textures`.\n * @returns {array.<array.<number>>} `to.textures` Values grouped into\n *   textures, as `array`s corresponding to `framebuffer` attachments, into\n *   which `values` are drawn; whose values are indexes into `to.values`.\n * @returns {array.<number>} `to.values` The `values`, as given.\n * @returns {number} `to.buffersMax` The max textures per pass, as given.\n * @returns {number} `to.channelsMax` The max channels per-texture, as given.\n * @returns {array.<number>} `to.valueToTexture` Inverse map from each index of\n *   `to.values` to the index of the data-texture containing it.\n * @returns {array.<number>} `to.valueToPass` Inverse map from each index of\n *   `to.values` to the index of the pass containing it.\n * @returns {array.<number>} `to.textureToPass` Inverse map from each index of\n *   `to.textures` to the index of the pass containing it.\n */\nexport function mapGroups(maps = {}, to = maps) {\n  if(!maps) { return to; }\n\n  const {\n      values = valuesDef(),\n      channelsMax = channelsMaxDef, buffersMax = buffersMaxDef,\n      // Pack `values` into blocks of `channelsMax` to minimise resources.\n      packed = packValues(values, channelsMax, cache.packed)\n    } = maps;\n\n  to.values = values;\n  to.buffersMax = buffersMax;\n  to.channelsMax = channelsMax;\n  to.packed = packed;\n\n  const passes = to.passes = [[]];\n  const textures = to.textures = [[]];\n  const valueToTexture = to.valueToTexture = [];\n  const valueToPass = to.valueToPass = [];\n  const textureToPass = to.textureToPass = [];\n  // Counts the number of channels written in a single draw pass.\n  let channels = 0;\n  // Get the value, via `packed` if valid, or directly as given in `values`.\n  const getValue = ((packed)? ((_, i) => values[i]) : ((v) => v));\n  const getIndex = ((packed)? ((i) => packed[i]) : ((i) => i));\n\n  return reduce((to, v, i) => {\n      const index = getIndex(i);\n      const value = getValue(v, index);\n\n      if(!validValue(value, channelsMax)) { return to; }\n\n      let p = passes.length-1;\n      let pass = passes[p];\n      let t = textures.length-1;\n      let texture = textures[t];\n\n      if((channels += value) > channelsMax) {\n        channels = value;\n        t = textures.push(texture = [])-1;\n        (pass.length >= buffersMax) && (p = passes.push(pass = [])-1);\n        pass.push(t);\n        textureToPass.push(p);\n      }\n      else if(pass.length === 0) {\n        pass.push(t);\n        textureToPass.push(p);\n      }\n\n      texture.push(index);\n      valueToTexture[index] = t;\n      valueToPass[index] = p;\n\n      return to;\n    },\n    values, to);\n}\n\n/**\n * Maps the minimal set of texture reads to derive the next state of values from\n * a past state of values they depend upon.\n *\n * @see {@link mapGroups}\n *\n * @example ```\n *   const maps = mapGroups({\n *     // See `mapGroups` examples for resulting maps.\n *     values: [2, 4, 1], channelsMax: 4, buffersMax: 1, packed: false,\n *     // Derived step/value indexes, per-value; sample entries include:\n *     derives: [\n *       // Single...\n *       2,\n *       // Empty...\n *       ,\n *       // Multiple...\n *       [\n *         // Defined step...\n *         [1, 0],\n *         // All values at any given level/step...\n *         true\n *       ]\n *     ]\n *   });\n *\n *   mapSamples(maps); // =>\n *   {\n *     ...maps,\n *     // Minimum texture samples for values; nested per-pass, per-value.\n *     // Deepest arrays are step/texture index pairs into `maps.textures`.\n *     samples: [\n *       [[0, 2]],\n *       null,\n *       [[1, 0], [0, 0], [0, 1], [0, 2]]\n *     ],\n *     // Value indexes into `to.samples`; nested per-pass, per-value.\n *     // Map from a value index to data it needs in the minimal samples.\n *     reads: [\n *       [[0]],\n *       null,\n *       [null, null, [0, 1, 2, 3]]\n *     ]\n *   };\n * ```\n *\n * @param {object} maps How values are grouped per-`texture` per-pass per-step.\n *   See `mapGroups`.\n * @param {true|array} [maps.derives] How any new values derive from past\n *   values. If not given `false`y, this returns with no changes.\n * @param {true|number|array} [maps.derives.[]] L1\n * @param {true|number|array} [maps.derives.[].[]] L2\n * @param {true|number} [maps.derives.[].[].[]] L3\n *\n * @param {true|array.<true,number,array.<true,number,array.<true,number>>>} [maps.derives]\n *   How values derive from past values.\n *\n *   If given as a sparse array, each entry relates the corresponding value to\n *   any past value steps/indexes it derives from - a value not derived from\n *   past values may have an empty/null entry; a value derives from past\n *   values where its entry has:\n *   - Numbers; deriving from the most recent state at the given value index.\n *   - Lists of numbers; deriving from the given past state index (1st number\n *     denotes how many steps ago), at the given value index (2nd number).\n *\n *   The nested hierarchy thus has any `pass,[values,[value,[step, value]]]`.\n *   If any level is given as `true`, maps to sample all values, at the given\n *   step (or most recent step, if none given).\n *\n *   If no `derives` given, no samples are mapped, `to` is returned unchanged.\n *\n * @param {array.<array.<number>>} maps.passes Textures grouped into passes. See\n *   `mapGroups`.\n * @param {array.<array.<number>>} maps.textures Values grouped into textures. See\n *   `mapGroups`.\n * @param {array.<number>} maps.valueToTexture Inverse map from each value index\n *   to the data texture index containing it.\n * @param {object} [to=maps] The object to store the result in; `maps` if not\n *   given.\n *\n * @returns {object} `to` The given `to` object, with resulting maps added for\n *   any given `maps.derives`.\n * @returns {array.<array.<array.<number>>>} `[to.samples]` Map of the minimum\n *   set of indexes into `maps.textures` that need to be sampled per-pass,\n *   to get all `derives` needed for each value of `maps.values` of each\n *   pass of `maps.passes`.\n * @returns {array.<array.<array.<number>>>} `[to.reads]` Sparse map from\n *   each value of `derives` to its step and texture indexes in `to.samples`.\n * @returns {true|array.<true,number,array.<true,number,array.<true,number>>>}\n *   `[to.derives]` How new values derive from past values, as given.\n */\nexport function mapSamples(maps, to = maps) {\n  const derives = maps?.derives;\n\n  if(!derives) { return to; }\n\n  const { passes, textures, valueToTexture } = maps;\n  const reads = to.reads = [];\n  const cache = {};\n\n  to.derives = derives;\n\n  const all = (step = 0) =>\n    cache[step] ??= map((t, v) => [step, v], valueToTexture);\n\n  const getAddSample = (pass, value) => function add(set, derive, d) {\n    let step = 0;\n    let texture;\n\n    if(derive === true) { return reduce(add, all(step), set); }\n    else if(isInteger(derive)) { texture = valueToTexture[derive]; }\n    else if(derive[1] === true) { return reduce(add, all(derive[0]), set); }\n    else {\n      step = derive[0];\n      texture = valueToTexture[derive[1]];\n    }\n\n    if(!(isInteger(step) && isInteger(texture))) {\n      return console.error('`mapSamples`: invalid map for sample',\n        derives, maps, pass, value, derive, d, step, texture);\n    }\n\n    // Create the set if not already created.\n    const to = (set || []);\n    // Check for any existing matching step/texture read in the set.\n    const i = to.findIndex(([s, t]) => (s === step) && (t === texture));\n\n    // Add the read for this value in this pass; creating any needed maps.\n    ((reads[pass] ??= [])[value] ??= [])\n      // A new read as needed, or any existing matching read.\n      .push((i < 0)? to.push([step, texture])-1 : i);\n\n    return to;\n  };\n\n  const getAddSamples = (pass) => (set, value) => {\n    const valueDerives = ((derives === true)? derives : derives[value]);\n\n    return ((!valueDerives && (valueDerives !== 0))? set\n      : (((valueDerives === true) || isInteger(valueDerives))?\n        getAddSample(pass, value)(set, valueDerives)\n      : reduce(getAddSample(pass, value), valueDerives, set)));\n  }\n\n  to.samples = map((pass, p) => reduce((set, texture) =>\n        reduce(getAddSamples(p), textures[texture], set),\n      pass, null),\n    passes, []);\n\n  return to;\n}\n\n/**\n * Full maps, creates mappings for grouping given values and for minimal samples\n * and reads (if new values derive from past ones).\n *\n * @see {@link mapGroups}\n * @see {@link mapSamples}\n *\n * @param {object} [maps] Input value maps and settings.\n * @param {object} [to=maps] An `object` to contain the results; modifies `maps`\n *   if not given.\n *\n * @returns {object} `to` The given `to` object; how `values` are grouped\n *   per-`texture` per-pass per-step, meta information, and given parameters;\n *   and minimal samples and reads for any given `maps.derives`.\n */\nexport const mapValues = (maps, to = maps) =>\n  mapSamples(maps, mapGroups(maps, to));\n\nexport default mapValues;\n","/**\n * @module\n * @category JS\n */\n\nimport map from '@epok.tech/fn-lists/map';\nimport range from '@epok.tech/fn-lists/range';\n\nconst { isFinite, isInteger } = Number;\n\n/**\n * Returns the given width, for various properties in order of precedence.\n *\n * @see {@link state.getState}\n *\n * @param {object} value Size (width) `number`, or an `object` containing it.\n * @param {number} [value.width] Width; supersedes further aliases.\n * @param {number} [value.w] Alias of `width`; supersedes further aliases.\n * @param {number} [value.x] Alias of `width`; supersedes further aliases.\n * @param {object} [value.shape] Shape (width) `number`, or an `object`\n *   containing it; supersedes further aliases.\n * @param {object} [value.size] Size (width) `number`, or an `object`\n *   containing it; supersedes further aliases.\n * @param {number} [value.side] Width and height; supersedes further aliases.\n * @param {number} [value.ʼ0ʼ] Alias of `width`; supersedes `value` itself.\n *\n * @returns {number} The width as given in one of the expected properties, or\n *   any given `value` number, or `null`ish if no width could be resolved.\n */\nexport function getWidth(value) {\n  const { width, w, x, shape, size, side, 0: v0 } = value;\n\n  return width ?? w ?? x ??\n    (shape && getWidth(shape)) ?? (size && getWidth(size)) ??\n    side ?? v0 ?? ((isFinite(value))? value : null);\n}\n\n/**\n * Returns the given height, for various properties in order of precedence.\n *\n * @see {@link state.getState}\n *\n * @param {object} value Size (height) `number`, or an `object` containing it.\n * @param {number} [value.height] Height; supersedes further aliases.\n * @param {number} [value.h] Alias of `height`; supersedes further aliases.\n * @param {number} [value.y] Alias of `height`; supersedes further aliases.\n * @param {object} [value.shape] Shape (height) `number`, or an `object`\n *   containing it; supersedes further aliases.\n * @param {object} [value.size] Size (height) `number`, or an `object`\n *   containing it; supersedes further aliases.\n * @param {number} [value.side] Width and height; supersedes further aliases.\n * @param {number} [value.ʼ1ʼ] Alias of `height`; supersedes `value` itself.\n *\n * @returns {number} The height as given in one of the expected properties, or\n *   any given `value` number, or `null`ish if no height could be resolved.\n */\nexport function getHeight(value) {\n  const { height, h, y, shape, size, side, 1: v1 } = value;\n\n  return height ?? h ?? y ??\n    (shape && getHeight(shape)) ?? (size && getHeight(size)) ??\n    side ?? v1 ?? ((isFinite(value))? value : null);\n}\n\n/**\n * Gives the number of indexes to draw a full state, for various parameters.\n * Effectively equivalent to `gl_VertexID` in `WebGL2`.\n *\n * @see {@link getWidth}\n * @see {@link getHeight}\n * @see {@link state.getState}\n *\n * @param {object} [size=1] Size `number` of data resources, or an `object`\n *   containing it; width if `height` is given as a second parameter.\n *   See `getWidth` and `getHeight`.\n * @param {number} [size.count] The `number` of entries of data resources.\n * @param {object} [height=1] Height `number` of data resources, or an `object`\n *   containing it.\n *\n * @returns {number} The number of indexes needed to draw a full state; each\n *   entry of a data-texture (its area, equivalent to `state.size.count`).\n */\nexport const countDrawIndexes = (size = 1, height = 1) =>\n  size?.count ?? (getWidth(size) ?? 1)*(getHeight(height) ?? 1);\n\n/**\n * Gives the array of indexes needed to draw a full state.\n *\n * @param {object} size The `number` of entries in each data-texture; or an\n *   `object` of size/type of data resources.\n *\n * @returns {array.<number>} An array of indexes for drawing all data-texture\n *   entries, numbered `0` to `size-1`.\n */\nexport const getDrawIndexes = (size) => map((_, i) => i,\n  range(isInteger(size)? size : countDrawIndexes(size)), 0);\n\n/**\n * 2 raised to the given numeric power, or `null` if not given.\n *\n * @param {number} [scale] The power to raise 2 to.\n *\n * @returns 2 raised to the given numeric power, or `null` if not given.\n */\nexport const getScaled = (scale) => ((isFinite(scale))? 2**scale : null);\n","/**\n * The `gpgpu` state and `GL` resources.\n *\n * Handles `framebuffer`s, `texture`s; and meta info.\n *\n * @module\n * @category JS\n *\n * @todo Allow passes into or across textures; separate data and texture shapes.\n * @todo In-place updates of complex resources and meta info.\n */\n\nimport range from '@epok.tech/fn-lists/range';\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\n\nimport { getWidth, getHeight, getScaled } from './size';\n\nimport {\n    widthDef, heightDef, scaleDef, stepsDef, valuesDef, channelsMinDef, typeDef,\n    minDef, magDef, wrapDef, depthDef, stencilDef, mergeDef\n  } from './const';\n\nconst { isInteger } = Number;\n\n/**\n * Set up the `gpgpu` resources and meta info for a state of a number data.\n *\n * @example ```\n *   const api = {\n *     framebuffer: ({ depth, stencil, width, height, color }) => null,\n *     texture: ({ type, min, mag, wrap, width, height, channels }) => null\n *   };\n *\n *   // Example with `webgl_draw_buffers` extension support, for 4 buffers.\n *   let maps = mapGroups({ values: [1, 2, 3], buffersMax: 4, packed: 0 });\n *   let state = { steps: 2, side: 10, maps };\n *\n *   const s0 = getState(api, state, {}); // =>\n *   {\n *     ...state, passNow: undefined, stepNow: undefined,\n *     size: {\n *       steps: 2, passes: 2, textures: 4,\n *       width: 10, height: 10, shape: [10, 10], count: 100\n *     },\n *     steps: [[s0.passes[0][0].framebuffer], [s0.passes[1][0].framebuffer]],\n *     // This setup results in fewer passes, as more buffers can be bound.\n *     passes: [\n *       [\n *         {\n *           framebuffer: api.framebuffer(s0.passes[0][0]),\n *           color: [s0.textures[0][0].texture, s0.textures[0][1].texture],\n *           map: [0, 1], // maps.passes[0]\n *           entry: 0, index: 0, step: 0,\n *           depth: false, stencil: false, width: 10, height: 10\n *         }\n *       ],\n *       [\n *         {\n *           framebuffer: api.framebuffer(s0.passes[1][0]),\n *           color: [s0.textures[1][0].texture, s0.textures[1][1].texture],\n *           map: [0, 1], // maps.passes[0]\n *           entry: 1, index: 0, step: 1,\n *           depth: false, stencil: false, width: 10, height: 10\n *         }\n *       ]\n *     ],\n *     textures: [\n *       [\n *         {\n *           texture: api.texture(s0.textures[0][0]),\n *           map: [0, 1], // maps.textures[0]\n *           entry: 0, index: 0, step: 0, pass: 0,\n *           type: 'float', width: 10, height: 10, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         },\n *         {\n *           texture: api.texture(s0.textures[0][1]),\n *           map: [2], // maps.textures[1]\n *           entry: 1, index: 1, step: 0, pass: 0,\n *           type: 'float', width: 10, height: 10, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         }\n *       ],\n *       [\n *         {\n *           texture: api.texture(s0.textures[1][0]),\n *           map: [0, 1], // maps.textures[0]\n *           entry: 2, index: 0, step: 1, pass: 0,\n *           type: 'float', width: 10, height: 10, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         },\n *         {\n *           texture: api.texture(s0.textures[1][1]),\n *           map: [2], // maps.textures[1]\n *           entry: 3, index: 1, step: 1, pass: 0,\n *           type: 'float', width: 10, height: 10, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         }\n *       ]\n *     ]\n *   };\n *\n *   // Example with no `webgl_draw_buffers` extension support, only 1 buffer.\n *   maps = mapGroups({ values: [1, 2, 3], buffersMax: 1, packed: 0 });\n *   state = { type: 'uint8', steps: 2, scale: 5, maps, stepNow: 1 };\n *\n *   const s1 = getState(api, state, {}); // =>\n *   {\n *     ...state, passNow: undefined, stepNow: 1,\n *     size: {\n *       steps: 2, passes: 4, textures: 4,\n *       width: 32, height: 32, shape: [32, 32], count: 1024\n *     },\n *     steps: [\n *       [s1.passes[0][0].framebuffer, s1.passes[0][1].framebuffer],\n *       [s1.passes[1][0].framebuffer, s1.passes[1][1].framebuffer]\n *     ],\n *     // This setup results in more passes, as fewer buffers can be bound.\n *     passes: [\n *       [\n *         {\n *           framebuffer: api.framebuffer(s1.passes[0][0]),\n *           color: [s1.textures[0][0].texture],\n *           map: [0], // maps.passes[0]\n *           entry: 0, index: 0, step: 0,\n *           depth: false, stencil: false, width: 32, height: 32\n *         },\n *         {\n *           framebuffer: api.framebuffer(s1.passes[0][1]),\n *           color: [s1.textures[0][1].texture],\n *           map: [1], // maps.passes[1]\n *           entry: 1, index: 1, step: 0,\n *           depth: false, stencil: false, width: 32, height: 32\n *         }\n *       ],\n *       [\n *         {\n *           framebuffer: api.framebuffer(s1.passes[1][0]),\n *           color: [s1.textures[1][0].texture],\n *           map: [0], // maps.passes[0]\n *           entry: 2, index: 0, step: 1,\n *           depth: false, stencil: false, width: 32, height: 32\n *         },\n *         {\n *           framebuffer: api.framebuffer(s1.passes[1][1]),\n *           color: [s1.textures[1][1].texture],\n *           map: [1], // maps.passes[1]\n *           entry: 3, index: 1, step: 1,\n *           depth: false, stencil: false, width: 32, height: 32\n *         }\n *       ]\n *     ],\n *     textures: [\n *       [\n *         {\n *           texture: api.texture(s1.textures[0][0]),\n *           map: [0, 1], // maps.textures[0]\n *           entry: 0, index: 0, step: 0, pass: 0,\n *           type: 'uint8', width: 32, height: 32, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         },\n *         {\n *           texture: api.texture(s1.textures[0][1]),\n *           map: [2], // maps.textures[1]\n *           entry: 1, index: 1, step: 0, pass: 1,\n *           type: 'uint8', width: 32, height: 32, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         }\n *       ],\n *       [\n *         {\n *           texture: api.texture(s1.textures[1][0]),\n *           map: [0, 1], // maps.textures[0]\n *           entry: 2, index: 0, step: 1, pass: 0,\n *           type: 'uint8', width: 32, height: 32, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         },\n *         {\n *           texture: api.texture(s1.textures[1][1]),\n *           map: [2], // maps.textures[1]\n *           entry: 3, index: 1, step: 1, pass: 1,\n *           type: 'uint8', width: 32, height: 32, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         }\n *       ]\n *     ]\n *   };\n * ```\n *\n * @todo Example using `merge`.\n *\n * @see {@link texture}\n * @see {@link framebuffer}\n * @see {@link maps.mapGroups}\n * @see {@link maps.mapSamples}\n * @see {@link step.getStep}\n * @see {@link macros.macroSamples}\n * @see {@link macros.macroTaps}\n * @see {@link macros.macroPass}\n * @see {@link size.getWidth}\n * @see {@link size.getHeight}\n * @see {@link size.getScaled}\n *\n * @see [`sampler array index must be a literal expression`](https://stackoverflow.com/a/60110986/716898)\n * @see [`sampler2DArray`](https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_2d_array.html)\n * @see [`sampler3D`](https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_3d.html)\n *\n * @param {object} api The API for `GL` resources.\n * @param {texture} [api.texture] Function creating `GL` `texture`s.\n * @param {framebuffer} [api.framebuffer] Function creating `GL` `framebuffer`s.\n * @param {object} [state=\\{\\}] The state parameters.\n *\n * @param {number} [state.width=widthDef] Data width, aliases follow in order\n *   of precedence. See `getWidth`.\n * @param {number} [state.w] Alias of `state.width`. See `getWidth`.\n * @param {number} [state.x] Alias of `state.width`. See `getWidth`.\n * @param {number} [state.ʼ0ʼ] Alias of `state.width`. See `getWidth`.\n *\n * @param {number} [state.height=heightDef] Data height, aliases follow in order\n *   of precedence. See `getHeight`.\n * @param {number} [state.h] Alias of `state.height`. See `getHeight`.\n * @param {number} [state.y] Alias of `state.height`. See `getHeight`.\n * @param {number} [state.ʼ1ʼ] Alias of `state.height`. See `getHeight`.\n * @param {number} [state.shape] Data size. See `getWidth` and `getHeight`.\n * @param {number} [state.size] Data size. See `getWidth` and `getHeight`.\n * @param {number} [state.side] Data size of width/height.\n *   See `getWidth` and `getHeight`.\n * @param {number} [state.scale=scaleDef] Data size of width/height as a square\n *   power-of-two size, 2 raised to this power. See `getScaled`.\n *\n * @param {number|array} [state.steps=stepsDef] How many steps of state to\n *   track, or the list of states if already set up.\n * @param {object} [state.maps] How `state.maps.values` are grouped\n *   per-`texture` per-pass per-step. See `mapGroups`.\n * @param {array.<number>} [state.maps.values=valuesDef()] How values of each\n *   data item may be grouped into `texture`s across passes; set up here if not\n *   given. See `mapGroups`.\n * @param {number} [state.maps.channelsMin=channelsMinDef] The minimum allowed\n *   channels for `framebuffer` attachments; allocates unused channels as needed\n *   to reach this limit.\n * @param {number} [state.maps.textures] How values are grouped into `texture`s.\n *   See `mapGroups`.\n *\n * @param {number} [state.stepNow] The currently active state step, if any.\n * @param {number} [state.passNow] The currently active draw pass, if any.\n * @param {string} [state.type=typeDef] Any `texture` data type value.\n * @param {string} [state.min=minDef] Any `texture` minification filter value.\n * @param {string} [state.mag=magDef] Any `texture` magnification filter value.\n * @param {string} [state.wrap=wrapDef] Any `texture` wrap mode value.\n * @param {object} [state.depth=depthDef] Any `framebuffer` depth attachment, or\n *   a flag for whether it should be created.\n * @param {object} [state.stencil=stencilDef] Any `framebuffer` stencil\n *   attachment, or a flag for whether it should be created.\n *\n * @param {object} [state.merge=mergeDef] Whether to merge states into\n *   one `texture`; `true`y handles merging here, with any given properties used\n *   as-is (the merged `texture` already set up); `false`y uses un-merged\n *   `array`s of `texture`s.\n *\n *   Merging allows shaders to access past steps by non-constant lookups; e.g:\n *   attributes cause `\"sampler array index must be a literal expression\"` on\n *   `GLSL3` spec and some platforms (e.g: `D3D`); but takes more work to copy\n *   the last pass's bound `texture`/s to merge into the past `texture`, so\n *   should be used to variably access past steps or avoid limits of `array`s of\n *   `texture`s.\n *   Only this merged past `texture` and those bound in an active pass are\n *   created, as upon each pass the output will be copied to the past `texture`,\n *   and bound `texture`s reused in the next pass.\n *   If not merging, all state is as output by its pass in its own one of the\n *   `array`s of `texture`s.\n *\n *   The default merged `texture` is laid out as `[texture, step]` on the\n *   `[x, y]` axes, respectively; if other layouts are needed, the merge\n *   `texture` can be given here to be used as-is, and the merging/copying and\n *   lookup logic in their respective hooks. See `getStep` and `macroTaps`.\n *   If a merge `texture` is given, size information is interpreted in a similar\n *   way and precedence as it is from `state`. See `getWidth` and `getHeight`.\n *\n * @param {number} [state.merge.width] Merged data width, aliases follow in\n *   order of precedence. See `state`.\n * @param {number} [state.merge.w] Alias of `state.merge.width`. See `state`.\n * @param {number} [state.merge.x] Alias of `state.merge.width`. See `state`.\n * @param {number} [state.merge.ʼ0ʼ] Alias of `state.merge.width`. See `state`.\n * @param {number} [state.merge.height] Merged data height, aliases follow in\n *   order of precedence. See `state`.\n * @param {number} [state.merge.h] Alias of `state.merge.height`. See `state`.\n * @param {number} [state.merge.y] Alias of `state.merge.height`. See `state`.\n *   See `state`.\n * @param {number} [state.merge.ʼ1ʼ] Alias of `state.merge.height`. See `state`.\n * @param {number} [state.merge.shape] Merged data size. See `state`.\n * @param {number} [state.merge.size] Merged data size. See `state`.\n * @param {number} [state.merge.side] Merged data size of width/height.\n * @param {number} [state.merge.scale] Merged data size of width/height as a\n *   square power-of-two size, 2 raised to this power. See `state`.\n *\n * @param {object} [to=state] The state object to set up. Modifies the given\n *   `state` object by default.\n *\n * @returns {object} `to` The state object, set up with the data resources and\n *   meta information, for use with `getStep` and drawing:\n * @returns {object.<number,array.<number,array.<number>>>} `to.maps` Any given\n *   `state.maps`. See `mapGroups`.\n * @returns {array.<array.<object.<texture,string,number,array.<number>>>>}\n *   `to.textures` The `texture`s per-step, as `array`s of objects of `texture`s\n *   and meta info. See `to.maps.textures`.\n * @returns {array.<array.<object.<framebuffer,number,array.<number>>>>}\n *   `to.passes` Passes per step, as `array`s of objects of `framebuffer`s,\n *   referencing `to.textures`, and meta info. See `to.maps.passes`.\n * @returns {array.<framebuffer<array.<texture>>>} `to.steps`\n *   Hierarchy of steps of state, as an `array` of `framebuffer`s from\n *   `to.passes`, with `array`s of `texture`s from `to.textures`, and meta\n *   information; set up here, or the given `state.steps` if it's an `array`.\n *   State data may be drawn into the `framebuffer`s accordingly.\n *   See `mapGroups` and `getStep`.\n * @returns {object|undefined} `[to.merge]` If merging, a given or new merged\n *   `texture` and copier `framebuffer`, with meta info. See `getStep` and\n *   `macroTaps`.\n * @returns {object.<texture,string,number>|undefined} `[to.merge.all]` Any given\n *   `state.merge.all`, or newly-created merged `texture` and meta info.\n * @returns {object.<framebuffer,string,number>|undefined} `[to.merge.next]` Any\n *   given `state.merge.next`, or newly-created `framebuffer` and meta info; for\n *   copying each pass's data into the `merge`d `texture`.\n * @returns {object} `to.size` Size/type information of the created resources.\n * @returns {string} `to.size.type` Data type of `framebuffer`s and `texture`s.\n * @returns {boolean} `to.size.depth` Whether `framebuffer`s attach depth.\n * @returns {boolean} `to.size.stencil` Whether `framebuffer`s attach stencil.\n * @returns {number} `to.size.channelsMin` Minimum channels in any `texture`.\n * @returns {number} `to.size.steps` Number of `to.steps` in the main flow.\n * @returns {number} `to.size.passes` Number of `to.passes` in `to.steps`.\n * @returns {number} `to.size.framebuffers` Number of `framebuffer`s created.\n * @returns {number} `to.size.textures` Number of `to.textures` in `to.passes`.\n * @returns {number} `to.size.colors` Number of `texture`s created.\n * @returns {number} `to.size.width` Width of `framebuffer`s and `texture`s.\n * @returns {number} `to.size.height` Height of `framebuffer`s and `texture`s.\n * @returns {array.<number>} `to.size.shape` Shape of `framebuffer`s and\n *   `texture`s, as `[to.size.width, to.size.height]`.\n * @returns {number} `to.size.count` Number of entries in each `texture`.\n * @returns {object.<number,string,array.<number>>|undefined} `[to.size.merge]`\n *   Any size/type information about any created or given `merge`d `texture`.\n * @returns {number} `to.stepNow` The currently active state step, as given.\n * @returns {number} `to.passNow` The currently active draw pass, as given.\n */\nexport function getState({ texture, framebuffer }, state = {}, to = state) {\n  const {\n      steps = stepsDef, stepNow, passNow, maps, merge = mergeDef, scale,\n      // Resource format settings.\n      type = typeDef, min = minDef, mag = magDef, wrap = wrapDef,\n      depth = depthDef, stencil = stencilDef\n    } = state;\n\n  const scaled = getScaled(scale);\n  const width = Math.floor(getWidth(state) ?? scaled ?? widthDef);\n  const height = Math.floor(getHeight(state) ?? scaled ?? heightDef);\n\n  to.maps = maps;\n  to.stepNow = stepNow;\n  to.passNow = passNow;\n\n  const {\n      values = valuesDef(), channelsMin = channelsMinDef, textures: texturesMap\n    } = maps;\n\n  maps.channelsMin = channelsMin;\n  maps.values = values;\n\n  /**\n   * All `framebuffer` attachments need the same number of channels; enough to\n   * hold all values a pass holds, or all passes hold if merging and reusing.\n   */\n  const passChannels = (pass, min) =>\n    reduce((min, t) =>\n        Math.max(min, reduce((sum, v) => sum+values[v], texturesMap[t], 0)),\n      pass, min);\n\n  /**\n   * If merging past `texture`s and reusing `texture` attachments in each pass's\n   * `framebuffer`, pre-compute the minimum channels for a reusable pool of\n   * `texture` attachments that can hold any pass's values; since all a\n   * `framebuffer`'s attachments also need the same number of channels, this is\n   * also the same number of channels across all passes.\n   */\n  const mergeChannels = ((!merge)? null\n    : reduce((min, p) => passChannels(p, min), maps.passes, channelsMin));\n\n  /** Size of the created resources. */\n  const size = to.size = {\n    type, depth, stencil, channelsMin: mergeChannels ?? channelsMin,\n    steps: steps.length ?? steps,\n    passes: 0, framebuffers: 0, textures: 0, colors: 0,\n    width, height, shape: [width, height], count: width*height\n  };\n\n  /** The `texture`s created for the `step`/`pass` render flow. */\n  const textures = to.textures = [];\n  /** The passes created for the `step`/`pass` render flow. */\n  const passes = to.passes = [];\n  /** The `texture`s bound to the next pass; reused if merging. */\n  let colorPool;\n\n  /**\n   * Add a `texture` attachment and meta info to `texture`s if applicable; to\n   * return its new `texture` or a reused one to bind to a pass in `passes`.\n   */\n  const addTexture = (channels, w, h, step, pass) => (index, c, _, color) => {\n    /** Properties passed for `texture` creation, then meta info. */\n    const to = { channels, width: w, height: h, type, min, mag, wrap };\n\n    // Resources.\n\n    /**\n     * Add/reuse `texture` color attachments as needed; add minimal `texture`s.\n     * If merging, passes may reuse any pass's existing `texture` attachments;\n     * otherwise, each pass has its own dedicated `texture` attachments.\n     */\n    let entry = c;\n    let t = color?.[entry];\n\n    // Only create new `texture`s if existing ones can't be reused.\n    if(!t) {\n      t = texture?.(to);\n      entry = size.textures++;\n    }\n\n    // Add meta info.\n\n    /** Check if this is bound to a pass. */\n    const s = isInteger(step);\n    const p = isInteger(pass);\n    const i = isInteger(index);\n\n    /** Denotes attached `texture`; if merging, `texture`s are reused. */\n    to.texture = t;\n    /** Denotes attached `texture` entry; if merging, `texture`s are reused. */\n    to.entry = entry;\n\n    s && (to.step = step);\n\n    if(p) {\n      /** Denotes `framebuffer` attachments; may reuse underlying `texture`s. */\n      to.color = size.colors++;\n      to.pass = pass;\n    }\n\n    i && (to.map = texturesMap[to.index = index]);\n\n    // Check whether this `texture` is part of the `step`/`pass` render flow.\n    // If so, add to `textures`, return its `texture` to bind to a pass.\n    // If not, return the entire object.\n    return ((s && p && i)? ((textures[step] ??= [])[index] = to).texture : to);\n  };\n\n  /**\n   * Add a pass to `passes`, with its `texture`s bound; to return its\n   * `framebuffer` to one of `steps`.\n   */\n  const addPass = (step, color) => (pass, index) => {\n    /**\n     * All a `framebuffer`'s attachments need the same number of channels;\n     * ignored if a `color`'s given as it'll be defined there instead.\n     */\n    const channels = color ?? mergeChannels ??\n      ((pass)? passChannels(pass, channelsMin) : channelsMin);\n\n    // Resources.\n\n    /** Properties passed for `framebuffer` creation, then meta info. */\n    const to = {\n      depth, stencil, width, height,\n      /** Map the pass's `texture` color attachments and their meta info. */\n      color: color ??\n        map(addTexture(channels, width, height, step, index), pass,\n          // Reuse any existing color attachments if merging; otherwise make\n          // dedicated color attachments for each pass.\n          ((merge)? (colorPool ??= []) : []))\n    };\n\n    /** The `framebuffer` for this pass. */\n    to.framebuffer = framebuffer?.(to);\n\n    // Add meta info.\n\n    /** Denotes attached `framebuffer` entry. */\n    to.entry = size.framebuffers++;\n\n    if(pass) {\n      to.map = pass;\n      to.pass = size.passes++;\n    }\n\n    const s = isInteger(step);\n    const i = isInteger(index);\n\n    s && (to.step = step);\n    i && (to.index = index);\n\n    // Check whether this pass is part of the `step`/`pass` render flow.\n    // If so, add to `passes`, return its `framebuffer` for its step.\n    return ((pass && s && i)? ((passes[step] ??= [])[index] = to).framebuffer\n        // If not, return the entire object.\n      : to);\n  };\n\n  /**\n   * Set up resources needed to store data per-`texture` per-pass per-step.\n   * Use any given steps/passes or create new ones.\n   */\n  to.steps = map((passes, step) => passes || map(addPass(step), maps.passes),\n    ((isInteger(steps))? range(steps) : steps), 0);\n\n  // Finish here if merge is disabled.\n  if(!merge) { return to; }\n\n  // Set up the `texture` for states to be merged into.\n\n  /** Use any size info given in `merge`, as with `state` above. */\n  const mScaled = getScaled(merge.scale);\n  /** Use any given size info, or merge along `[texture, step]` axes. */\n  const mw = getWidth(merge) ?? mScaled ?? maps.textures.length*width;\n  const mh = getHeight(merge) ?? mScaled ?? size.steps*height;\n\n  to.merge = {\n    /** New merge `texture` and info, or use any given merge `texture`. */\n    all: merge.all ?? addTexture(mergeChannels, mw, mh)(),\n    /** Empty `framebuffer`, to copy data from each `texture` of each pass. */\n    next: merge.next ?? addPass(null, false)()\n  };\n\n  size.merge = { width: mw, height: mh, shape: [mw, mh], count: mw*mh };\n\n  return to;\n}\n\n/**\n * @todo [Fix `@callback`:  nested `@param`, `@return`/`@see`/etc details](https://github.com/TypeStrong/typedoc/issues/1896)\n *\n * @callback texture\n * Function to create a `GL` `texture`; from a `GL` API.\n *\n * **See**\n * - {@link getState}\n *\n * **Returns**\n * - `texture` A `GL` `texture`, or an object serving that purpose.\n *\n * @param {string} type Any `texture` data type value.\n * @param {string} min Any `texture` minification filter value.\n * @param {string} mag Any `texture` magnification filter value.\n * @param {string} wrap Any `texture` wrap mode value.\n * @param {number} width The width of the `texture`.\n * @param {number} height The height of the `texture`.\n * @param {number} channels The number of channels of the `texture`.\n *\n * @returns {object}\n */\n\n/**\n * @todo [Fix `@callback`:  nested `@param`, `@return`/`@see`/etc details](https://github.com/TypeStrong/typedoc/issues/1896)\n *\n * @callback framebuffer\n * Function to create a `GL` `framebuffer`; from a `GL` API.\n *\n * **See**\n * - {@link getState}\n *\n * **Returns**\n * - `framebuffer` A `GL` `framebuffer`, or an object serving that purpose.\n *\n * @param {object} [depth] Any `framebuffer` depth attachment, or a flag for\n *   whether it should be created.\n * @param {object} [stencil] Any `framebuffer` stencil attachment, or a flag for\n *   whether it should be created.\n * @param {number} width The width of the `framebuffer`.\n * @param {number} height The height of the `framebuffer`.\n * @param {array.<texture>} color The `texture` attachments to use.\n *\n * @returns {object}\n */\n\nexport default getState;\n","const [{ length: start}, { length: end }] = '[object {type}]'.split('{type}');\n\n/**\n * Gives the type of a given input.\n *\n * @see https://stackoverflow.com/a/17772086/716898\n *\n * @param {*} x Any input to test.\n *\n * @returns {string} The type of `x`.\n */\nexport const type = (x) => toString.call(x).slice(start, -end);\n\nexport default type;\n","/**\n * The `gpgpu` `GLSL` preprocessor macros for working with the state and maps.\n *\n * Use these with care, as each set of different macros will result in new\n * shaders and compilations - as few unique macros as possible should be created\n * for a given set of inputs, ideally; can use caches here for this efficiency.\n *\n * @module\n * @category JS\n *\n * @todo Ensure the `output_N` in `macroOutput` can work with `WebGL2`; look at\n *   using `layout(location=attach_N) out data_N`, not `gl_FragData[attach_N]`.\n *   - https://stackoverflow.com/questions/51793336/multiple-output-textures-from-the-same-program\n *   - https://stackoverflow.com/questions/46740817/gl-fragdata-must-be-constant-zero\n *   - https://stackoverflow.com/questions/50258822/how-are-layout-qualifiers-better-than-getattriblocation-in-webgl2\n * @todo Redo examples, especially `macroTaps` and `macroPass`.\n */\n\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\nimport { type } from '@epok.tech/is-type/type';\n\nimport { preDef, boundDef, cacheDef } from './const';\n\n/** Escaped carriage-return for easier reading. */\nexport const cr = ' \\\\\\n';\n/** The channels denoted for texture input/output. */\nexport const rgba = 'rgba';\n/** Gives cache keys from simple plain `object` inputs. */\nconst id = JSON.stringify;\n\n/** Keys for each part of the macro handling process available to hooks. */\nexport const hooks = {\n  /** The full set of macros. */\n  macroPass: 'pass',\n  /** Each part of the set of macros. */\n  macroValues: 'values', macroOutput: 'output',\n  macroSamples: 'samples', macroTaps: 'taps'\n};\n\n/**\n * Whether macros should be handled here; or the result of handling them by a\n * given named hook.\n * Allows macros of the given key to be handled by external named hooks, to\n * replace any part of the functionality here.\n *\n * @example ```\n *   // Macros to be handled here, the default.\n *   [hasMacros(), hasMacros({}), hasMacros({ macros: true })]]\n *     .every((m) => m === null);\n *\n *   // Macros to be handled here, with prefix `'pre_'` instead of `'preDef'`.\n *   hasMacros({ pre: 'pre_' }) === null;\n *\n *   // Macros not created.\n *   [hasMacros({ macros: false }), hasMacros({ macros: 0 })]\n *     .every((m) => m === '');\n *\n *   // Macros for 'a' handled by external static hook, not here.\n *   hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'a') === '//A\\n';\n *   // Macros for 'b' handled by external function hook, not here.\n *   hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'b') === '//B\\n';\n *   // Macros specified `on` a 'frag' not created.\n *   hasMacros({ macros: { frag: 0 } }, '', 'frag') === '';\n *   // Macros specified `on` a 'vert' handled here.\n *   hasMacros({ macros: { frag: 0, a_vert: 0 } }, '', 'vert') === null;\n *   // Macros for hook `'a'` specified `on` a 'vert' not created.\n *   hasMacros({ macros: { frag: 0, a_vert: 0 } }, 'a', 'vert') === '';\n * ```\n *\n * @param {object} [props] The properties handling macros.\n * @param {string} [key] The name for which macros should be handled.\n * @param {string} [on=''] Any further macro `hooks` specifier; if given, both\n *   the hook key and this specifier are checked (e.g: `key` and `key_on`).\n *\n * @param {string|function|object|false} [macros=props.macros] Whether and how\n *   `GLSL` preprocessor macros should be handled:\n *   - If it's false-y and non-nullish, no macros are handled here.\n *   - If it's a string, no macros are handled here as it's used instead.\n *   - If it's a function, it's passed the given `props`, `key`, `macros`, and\n *     the returned result is used.\n *   - If it's an object, any value at the given `key` is entered recursively,\n *     with the given `props`, `key`, and `macros[key]`.\n *   - Otherwise, returns `null` to indicate macros should be handled here.\n *\n * @returns {string|null} Either the result of the macros handled elsewhere,\n *   or `null` if macros should be handled here.\n */\nexport function hasMacros(props, key, on = '', macros = props?.macros) {\n  if((macros ?? true) === true) { return null; }\n  else if(!macros) { return ''; }\n\n  const t = type(macros);\n\n  return ((t === 'Function')? macros(props, key, on, macros)\n    : ((t === 'String')? macros\n    : (((macros instanceof Object) && (key in macros))?\n      hasMacros(props, key, on, macros[key])\n    : ((on)? hasMacros(props, ((key)? key+'_' : '')+on, '', macros)\n    : null))));\n}\n\n/**\n * Generates an array-like declaration, as a `GLSL` syntax string compatible\n * with all versions.\n *\n * Workaround for lack of `const` arrays in `GLSL` < 3. Used as the base for the\n * other `GLSL` version list types, ensuring a standard basis while offering\n * further language features where available.\n *\n * @example ```\n *   getGLSLListBase('float', 'list', [0, 1, 2], 'const'); // =>\n *   'const int list_l = 3;'+cr+\n *   'const int list_0 = float(0);'+cr+\n *   'const int list_1 = float(1);'+cr+\n *   'const int list_2 = float(2);';\n * ```\n *\n * @param {string} type The `GLSL` list data-type.\n * @param {string} name The name of the `GLSL` list variable.\n * @param {array.<number,array.<number>>} a The list of `GLSL` values.\n * @param {string} [qualify=''] A `GLSL` qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The `GLSL1` array-like declaration string.\n */\nexport const getGLSLListBase = (type, name, a, qualify = '', init = type) =>\n  `const int ${name}_l = ${a.length};`+\n  reduce((s, v, i) =>\n      s+cr+(qualify && qualify+' ')+type+\n        ` ${name}_${i} = ${init}(${v.join?.(', ') ?? v});`,\n    a, '');\n\n/**\n * Generates an array-like declaration, as a `GLSL1` syntax string.\n *\n * Workaround for lack of `const` arrays in `GLSL` < 3. Adds a lookup macro\n * function; slow here, but standard.\n *\n * @see {@link getGLSLListBase}\n *\n * @example ```\n *   getGLSL1ListLike('float', 'list', [0, 1, 2], 'const'); // =>\n *   'const int list_l = 3;'+cr+\n *   'const int list_0 = float(0);'+cr+\n *   'const int list_1 = float(1);'+cr+\n *   'const int list_2 = float(2);\\n'+\n *   '// Index macro `list_i` (e.g: `list_i(0)`) may be slow, `+\n *     'use name (e.g: `list_0`) if possible.\\n'+\n *   '#define list_i(i) ((i == 2)? list_2 : ((i == 1)? list_1 : list_0))\\n';\n * ```\n *\n * @param {string} type The `GLSL` list data-type.\n * @param {string} name The name of the `GLSL` list variable.\n * @param {array.<number,array.<number>>} a The list of `GLSL` values.\n * @param {string} [qualify=''] A `GLSL` qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The `GLSL1` array-like declaration string.\n */\nexport const getGLSL1ListLike = (type, name, a, qualify = '', init = type) =>\n  getGLSLListBase(type, name, a, qualify, init)+'\\n'+\n  // @todo Would ideally use the concatenation macro, but can't in GLSL 1.\n  // `#define ${name}_i(i) ${name}_##i`;\n  `// Index macro \\`${name}_i\\` (e.g: \\`${name}_i(0)\\`) may be slow, `+\n    `use name (e.g: \\`${name}_0\\`) if possible.\\n`+\n  `#define ${name}_i(i) ${reduce((s, v, i) =>\n      ((i)? `((i == ${i})? ${name}_${i} : ${s})` : `${name}_${i}`),\n    a, '')}\\n`;\n\n/**\n * Generates an array declaration, as a `GLSL1` syntax string.\n *\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @see {@link getGLSLListBase}\n *\n * @example ```\n *   getGLSL1ListArray('vec3', 'list', [[1, 0, 0], [0, 2, 0], [0, 0, 3]]);\n *   // =>\n *   'const int list_l = 3;'+cr+\n *   'vec3 list_0 = vec3(1, 0, 0);'+cr+\n *   'vec3 list_1 = vec3(0, 2, 0);'+cr+\n *   'vec3 list_2 = vec3(0, 0, 3);'+cr+\n *   'vec3 list[list_l];'+cr+\n *   'list[0] = list_0;'+cr+\n *   'list[1] = list_1;'+cr+\n *   'list[2] = list_2;\\n'+\n *   '#define list_i(i) list[i]\\n';\n * ```\n *\n * @param {string} type The `GLSL` list data-type.\n * @param {string} name The name of the `GLSL` list variable.\n * @param {array.<number,array.<number>>} a The list of `GLSL` values.\n * @param {string} [qualify=''] A `GLSL` qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The `GLSL1` array declaration string.\n */\nexport const getGLSL1ListArray = (type, name, a, qualify = '', init = type) =>\n  getGLSLListBase(type, name, a, qualify, init)+cr+\n  (qualify && qualify+' ')+type+` ${name}[${name}_l];`+\n  reduce((s, _, i) => s+cr+name+`[${i}] = ${name}_${i};`, a, '')+'\\n'+\n  `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Generates an array declaration, as a `GLSL3` syntax string.\n *\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @see {@link getGLSLListBase}\n *\n * @example ```\n *   getGLSL3List('int', 'list', [0, 1, 2], 'const'); // =>\n *   'const int list_l = 3;'+cr+\n *   'const int list_0 = int(0);'+cr+\n *   'const int list_1 = int(1);'+cr+\n *   'const int list_2 = int(2);'+cr+\n *   'const int list[list_l] = int[list_l](list_0, list_1, list_2);\\n'+\n *   '#define list_i(i) list[i]\\n';\n * ```\n *\n * @param {string} type The `GLSL` list data-type.\n * @param {string} name The name of the `GLSL` list variable.\n * @param {array.<number,array.<number>>} a The list of `GLSL` values.\n * @param {string} [qualify=''] A `GLSL` qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The `GLSL3` array declaration string.\n */\nexport const getGLSL3List = (type, name, a, qualify = '', init = type) =>\n  getGLSLListBase(type, name, a, qualify, init)+cr+\n  (qualify && qualify+' ')+type+` ${name}[${name}_l] = ${init}[${name}_l](${\n    reduce((s, _, i) => (s && s+', ')+name+'_'+i, a, '')});\\n`+\n  `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Creates a `GLSL` definition of an array, and initialises it with the given\n * values, type, and variable name.\n *\n * The initialisation is valid `GLSL1` or greater syntax; but is written with\n * escaped new-lines so it may be used in a single-line (e.g: for preprocessor\n * macros).\n *\n * For a `qualify` of `const` on any `GLSL` < 3, falls back to using non-array\n * variables with the index appended to `name`, since `const` arrays aren't\n * supported before `GLSL3`.\n *\n * @see {@link getGLSL3List}\n * @see {@link getGLSL1ListLike}\n * @see {@link getGLSL1ListArray}\n *\n * @example ```\n *   getGLSLList('int', 'test', [0, 1]); // =>\n *   'const int test_l = 2;'+cr+\n *   'int test_0 = int(0);'+cr+\n *   'int test_1 = int(1);'+cr+\n *   'int test[test_l];'+cr+\n *   'test[0] = test_0;'+cr+\n *   'test[1] = test_1;\\n'+\n *   '#define test_i(i) test[i]\\n';\n *\n *   getGLSLList('ivec2', 'vecs', [[1, 0], [0, 1]], 'const', 3); // =>\n *   'const int vecs_l = 2;'+cr+\n *   'ivec2 vecs_0 = ivec2(1, 0);'+cr+\n *   'ivec2 vecs_1 = ivec2(0, 1);'+cr+\n *   'const ivec2 vecs[vecs_l] = ivec2[vecs_l](vecs_0, vecs_1);\\n'+\n *   '#define vecs_i(i) vecs[i]\\n';\n *\n *   getGLSLList('int', 'listLike', [0, 1], 'const', 1); // =>\n *   'const int listLike_l = 2;'+cr+\n *   'const int listLike_0 = int(0);'+cr+\n *   'const int listLike_1 = int(1);\\n'+\n *   '// Index macro `listLike_i` (e.g: `listLike_i(0)`) may be slow, `+\n *     'use name (e.g: `listLike_0`) if possible.\\n'+\n *   '#define listLike_i(i) ((i == 1)? listLike_1 : listLike_0)\\n';\n * ```\n *\n * @param {string} type The `GLSL` list data-type.\n * @param {string} name The name of the `GLSL` list variable.\n * @param {array.<number,array.<number>>} a The list of `GLSL` values.\n * @param {string} [qualify=''] A `GLSL` qualifier, if needed (e.g: `const`).\n * @param {number} [glsl=1] The `GLSL` version to target, if specified.\n * @param {string} [init] A data-type initialiser.\n *\n * @returns {string} The `GLSL` (1 or 3) array or array-like declaration string.\n */\nexport const getGLSLList = (type, name, a, qualify = '', glsl = 1, init) =>\n  ((glsl >= 3)? getGLSL3List\n  : ((qualify.trim() === 'const')? getGLSL1ListLike : getGLSL1ListArray))\n    (type, name, a, qualify, init);\n\n/**\n * Defines the values within textures per-step, as `GLSL` preprocessor macros.\n *\n * These macros define mappings from values to their textures and channels.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see {@link hasMacros}\n * @see {@link maps.mapGroups}\n * @see {@link state.getState}\n * @see {@link const.cacheDef}\n *\n * @example ```\n *   const maps = { values: [2, 4, 1], channelsMax: 4 };\n *\n *   // No optimisations - values not packed, single texture output per pass.\n *   const state = {\n *     pre: '', steps: 2, maps: mapGroups({ ...maps, buffersMax: 1, packed: 0 })\n *   };\n *\n *   macroValues(state); // =>\n *   '#define texture_0 0\\n'+\n *   '#define channels_0 rg\\n'+\n *   '\\n'+\n *   '#define texture_1 1\\n'+\n *   '#define channels_1 rgba\\n'+\n *   '\\n'+\n *   '#define texture_2 2\\n'+\n *   '#define channels_2 r\\n'+\n *   '\\n'+\n *   '#define textures 3\\n'+\n *   '#define passes 3\\n'+\n *   '#define stepsPast 1\\n'+\n *   '#define steps 2\\n'+\n *   '\\n';\n *\n *   // Automatically packed values - values across fewer textures/passes.\n *   state.maps = mapGroups({ ...maps, buffersMax: 1 });\n *   state.size = { count: 2**5 };\n *   macroValues(state); // =>\n *   '#define texture_1 0\\n'+\n *   '#define channels_1 rgba\\n'+\n *   '\\n'+\n *   '#define texture_0 1\\n'+\n *   '#define channels_0 rg\\n'+\n *   '\\n'+\n *   '#define texture_2 1\\n'+\n *   '#define channels_2 b\\n'+\n *   '\\n'+\n *   '#define count 32\\n'+\n *   '#define textures 2\\n'+\n *   '#define passes 2\\n'+\n *   '#define stepsPast 1\\n'+\n *   '#define steps 2\\n'+\n *   '\\n';\n *\n *   // Can bind more texture outputs per pass - values across fewer passes.\n *   state.maps = mapGroups({ ...maps, buffersMax: 4 });\n *   macroValues(state); // =>\n *   '#define texture_1 0\\n'+\n *   '#define channels_1 rgba\\n'+\n *   '\\n'+\n *   '#define texture_0 1\\n'+\n *   '#define channels_0 rg\\n'+\n *   '\\n'+\n *   '#define texture_2 1\\n'+\n *   '#define channels_2 b\\n'+\n *   '\\n'+\n *   '#define count 32\\n'+\n *   '#define textures 2\\n'+\n *   '#define passes 1\\n'+\n *   '#define stepsPast 1\\n'+\n *   '#define steps 2\\n'+\n *   '\\n';\n * ```\n *\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *   the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled\n *   or prefixed. See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {object} state.maps How values are grouped per-`texture` per-pass\n *   per-step.\n * @param {array.<number>} state.maps.values How values of each data item are\n *   grouped into `texture`s. See `mapGroups`.\n * @param {array.<array.<number>>} state.maps.textures The groupings of values\n *   into `texture`s. See `mapGroups`.\n * @param {array} state.maps.passes Passes drawn per-step. See `mapGroups`.\n * @param {array|number} state.steps States drawn across frames. See `getState`.\n * @param {number} [state.bound=boundDef] How many steps are bound as outputs,\n *   unavailable as inputs.\n * @param {object} [state.size] Any size information about the GL resources.\n * @param {number} [state.size.count] The number of data entries per `texture`\n *   (the `texture`'s area), if given. See `getState`.\n * @param {object|false} [state.cache=cacheDef] Any object to cache any inputs'\n *   results in, `false`y to skip caching; uses `cacheDef` if not given.\n *\n * @returns {string} The `GLSL` preprocessor macros defining the mappings from\n *   values to `texture`s/channels.\n */\nexport function macroValues(state, on) {\n  const key = hooks.macroValues;\n  const hook = hasMacros(state, key, on);\n\n  if(hook !== null) { return hook; }\n\n  const { maps, steps, bound = boundDef, size, pre: n = preDef } = state;\n  const { cache = cacheDef } = state;\n  const { values, textures, passes: { length: passesL } } = maps;\n  const stepsL = steps.length ?? steps;\n  const count = size?.count;\n\n  const c = cache &&\n    `macro@${key}@${\n      n}|${bound}|${id(values)}|${id(textures)}|${stepsL}|${passesL}|${count}`;\n\n  const to = cache?.[c] ??\n    reduce((s, texture, t, _, i = 0) => reduce((s, v) =>\n          s+`#define ${n}texture_${v} ${t}\\n`+\n          `#define ${n}channels_${v} ${rgba.slice(i, i += values[v])}\\n\\n`,\n        texture, s),\n      textures, '')+\n    ((count)? `#define count ${count}\\n` : '')+\n    `#define ${n}textures ${textures.length}\\n`+\n    `#define ${n}passes ${passesL}\\n`+\n    `#define ${n}stepsPast ${stepsL-bound}\\n`+\n    `#define ${n}steps ${stepsL}\\n`+\n    `#define ${n}bound ${bound}\\n\\n`;\n\n  return ((cache)? cache[c] = to : to);\n}\n\n/**\n * Defines the outputs being drawn to per-pass, as `GLSL` preprocessor macros.\n *\n * These macros define mappings from values to their outputs, if bound.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see {@link hasMacros}\n * @see {@link maps.mapGroups}\n * @see {@link state.getState}\n * @see {@link const.cacheDef}\n *\n * @example ```\n *   const maps = { values: [2, 4, 1], channelsMax: 4 };\n *\n *   // No optimisations - values not packed, single texture output per pass.\n *   const state = {\n *     pre: '', passNow: 0,\n *     maps: mapGroups({ ...maps, buffersMax: 1, packed: 0 })\n *   };\n *\n *   macroOutput(state); // =>\n *   '#define passNow 0\\n'+\n *   '\\n'+\n *   '#define bound_0 0\\n'+\n *   '#define attach_0 0\\n'+\n *   '#define output_0 gl_FragData[attach_0].rg\\n'+\n *   '\\n';\n *\n *   // Automatically packed values - values across fewer textures/passes.\n *   state.maps = mapGroups({ ...maps, buffersMax: 1 });\n *   macroOutput(state); // =>\n *   '#define passNow 0\\n'+\n *   '\\n'+\n *   '#define bound_1 0\\n'+\n *   '#define attach_1 0\\n'+\n *   '#define output_1 gl_FragData[attach_1].rgba\\n'+\n *   '\\n';\n *\n *   // Next pass in this step.\n *   ++state.passNow;\n *   macroOutput(state); // =>\n *   '#define passNow 1\\n'+\n *   '\\n'+\n *   '#define bound_0 1\\n'+\n *   '#define attach_0 0\\n'+\n *   '#define output_0 gl_FragData[attach_0].rg\\n'+\n *   '\\n'+\n *   '#define bound_2 1\\n'+\n *   '#define attach_2 0\\n'+\n *   '#define output_2 gl_FragData[attach_2].b\\n'+\n *   '\\n';\n *\n *   // Can bind more texture outputs per pass - values across fewer passes.\n *   state.maps = mapGroups({ ...maps, buffersMax: 4 });\n *   state.passNow = 0;\n *   macroOutput(state); // =>\n *   '#define passNow 0\\n'+\n *   '\\n'+\n *   '#define bound_1 0\\n'+\n *   '#define attach_1 0\\n'+\n *   '#define output_1 gl_FragData[attach_1].rgba\\n'+\n *   '\\n'+\n *   '#define bound_0 1\\n'+\n *   '#define attach_0 1\\n'+\n *   '#define output_0 gl_FragData[attach_0].rg\\n'+\n *   '\\n'+\n *   '#define bound_2 1\\n'+\n *   '#define attach_2 1\\n'+\n *   '#define output_2 gl_FragData[attach_2].b\\n'+\n *   '\\n';\n * ```\n *\n * @param {object} state Properties for generating the macros. See `getState`:\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *   the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *   See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `pre` if not given.\n * @param {number} state.passNow The index of the currently active pass.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *   per-step. See `mapGroups`.\n * @param {array.<number>} state.maps.values How values of each data item may be\n *   grouped into textures across passes. See `mapGroups`.\n * @param {array.<array.<number>>} state.maps.textures The groupings of values\n *   into textures. See `mapGroups`.\n * @param {array.<array.<number>>} state.maps.passes The groupings of textures\n *   into passes. See `mapGroups`.\n * @param {object|false} [state.cache=cacheDef] Any object to cache any inputs'\n *   results in, `false`y to skip caching; uses `cacheDef` if not given.\n *\n * @returns {string} `GLSL` preprocessor macros for the pass's bound outputs.\n */\nexport function macroOutput(state, on) {\n  const key = hooks.macroOutput;\n  const hook = hasMacros(state, key, on);\n\n  if(hook !== null) { return hook; }\n\n  const { passNow: p, maps, pre: n = preDef, cache = cacheDef } = state;\n  const { values, textures, passes } = maps;\n  const pass = passes[p];\n\n  const c = cache &&\n    `macro@${key}@${n}|${p}|${id(values)}|${id(textures)}|${id(passes)}`;\n\n  const to = cache?.[c] ??\n    `#define ${n}passNow ${p}\\n`+\n    reduce((s, texture, bound, _, i = 0) => reduce((s, v) =>\n          s+'\\n'+\n          `#define ${n}bound_${v} ${texture}\\n`+\n          `#define ${n}attach_${v} ${bound}\\n`+\n          `#define ${n}output_${v} gl_FragData[${n}attach_${v}].${\n            rgba.slice(i, i += values[v])}\\n`,\n        textures[texture], s),\n      pass, '')+'\\n';\n\n  return ((cache)? cache[c] = to : to);\n}\n\n/**\n * Defines the texture samples/reads per-pass, as `GLSL` preprocessor macros.\n *\n * The macros define the mapping between the values and those they derive from,\n * as step/texture locations in a `samples` list, and indexes to read values\n * from sampled data in a `reads` list (once sampled into a `data` list, as in\n * `macroTaps` or similar).\n *\n * They're set up as function-like macros that may be called from the shader to\n * initialise the mappings arrays with a given name.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see {@link macroTaps}\n * @see {@link hasMacros}\n * @see {@link getGLSLList}\n * @see {@link maps.mapValues}\n * @see {@link state.getState}\n * @see {@link const.cacheDef}\n *\n * @example ```\n *   const values = [2, 4, 1];\n *   const derives = [2, , [[1, 0], true]];\n *   const maps = { values, derives, channelsMax: 4 };\n *\n *   // No optimisations - values not packed, single texture output per pass.\n *   const state =\n *     { pre: '', maps: mapValues({ ...maps, buffersMax: 1, packed: 0 }) };\n *\n *   // Uses the first pass by default.\n *   macroSamples(state); // =>\n *   '#define useSamples'+cr+\n *     'const int samples_l = 1;'+cr+\n *     'const ivec2 samples_0 = ivec2(0, 2);\\n'+\n *   '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *     'use name (e.g: `samples_0`) if possible.\\n'+\n *   '#define samples_i(i) samples_0\\n'+\n *   '\\n'+\n *   '#define useReads_0'+cr+\n *     'const int reads_0_l = 1;'+cr+\n *     'const int reads_0_0 = int(0);\\n'+\n *   '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+\n *     'use name (e.g: `reads_0_0`) if possible.\\n'+\n *   '#define reads_0_i(i) reads_0_0\\n'+\n *   '\\n';\n *\n *   // Next pass in this step - no derives, no samples nor reads.\n *   state.passNow = 1;\n *   macroSamples(state); // =>\n *   '';\n *\n *   // Next pass in this step.\n *   ++state.passNow;\n *   macroSamples(state); // =>\n *   '#define useSamples'+cr+\n *     'const int samples_l = 4;'+cr+\n *     'const ivec2 samples_0 = ivec2(1, 0);'+cr+\n *     'const ivec2 samples_1 = ivec2(0, 0);'+cr+\n *     'const ivec2 samples_2 = ivec2(0, 1);'+cr+\n *     'const ivec2 samples_3 = ivec2(0, 2);\\n'+\n *   '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *     'use name (e.g: `samples_0`) if possible.\\n'+\n *   '#define samples_i(i) ((i == 3)? samples_3 : ((i == 2)? samples_2 '+\n *     ': ((i == 1)? samples_1 : samples_0)))\\n'+\n *   '\\n'+\n *   '#define useReads_2'+cr+\n *     'const int reads_2_l = 4;'+cr+\n *     'const int reads_2_0 = int(0);'+cr+\n *     'const int reads_2_1 = int(1);'+cr+\n *     'const int reads_2_2 = int(2);'+cr+\n *     'const int reads_2_3 = int(3);\\n'+\n *   '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+\n *     'use name (e.g: `reads_2_0`) if possible.\\n'+\n *   '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *     ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n *   '\\n';\n *\n *   // Automatically packed values - values across fewer textures/passes.\n *   // Can bind more texture outputs per pass - values across fewer passes.\n *   // Also fewer samples where values share derives or textures.\n *   state.maps = mapGroups({ ...maps, buffersMax: 4 });\n *   state.passNow = 0;\n *   macroSamples(state); // =>\n *   '#define useSamples'+cr+\n *     'const int samples_l = 3;'+cr+\n *     'const ivec2 samples_0 = ivec2(0, 1);'+cr+\n *     'const ivec2 samples_1 = ivec2(1, 1);'+cr+\n *     'const ivec2 samples_2 = ivec2(0, 0);\\n'+\n *   '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *     'use name (e.g: `samples_0`) if possible.\\n'+\n *   '#define samples_i(i) '+\n *     '((i == 2)? samples_2 : ((i == 1)? samples_1 : samples_0))\\n'+\n *   '\\n'+\n *   '#define useReads_0'+cr+\n *     'const int reads_0_l = 1;'+cr+\n *     'const int reads_0_0 = int(0);\\n'+\n *   '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+\n *     'use name (e.g: `reads_0_0`) if possible.\\n'+\n *   '#define reads_0_i(i) reads_0_0\\n'+\n *   '\\n'+\n *   '#define useReads_2'+cr+\n *     'const int reads_2_l = 4;'+cr+\n *     'const int reads_2_0 = int(1);'+cr+\n *     'const int reads_2_1 = int(0);'+cr+\n *     'const int reads_2_2 = int(2);'+cr+\n *     'const int reads_2_3 = int(0);\\n'+\n *   '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+\n *     'use name (e.g: `reads_2_0`) if possible.\\n'+\n *   '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *     ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n *   '\\n';\n * ```\n *\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both the\n *   hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *   See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {number} [state.passNow=0] The index of the currently active pass;\n *   uses the first pass if not given.\n * @param {object} state.maps  How `values` are grouped per-texture per-pass\n *   per-step. See `mapGroups`.\n * @param {array.<array.<array.<number>>>} [state.maps.samples] The minimal set\n *   of texture samples to use. See `mapSamples`.\n * @param {array.<array.<array.<number>>>} [state.maps.reads] The mappings from\n *   values to the corresponding `state.samples`. See `mapSamples`.\n * @param {number} [state.glsl=1] The `GLSL` language version.\n *   See `getGLSLList`.\n * @param {object|false} [state.cache=cacheDef] Any object to cache any inputs'\n *   results in, `false`y to skip caching; uses `cacheDef` if not given.\n *\n * @returns {string} `GLSL` preprocessor macros defining the mappings for\n *   samples and reads, for each value.\n */\nexport function macroSamples(state, on) {\n  const key = hooks.macroSamples;\n  const hook = hasMacros(state, key, on);\n\n  if(hook !== null) { return hook; }\n\n  const { passNow: p = 0, maps, glsl, pre: n = preDef } = state;\n  const { cache = cacheDef } = state;\n  const { samples, reads } = maps;\n  const passSamples = samples?.[p];\n  const passReads = reads?.[p];\n\n  const c = cache &&\n    `macro@${key}@${n}|${p}|${id(passSamples)}|${id(passReads)}|${glsl}`;\n\n  const to = cache?.[c] ??\n    ((!passSamples)? ''\n    : `#define ${n}useSamples${cr+\n        getGLSLList('ivec2', n+'samples', passSamples, 'const', glsl)}\\n`)+\n    ((!passReads)? ''\n    : reduce((s, reads, v) =>\n          `${s}#define ${n}useReads_${v}${cr+\n            getGLSLList('int', n+'reads_'+v, reads, 'const', glsl)}\\n`,\n        passReads, ''));\n\n  return ((cache)? cache[c] = to : to);\n}\n\n/**\n * Defines the samples of textures per-pass, as `GLSL` preprocessor macros.\n *\n * The macros define the minimal sampling of textures for the data the active\n * pass's values derive from; creates a `data` list containing the samples; the\n * `samples` list variable names are required as created by `macroSamples`.\n *\n * Handles sampling states in a flat array of textures, or merged in one texture\n * (in both `sampler2D`, and `sampler3D`/`sampler2DArray` where supported).\n * Merging allows shaders to access past steps by non-constant lookups; e.g:\n * attributes cause `sampler array index must be a literal expression` on\n * `GLSL3` spec and other platforms (e.g: `D3D`); note these need texture repeat\n * wrapping.\n *\n * They're set up as function-like macros that may be called from the shader to\n * initialise the mappings arrays with a given name.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see [`sampler array index must be a literal expression`](https://stackoverflow.com/a/60110986/716898)\n * @see [`sampler2DArray`](https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_2d_array.html)\n * @see [`sampler3D`](https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_3d.html)\n *\n * @see {@link macroSamples}\n * @see {@link hasMacros}\n * @see {@link getGLSLList}\n * @see {@link maps.mapValues}\n * @see {@link state.getState}\n * @see {@link inputs.getUniforms}\n * @see {@link const.cacheDef}\n *\n * @example ```\n *   const values = [2, 4, 1];\n *   const derives = [2, , [[1, 0], true]];\n *   const maps = { values, derives, channelsMax: 4 };\n *\n *   // No optimisations - values not packed, single texture output per pass.\n *   const state =\n *     { pre: '', maps: mapValues({ ...maps, buffersMax: 1, packed: 0 }) };\n *\n *   // Uses the first pass by default.\n *   macroTaps(state); // =>\n *   '@todo';\n *\n *   // Next pass in this step - no derives, no samples nor reads.\n *   state.passNow = 1;\n *   macroTaps(state); // =>\n *   '';\n *\n *   // Next pass in this step.\n *   ++state.passNow;\n *   macroTaps(state); // =>\n *   '@todo';\n *\n *   // Automatically packed values - values across fewer textures/passes.\n *   // Can bind more texture outputs per pass - values across fewer passes.\n *   // Also fewer samples where values share derives or textures.\n *   state.maps = mapGroups({ ...maps, buffersMax: 4 });\n *   state.passNow = 0;\n *   macroTaps(state); // =>\n *   '@todo';\n * ```\n *\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *   the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *   See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {number} [state.passNow=0] The index of the currently active pass;\n *   uses the first pass if not given.\n * @param {object} state.maps  How `values` are grouped per-texture per-pass\n *   per-step. See `mapGroups`.\n * @param {array.<array.<array.<number>>>} [state.maps.samples] The minimal set\n *   of texture samples to use. See `mapSamples`.\n * @param {object} [state.merge] Any merged state texture; uses separate state\n *   textures if not given. See `getState`.\n * @param {number} [state.glsl=1] The `GLSL` language version.\n *   See `getGLSLList`.\n * @param {object|false} [state.cache=cacheDef] Any object to cache any inputs'\n *   results in, `false`y to skip caching; uses `cacheDef` if not given.\n *\n * @returns {string} The `GLSL` preprocessor macros defining the minimal\n *   sampling of textures, to suit how states are stored (array of textures, or\n *   all merged into one texture) and supported `GLSL` language features.\n */\nexport function macroTaps(state, on) {\n  const key = hooks.macroTaps;\n  const hook = hasMacros(state, key, on);\n\n  if(hook !== null) { return hook; }\n\n  const { passNow: p = 0, maps, merge, glsl, pre: n = preDef } = state;\n  const { cache = cacheDef } = state;\n  const passSamples = maps.samples?.[p];\n  const index = !merge;\n\n  const c = cache &&\n    `macro@${key}@${n}|${p}|${id(passSamples)}|${index}|${glsl}`;\n\n  let to = cache?.[c];\n\n  if(to != null) { return to; }\n\n  const glsl3 = (glsl >= 3);\n  /** Which texture sampling function is available. */\n  const texture = 'texture'+((glsl3)? '' : '2D');\n  /** Short and common names for functions and parameters. */\n  const f = n+'tapState';\n  const tap = '#define '+f;\n  /** Common parameters, passed as `(..., stepBy, textureBy)` */\n  const by = `stepBy, textureBy`;\n  /** Aliases default names for brevity, main functions offer more control. */\n  const aka = `#define ${f}(uv)${cr+f}`;\n  const akaBy = `#define ${f}By(uv, ${by})${cr+f}`;\n  /** The current `sample`, as `[step, texture]`. */\n  const st = n+'samples_';\n  /** Prefix for private temporary variables. */\n  const t = '_'+n;\n  /** A temporary `array` to pass to `getGLSLList`. */\n  const tapsSamples = cache[key+':tapsSamples'] ??= [];\n  const tapsL = tapsSamples.length = passSamples?.length ?? 0;\n\n  /** The main `texture`-sampling logic. */\n  to = ((index)? '' : `#define ${n}mergedStates\\n\\n`)+\n    ((!tapsL)? ''\n    : ((index)?\n      /** Separate un-merged `texture`s accessed by constant index. */\n      '// States in a `sampler2D[]`; looks up 1D index and 2D `uv`; '+cr+\n        'past steps go later in the list.\\n'+\n      `// Pass constant array index values; \\`textures\\`.\\n`+\n      `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n      tap+`s(uv, states, textures)`+cr+\n        // Compute before the loop for lighter work.\n        `const int ${t}tlI = int(textures);`+cr+\n        `vec2 ${t}uvI = vec2(uv);`+cr+\n        // Sample into the `data` output list.\n        getGLSLList('vec4', n+'data',\n          map((_, i) => texture+\n              // Offset step, `texture`.\n              `(states[(int(${st+i}.s)*${t}tlI)+int(${st+i}.t)], ${t}uvI)`,\n            passSamples, tapsSamples),\n          '', glsl)+'\\n'+\n      '// States may also be sampled by shifted step/texture.\\n'+\n      `// Pass constant array index values; \\`textures, ${by}\\`.\\n`+\n      `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n      tap+`sBy(uv, states, textures, ${by})`+cr+\n        // Compute before the loop for lighter work.\n        `const int ${t}tlIB = int(textures);`+cr+\n        `ivec2 ${t}byIB = ivec2(${by});`+cr+\n        `vec2 ${t}uvIB = vec2(uv);`+cr+\n        // Sample into the `data` output list.\n        getGLSLList('vec4', n+'data',\n          map((_, i) =>\n              texture+'(states['+\n                  // Offset step.\n                  `((int(${st+i}.s)+${t}byIB.s)*${t}tlIB)+`+\n                  // Offset `texture`.\n                  `int(${st+i}.t)+${t}byIB.t`+\n                `], ${t}uvIB)`,\n            passSamples, tapsSamples),\n          '', glsl)+'\\n'+\n      '// Preferred aliases: index suits states array constant access.\\n'+\n      aka+`s(uv, ${n}states, ${n}textures)\\n`+\n      akaBy+`sBy(uv, ${n}states, ${n}textures, ${by})\\n`\n    : /** Merged 2D `texture`. */\n      '// States merged to a `sampler2D`, scales 2D `uv` over '+\n        '`[textures, steps]`.\\n'+\n      '// Step from now into the past going upwards in the texture.\\n'+\n      `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n      tap+`2(uv, states, stepNow, steps, textures)`+cr+\n        // Compute before the loop for lighter work.\n        `vec2 ${t}l2 = vec2(textures, steps);`+cr+\n        `vec2 ${t}uv2 = vec2(uv)/${t}l2;`+cr+\n        // Steps advance in reverse, top-to-bottom.\n        `vec2 ${t}s2 = vec2(1, -1)/${t}l2;`+cr+\n        // Offset `texture`, step.\n        // Each step stored in `texture` top downward at `-stepNow`.\n        // Most recent step to look up is at `-stepNow+1`.\n        `vec2 ${t}i2 = vec2(0, 1)-vec2(0, stepNow);`+cr+\n        // Sample into the `data` output list.\n        getGLSLList('vec4', n+'data',\n          // Would repeat wrap; but `WebGL1` needs power-of-2.\n          map((_, i) =>\n              texture+`(states, `+\n                // Offset `texture`, step.\n                `fract(${t}uv2+fract((vec2(${st+i}).ts+${t}i2)*${t}s2)))`,\n            passSamples, tapsSamples),\n          '', glsl)+'\\n'+\n      '// States may also be sampled by shifted step/texture.\\n'+\n      `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n      tap+`2By(uv, states, stepNow, steps, textures, ${by})`+cr+\n        // Compute before the loop for lighter work.\n        `vec2 ${t}l2B = vec2(textures, steps);`+cr+\n        `vec2 ${t}uv2B = vec2(uv)/${t}l2B;`+cr+\n        // Steps advance in reverse, top-to-bottom.\n        `vec2 ${t}s2B = vec2(1, -1)/${t}l2B;`+cr+\n        // Offset `texture`, step.\n        // Each step stored in `texture` top downward at `-stepNow`.\n        // Most recent step to look up is at `-stepNow+1`.\n        `vec2 ${t}i2B = vec2(${by}).ts+vec2(0, 1)-vec2(0, stepNow);`+cr+\n        // Sample into the `data` output list.\n        getGLSLList('vec4', n+'data',\n          // Would repeat wrap; but `WebGL1` needs power-of-2.\n          map((_, i) =>\n              texture+`(states, `+\n                // Offset `texture`, step.\n                `fract(${t}uv2B+fract((vec2(${st+i}).ts+${t}i2B)*${t}s2B)))`,\n            passSamples, tapsSamples),\n          '', glsl)+'\\n'+\n      ((!glsl3)?\n        '// Preferred aliases: 2D suits merged texture in GLSL < 1.\\n'+\n        aka+`2(uv, ${n}states, ${n}stepNow, ${n}steps, ${n}textures)\\n`+\n        akaBy+\n          `2By(uv, ${n}states, ${n}stepNow, ${n}steps, ${n}textures, ${by})\\n`\n      : /**\n         * Merged 3D `texture` types, supported from `GLSL3`.\n         * @todo Check and finish this.\n         */\n        '// States merged to `sampler3D` or `sampler2DArray`; 2D `uv` '+\n          'to 3D; scales `x` over `textures`, `z` over `steps` as:\\n'+\n        '// - `sampler3D`: the number of steps; depth, `[0, 1]`.\\n'+\n        '// - `sampler2DArray`: `1` or less; layer, `[0, steps-1]`.\\n'+\n        `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n        tap+`3(uv, states, stepNow, steps, textures)`+cr+\n          /** @see `...2()` above. */\n          // Compute before the loop for lighter work.\n          `vec2 ${t}l3 = vec2(textures, steps);`+cr+\n          `vec2 ${t}uv3 = vec2(uv)/${t}l3;`+cr+\n          // Offset `texture`.\n          `float ${t}sx3 = 1.0/${t}l3.x;`+cr+\n          // Offset step.\n          `float ${t}s3 = -float(stepNow);`+cr+\n          `float ${t}sz3 = -1.0/${t}l3;`+cr+\n          // Sample into the `data` output list.\n          getGLSLList('vec4', n+'data',\n            // Would repeat wrap; but `sampler2DArray` layer can't.\n            map((_, i) =>\n                texture+'(states, fract(vec3('+\n                  // Offset `texture`.\n                  `${t}uv3.x+(float(${st+i}.t)*${t}sx3), ${t}uv3.y, `+\n                  // Offset step: `sampler3D` depth, `[0, 1]`;\n                  // `sampler2DArray` layer, `[0, steps-1]`.\n                  `(float(${st+i}.s)+${t}s3)*${t}sz3)))`,\n              passSamples, tapsSamples),\n            '', glsl)+'\\n'+\n        '// States may also be sampled by shifted step/`texture`.\\n'+\n        `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n        tap+`3By(uv, states, stepNow, steps, textures, ${by})`+cr+\n          /** @see `...2By()` above. */\n          // Compute before the loop for lighter work.\n          `vec2 ${t}l3B = vec2(textures, steps);`+cr+\n          `vec2 ${t}uv3B = (vec2(uv)+vec2(textureBy, 0))/${t}l3B;`+cr+\n          // Offset `texture`.\n          `float ${t}sx3B = 1.0/${t}l3B.x;`+cr+\n          // Offset step.\n          `float ${t}s3B = float(stepBy)-float(stepNow);`+cr+\n          `float ${t}sz3B = -1.0/${t}l3B;`+cr+\n          // Sample into the `data` output list.\n          getGLSLList('vec4', n+'data',\n            // Would repeat wrap; but `sampler2DArray` layer can't.\n            map((_, i) =>\n                texture+'(states, fract(vec3('+\n                  // Offset `texture`.\n                  `${t}uv3B.x+(float(${st+i}.t)*${t}sx3B), ${t}uv3B.y, `+\n                  // Offset step: `sampler3D` depth, `[0, 1]`;\n                  // `sampler2DArray` layer, `[0, steps-1]`.\n                  `(float(${st+i}.s)+${t}s3B)*${t}sz3B)))`,\n              passSamples, tapsSamples),\n            '', glsl)+'\\n'+\n        '// Preferred aliases: 3D suits merged texture in `GLSL` 3+.\\n'+\n        aka+`3(uv, ${n}states, ${n}stepNow, ${n}steps, ${n}textures)\\n`+\n        akaBy+\n          `3By(uv, ${n}states, ${n}stepNow, ${n}steps, ${n}textures, ${by})\\n`\n      ))+'\\n');\n\n  return ((cache)? cache[c] = to : to);\n}\n\n/**\n * Defines all `GLSL` preprocessor macro values, `texture` samples, and outputs\n * for the active pass.\n *\n * The macros define the mapping between the active values, their `texture`s and\n * channels, bound outputs, and other macros useful for a draw pass.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see {@link hasMacros}\n * @see {@link macroValues}\n * @see {@link macroOutput}\n * @see {@link macroTaps}\n * @see {@link macroSamples}\n * @see {@link maps.mapValues}\n * @see {@link state.getState}\n *\n * @example ```\n *   const values = [2, 4, 1];\n *   const derives = [2, , [[1, 0], true]];\n *\n *   // Automatically packed values - values across fewer `texture`s/passes.\n *   // Only a single `texture` output per pass - values across more passes.\n *   const state = {\n *     passNow: 0, steps: 2, size: { count: 2**5 },\n *     maps: mapValues({ values, derives, channelsMax: 4, buffersMax: 1 })\n *   };\n *\n *   macroPass(state); // =>\n *   '#define gpgpu_texture_1 0\\n'+\n *   '#define gpgpu_channels_1 rgba\\n'+\n *   '\\n'+\n *   '#define gpgpu_texture_0 1\\n'+\n *   '#define gpgpu_channels_0 rg\\n'+\n *   '\\n'+\n *   '#define gpgpu_texture_2 1\\n'+\n *   '#define gpgpu_channels_2 b\\n'+\n *   '\\n'+\n *   '#define count 32\\n'+\n *   '#define gpgpu_textures 2\\n'+\n *   '#define gpgpu_passes 2\\n'+\n *   '#define gpgpu_stepsPast 1\\n'+\n *   '#define gpgpu_steps 2\\n'+\n *   '\\n'+\n *   '#define gpgpu_passNow 0\\n'+\n *   '\\n'+\n *   '#define gpgpu_bound_1 0\\n'+\n *   '#define gpgpu_attach_1 0\\n'+\n *   '#define gpgpu_output_1 gl_FragData[gpgpu_attach_1].rgba\\n'+\n *   '\\n';\n *\n *   // Next pass and extra step.\n *   ++state.steps;\n *   ++state.passNow;\n *   state.pre = '';\n *   macroPass(state); // =>\n *   '#define texture_1 0\\n'+\n *   '#define channels_1 rgba\\n'+\n *   '\\n'+\n *   '#define texture_0 1\\n'+\n *   '#define channels_0 rg\\n'+\n *   '\\n'+\n *   '#define texture_2 1\\n'+\n *   '#define channels_2 b\\n'+\n *   '\\n'+\n *   '#define count 32\\n'+\n *   '#define textures 2\\n'+\n *   '#define passes 2\\n'+\n *   '#define stepsPast 2\\n'+\n *   '#define steps 3\\n'+\n *   '\\n'+\n *   '#define passNow 1\\n'+\n *   '\\n'+\n *   '#define bound_0 1\\n'+\n *   '#define attach_0 0\\n'+\n *   '#define output_0 gl_FragData[attach_0].rg\\n'+\n *   '\\n'+\n *   '#define bound_2 1\\n'+\n *   '#define attach_2 0\\n'+\n *   '#define output_2 gl_FragData[attach_2].b\\n'+\n *   '\\n'+\n *   '#define useSamples'+cr+\n *     'const int samples_l = 3;'+cr+\n *     'const ivec2 samples_0 = ivec2(0, 1);'+cr+\n *     'const ivec2 samples_1 = ivec2(1, 1);'+cr+\n *     'const ivec2 samples_2 = ivec2(0, 0);\\n'+\n *   '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *     'use name (e.g: `samples_0`) if possible.\\n'+\n *   '#define samples_i(i)'+cr+\n *     '((i == 2)? samples_2 : ((i == 1)? samples_1 : samples_0))\\n'+\n *   '\\n'+\n *   '#define useReads_0'+cr+\n *     'const int reads_0_l = 1;'+cr+\n *     'const int reads_0_0 = int(0);\\n'+\n *   '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+\n *     'use name (e.g: `reads_0_0`) if possible.\\n'+\n *   '#define reads_0_i(i) reads_0_0\\n'+\n *   '\\n'+\n *   '#define useReads_2'+cr+\n *     'const int reads_2_l = 4;'+cr+\n *     'const int reads_2_0 = int(1);'+cr+\n *     'const int reads_2_1 = int(0);'+cr+\n *     'const int reads_2_2 = int(2);'+cr+\n *     'const int reads_2_3 = int(0);\\n'+\n *   '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+\n *     'use name (e.g: `reads_2_0`) if possible.\\n'+\n *   '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *     ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n *   '\\n'+\n *   '// States in a `sampler2D[]`; looks up 1D index and 2D `uv`.\\n'+\n *   '@todo';\n * ```\n *\n * @param {object} state Properties for generating the macros. See `getState`\n *   and `mapGroups`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *   the hook key and this specifier are checked (e.g: `key` and `key_on`).\n *\n * @returns {string} The `GLSL` preprocessor macros defining the mappings for\n *   values, `texture`s, channels, bound outputs of the active pass, etc. See\n *   `macroValues`, `macroOutput`, and `macroSamples`.\n */\nexport const macroPass = (state, on) =>\n  hasMacros(state, hooks.macroPass, on) ??\n    macroValues(state)+macroOutput(state)+macroSamples(state)+macroTaps(state);\n\nexport default macroPass;\n","export const setC2 = (out, x, y) => (!out && (out = []), (out[0] = x), (out[1] = y), out);\nexport const setC3 = (out, x, y, z) => (!out && (out = []), (out[0] = x), (out[1] = y), (out[2] = z), out);\nexport const setC4 = (out, x, y, z, w) => (!out && (out = []),\n    (out[0] = x),\n    (out[1] = y),\n    (out[2] = z),\n    (out[3] = w),\n    out);\nexport const setC6 = (out, a, b, c, d, e, f) => (!out && (out = []),\n    (out[0] = a),\n    (out[1] = b),\n    (out[2] = c),\n    (out[3] = d),\n    (out[4] = e),\n    (out[5] = f),\n    out);\nexport const setC = (out, ...xs) => {\n    !out && (out = []);\n    for (let i = 0, n = xs.length; i < n; i++) {\n        out[i] = xs[i];\n    }\n    return out;\n};\n","/**\n * The `gpgpu` inputs - `uniforms`, `attribute`s, indexes, etc.\n *\n * @module\n * @category JS\n */\n\nimport { setC2, setC4 } from '@thi.ng/vectors/setc';\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap';\n\nimport { boundDef, preDef } from './const';\n\n/**\n * Sets up `GL` `uniform` inputs for `gpgpu` calls, such as in `getStep`.\n *\n * The `uniform`s are defined as callback hooks to be called on each render pass\n * with global context and local state `object`s, allowing the use of different\n * `GL` APIs or author-defined hooks.\n *\n * Handles inputs of states as `array`s of data-`texture`s, or merged into one\n * data-`texture`; for `array`s of `texture`s, this arranges them on each step\n * so `GLSL` can dynamically sample the flattened `array` of `texture`s by a\n * constant step index; otherwise the single merged `texture` is bound once, and\n * `GLSL` can use a dynamic step index to sample states.\n *\n * @example ```javascript\n * const state = { pre: '', steps: 2, maps: mapValues({ values: [1, 2, 3] }) };\n * const api = {};\n *\n * getUniforms(getState(api, { ...state, merge: false }, {})); // =>\n * {\n *   stepNow: (context, state) => {},\n *   stateShape: (context, state) => {},\n *   viewShape: (context, state) => {},\n *   // Separate state data-`texture`s in an `array` (e.g: `sampler2D[]`).\n *   // State data-`texture`s for the 1st step ago, not bound as outputs.\n *   'states[0]': (context, state) => {},\n *   'states[1]': (context, state) => {},\n *   // Merged `texture` not used.\n *   states: (context, state) => null\n * };\n *\n * getUniforms(getState(api, { ...state, steps: 3, merge: false }, {})); // =>\n * {\n *   stepNow: (context, state) => {},\n *   stateShape: (context, state) => {},\n *   viewShape: (context, state) => {},\n *   // Separate state data-`texture`s in an `array` (e.g: `sampler2D[]`).\n *   // State data-`texture`s for the 1st step ago, not bound as outputs.\n *   'states[0]': (context, state) => {},\n *   'states[1]': (context, state) => {}\n *   // State data-`texture`s for the 2nd step ago, not bound as outputs.\n *   'states[2]': (context, state) => {},\n *   'states[3]': (context, state) => {},\n *   // Merged `texture` not used.\n *   states: (context, state) => null\n * };\n *\n * getUniforms(getState(api, { ...state, merge: true }, {})); // =>\n * {\n *   stepNow: (context, state) => {},\n *   stateShape: (context, state) => {},\n *   viewShape: (context, state) => {},\n *   // Merged states in one data-`texture` upon every pass (e.g: `sampler2D`,\n *   // or `sampler3D`/`sampler2DArray` where supported).\n *   states: (context, state) => {},\n *   // Separate data-`texture`s not used.\n *   'states[0]': (context, state) => null,\n *   'states[1]': (context, state) => null,\n *   // ...etc...\n * };\n * ```\n *\n * @see {@link uniforms}\n * @see {@link getUniform}\n * @see {@link step.getStep}\n * @see {@link state.getState}\n * @see {@link maps.mapGroups}\n * @see {@link macros.macroSamples}\n * @see {@link macros.macroTaps}\n *\n * @param {object} state The `gpgpu` state. See `getState` and `mapGroups`.\n * @param {array|number} state.steps The `array` of steps, or number of steps.\n *   See `getState`.\n * @param {{textures?:number[][]}} state.maps How values are grouped into\n *   data-`texture`s (per-pass per-step). See `mapGroups`.\n * @param {string} [state.pre=preDef] Namespace prefix; `preDef` if not given.\n * @param {{all?:{texture?:object}}} [state.merge] Any merged state `texture`;\n *   uses separate state data-`texture`s if not given. See `getState`.\n *\n * @param {{shape?:number[],merge?:{shape?:number[]}}} [state.size] Any size of\n *   `state` data-`texture`s (each as `[width, height]`), with properties:\n *   - `shape`: Any `state` shape.\n *   - `merge.shape`: Any merged `states` shape, otherwise `state` shape.\n *\n *   See `getState`.\n *\n * @param {number} [state.bound=boundDef] Number of steps bound for output, not\n *   used for input; for platforms preventing read/write of the same `texture`.\n * @param {object} [state.uniforms] Any `object` to merge the new `uniforms`\n *   into. See `to`.\n * @param {object} [to=state.uniforms] Any `object` to contain the `uniform`\n *   hooks; modifies any `state.uniforms`, or a new `object` if not given.\n *   See `state.uniforms` and `uniforms`.\n *\n * @returns {uniforms} The `to` set up with `uniform` hooks for the given\n *   `state`. See `uniforms`.\n */\nexport function getUniforms(state, to = state.uniforms ?? {}) {\n  const { pre: n = preDef, steps, maps, bound = boundDef } = state;\n  const { textures } = maps;\n  const stepsL = steps.length ?? steps;\n  const texturesL = textures.length;\n  const stateShape = [];\n  const viewShape = [];\n\n  to[n+'stepNow'] = (_, s) => s.stepNow;\n\n  /**\n   * Shape of any data-`texture`, and any other relevant data shape (any\n   * `merge`d `texture` or the same data-`texture` shape).\n   * Sets properties to `null`ish if there's no valid shape.\n   */\n  to[n+'stateShape'] = (_, { size: { shape: s, merge: m } }) =>\n    ((s)? setC4(stateShape, ...s, ...(m?.shape ?? s)) : setC4(stateShape));\n\n  to[n+'viewShape'] = ({ drawingBufferWidth: w, drawingBufferHeight: h }) =>\n    setC2(viewShape, w, h);\n\n  /**\n   * Past steps, all merged into one `texture`.\n   * Only returns a value if using a `merge`d `texture`; otherwise `null`.\n   */\n  to[n+'states'] = (_, s) => s.merge?.all?.texture ?? null;\n\n  /**\n   * Past steps, each some steps `ago`, from the current active step at `0`, as\n   * `[0,... stepsL-1-bound]`.\n   */\n  const addTextures = (ago) =>\n    /**\n     * Hooks to pull a given `texture` by the active pass `props`; lets `GLSL`\n     * access the `array` of `texture`s by constant index (steps ago).\n     * Only returns a value if not using a `merge`d `texture`; otherwise `null`.\n     */\n    each((_, t) => to[n+`states[${(ago*texturesL)+t}]`] =\n        (_, { merge: m, stepNow: s, bound: b = bound, textures: ts }) =>\n          ((m)? null : wrap(s-b-ago, ts)?.[t]?.texture),\n      textures);\n\n  /** Flatten all input `texture`s, as `uniform`s are kept in flat `array`s. */\n  for(let ago = 0, pl = stepsL-bound; ago < pl; ++ago) { addTextures(ago); }\n\n  return to;\n}\n\n/**\n * @typedef {object} uniforms\n *\n * The `uniform` callback hooks for a given `state`, to be called on each render\n * pass to get the latest `uniform` values.\n *\n * Its property names may be prefixed with any given `state.pre`.\n *\n * **See**\n * - {@link state.getState}\n * - {@link step.getStep}\n *\n * @property {getUniform} stepNow Gives any current step. See `getStep`.\n *\n * @property {getUniform} stateShape Gives any size of `state` data-`texture`s\n *   (as a `vec4` of `[[width, height], [width, height]]`; channels are\n *   `null`ish if there's no valid shape):\n *   - Any `state` shape; in `xy` channels.\n *   - Any merged `states` shape, otherwise `state` shape; in `zw` channels.\n *\n *   See `getState`.\n *\n * @property {getUniform} viewShape Gives the shape of the `GL` viewport (as a\n *   `vec2` of `[width, height]`).\n *\n * @property {getUniform} states Gives the past steps data-`texture`s as either:\n *   - Any merged data-`texture` as a single `GLSL` `sampler` (e.g: `2D`/\n *     `2DArray`/`3D`; up to to the `GL` API for `texture`); otherwise `null`.\n *   - Any separate data-`texture`s as a `GLSL` `array` of `sampler`s (e.g:\n *     `sampler2D[]`), each part/all of a `gpgpu` step's data and accessible by\n *     constant index (steps ago); otherwise `null`.\n *\n *   See `getStep`.\n */\n\n/**\n * @todo [Fix `@callback`:  nested `@param`, `@return`/`@see`/etc details](https://github.com/TypeStrong/typedoc/issues/1896)\n *\n * @typedef {(context: {\n *     drawingBufferWidth:number,\n *     drawingBufferHeight:number\n *   },\n *   props: {\n *     stepNow:number,\n *     bound:number,\n *     merge:{texture:object},\n *     textures:{texture:object}[][]\n *   }) => number|number[]|texture|object} getUniform\n *\n * Function hook to update a `uniform` on each render pass for its latest value.\n *\n * **See**\n * - {@link getUniforms}\n * - {@link state.getState}\n * - {@link state.texture}\n *\n * **Parameters**\n * - `context`: General or global properties.\n *   - `drawingBufferWidth`: Current `GL` viewport width in pixels.\n *   - `drawingBufferHeight`: Current `GL` viewport height in pixels.\n * - `props`: Local properties (`gpgpu` `state`).\n *   - `stepNow`: The current step of the `gpgpu` `state`.\n *   - `bound`: Number of steps bound to output; can't be bound as inputs.\n *   - `merge`: Any `object` containing merged data-`texture`.\n *     - `texture`: Any merged data-`texture`.\n *   - `textures`: Textures per-step, as `array`s of `object`s with a `texture`\n *     property. See `getState`.\n *\n * **Returns**\n * - `uniform` A `GL` uniform to be bound via a `GL` API.\n */\n\nexport default getUniforms;\n","/**\n * The `gpgpu` update step.\n *\n * Connects inputs to the `GL` state and renders an update step.\n *\n * @module\n * @category JS\n */\n\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap';\n\nimport { macroPass } from './macros';\nimport { getUniforms } from './inputs';\nimport { vertDef, positionsDef, preDef } from './const';\n\nconst scale = { vec2: 0.5 };\n\nexport const cache = {\n  clearPass: { color: [0, 0, 0, 0], depth: 1, stencil: 0 },\n  copyFrame: { color: null }, copyImage: { copy: true }\n};\n\n/**\n * Convenience to get the currently active `framebuffer`.\n *\n * @see {@link state.getState}\n *\n * @param {object} state The `gpgpu` state.\n * @param {array.<object>} state.passes Passes per step. See `getState`.\n * @param {number} [state.stepNow] The currently active state step, if any.\n * @param {number} [state.passNow] The currently active draw pass, if any.\n *\n * @returns {object} The active step's active pass object, if any.\n */\nexport const getPass = ({ passes: ps, stepNow: s, passNow: p }) =>\n  wrap(s, ps)?.[p];\n\n/**\n * Merged `texture` update, called upon each pass.\n *\n * Copies the active pass's output into the merged `texture`, from each of its\n * attachments one by one (to support multiple draw buffers).\n * Matches the lookup logic defined in `macroTaps`.\n *\n * @todo Update docs.\n *\n * @see [SO reading from multiple `framebuffers`](https://stackoverflow.com/a/34160982/716898)\n * @see {@link getPass}\n * @see {@link state.texture}\n * @see {@link state.getState}\n * @see {@link maps.mapGroups}\n * @see {@link macros.macroTaps}\n *\n * @param {object} state A `gpgpu` state of the active pass.\n * @param {array.<object.<array.<texture>,array.<number>>>} state.passes Passes per\n *   step; the active one is found via `getPass`, with a `color` array of\n *   `texture`s, and a `map` array of numbers showing how the textures are\n *   grouped into the pass. See `getState` and `mapGroups`.\n * @param {merge} state.merge The merged `texture` to update.\n * @param {number} [state.stepNow] The currently active state step, if any.\n *\n * @returns {texture} The merged `texture`, updated by the active pass's output;\n *   matches the lookup logic defined in `macroTaps`.\n */\n export function updateMerge(state) {\n  const { color, map: pass } = getPass(state);\n  const { merge, stepNow: s, size } = state;\n  const { all: { texture: to }, next: { framebuffer: f } } = merge;\n\n  // Silent exit if there's not enough info ready now to perform the update.\n  if(!(to && f && color && pass && (s || (s === 0)))) { return to; }\n\n  const { steps: sl, shape: [w, h] } = size;\n  /** Start at the top of the `texture`, move down row-per-step and wrap. */\n  const y = (s%sl)*h;\n  const { copyFrame: cf, copyImage: ci } = cache;\n\n  /** Reusable `framebuffer` copies pass's pixels to the merged `texture`. */\n  each((c, i) =>\n      ((cf.color = c) && f(cf).use(() => to.subimage(ci, pass[i]*w, y))),\n    color);\n\n  return to;\n}\n\n/**\n * Creates a `gpgpu` update step function, for use with a `gpgpu` state object.\n *\n * @todo Make this fully extensible in state.\n * @todo Example\n *\n * @see {@link buffer}\n * @see {@link command}\n * @see {@link subimage}\n * @see {@link onStep}\n * @see {@link onPass}\n * @see {@link getPass}\n * @see {@link state.getState}\n * @see {@link maps.mapGroups}\n * @see {@link macros.macroPass}\n * @see {@link inputs.getUniforms}\n *\n * @param {object} api An API for `GL` resources.\n * @param {buffer} [api.buffer] Function to set up a `GL` buffer.\n * @param {clear} [api.clear] Function to clear `GL` view or `framebuffer`.\n * @param {command} [api.command=api] Function to create a `GL` render pass,\n *   given options, to be called later with options; `api` if not given.\n * @param {object} state The `gpgpu` state to use. See `getState` and\n *   `mapGroups`.\n * @param {object} state.maps How values are grouped per-`texture` per-pass\n *   per-step. See `mapGroups`.\n * @param {array.<array.<number>>} state.passes How textures are grouped into\n *   passes. See `mapGroups`.\n * @param {object} [state.merge] Any merged state `texture`; uses separate state\n *   textures if not given.\n * @param {object} [state.merge.texture] Any `GL` `texture` of `state.merge`.\n * @param {subimage} [state.merge.texture.subimage] A function to update part of\n *   the merge `GL` `texture` object data. See `subimage`.\n * @param {function} [state.merge.update] Hook to update, if any; if not given,\n *   `state.merge.texture` is updated here with active states upon each pass.\n *\n *   The default merged `texture` is laid out as `[texture, step]` on the\n *   `[x, y]` axes, respectively; if other layouts are needed, this merge update\n *   hook can be given to use as-is, and the setup and lookup logic in their\n *   respective hooks.\n *\n *   See `getState` and `macroTaps`.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n * @param {object} [state.step=to] The properties for the step `GL` command.\n * @param {string} [state.step.vert=vertDef] The step vertex shader `GLSL`; a\n *   simple flat screen shader if not given.\n * @param {string} state.step.frag The step fragment shader `GLSL`.\n * @param {object} [state.step.uniforms=getUniforms(state)] The step uniforms;\n *   modifies any given. See `getUniforms`.\n * @param {array.<number>|buffer} [state.step.positions=positionsDef()] The step\n *   position attributes; 3 points of a large flat triangle if not given.\n * @param {number} [state.step.count=state.step.positions.length*scale.vec2] The\n *   number of elements/attributes to draw.\n * @param {object} [state.step.passCommand] Any `GL` command properties to mix\n *   in over the default ones here, and passed to `api.command`.\n * @param {string} [state.step.vert=vertDef] Vertex `GLSL` code to append to.\n * @param {array} [state.step.verts] Preprocesses and caches vertex `GLSL` code\n *   per-pass if given, otherwise processes it just-in-time before each pass.\n * @param {string} [state.step.frag] Fragment shader `GLSL` to append to.\n * @param {array} [state.step.frags] Preprocesses and caches fragment `GLSL`\n *   code per-pass, otherwise processes it just-in-time before each pass.\n * @param {onStep} [onStep] Callback upon each step.\n * @param {onPass} [onPass] Callback upon each pass.\n * @param {object} [to=(state.step ?? \\{\\})] The results object; `state.step` or\n *   a new object if not given.\n *\n * @returns {object} `to` The given `to` object; containing a `gpgpu` update\n *   step function and related properties, to be passed a `gpgpu` state.\n * @returns {string} `to.vert` The given/new `state.vert` vertex shader `GLSL`.\n * @returns {string} `to.frag` The given `state.frag` fragment shader `GLSL`.\n * @returns {array.string} `[to.verts]` Any cached pre-processed vertex shaders\n *   `GLSL`, if `state.step.verts` was given.\n * @returns {array.string} `[to.frags]` Any cached pre-processed fragment\n *   shaders `GLSL`, if `state.step.verts` was enabled.\n * @returns {object} `to.uniforms` The given `state.uniforms`.\n * @returns {number} `to.count` The given/new `state.count`.\n * @returns {buffer} `to.positions` The given/new `state.positions`; via\n *   `api.buffer`.\n * @returns {command} `to.pass` A `GL` command function to draw a given pass;\n *   via `api`/`api.command`.\n * @returns {function} `to.run` The main step function, which performs all the\n *   draw pass `GL` commands for a given state step.\n */\nexport function getStep(api, state, to = state.step ?? {}) {\n  const { buffer, clear, command = api } = api;\n  const { maps: { passes }, merge, pre: n = preDef, step = to } = state;\n  let { positions = positionsDef() } = step;\n\n  const {\n      passCommand, vert = vertDef, verts, frag, frags, uniforms,\n      count = positions.count ?? positions.length*scale.vec2\n    } = step;\n\n  to.vert = vert;\n  to.frag = frag;\n  to.uniforms = getUniforms(state, uniforms);\n  to.count = count;\n  positions = to.positions = buffer(positions);\n\n  // May pre-process and keep the shaders for all passes in advance.\n  if(verts || frags) {\n    // Keep the current pass.\n    const { passNow } = state;\n\n    verts && (to.verts = verts);\n    frags && (to.frags = frags);\n\n    each((pass, p) => {\n        // Create macros for this pass in advance.\n        state.passNow = p;\n        // Specify the shader type, for per-shader macro hooks.\n        verts && (verts[p] ??= macroPass(state, 'vert')+vert);\n        frags && (frags[p] ??= macroPass(state, 'frag')+frag);\n      },\n      passes);\n\n    // Set the pass back to what it was.\n    state.passNow = passNow;\n  }\n\n  /** The render command describing a full `GL` state for a step. */\n  to.pass = command(to.passCommand = {\n    // Uses the full-screen vertex shader state by default.\n    vert(_, s = state) {\n      const { passNow: p, step } = s;\n      const { vert: v = vert, verts: vs = verts } = step;\n\n      // Specify the shader type, for per-shader macro hooks.\n      return vs?.[p] ?? macroPass(s, 'macroVert')+v;\n    },\n    frag(_, s = state) {\n      const { passNow: p, step } = s;\n      const { frag: f = frag, frags: fs = frags } = step;\n\n      // Specify the shader type, for per-shader macro hooks.\n      return fs?.[p] ?? macroPass(s, 'macroFrag')+f;\n    },\n    attributes: {\n      [n+'position']: (_, s = state) => s.step.positions ?? positions\n    },\n    uniforms, count,\n    depth: { enable: false },\n    /** Note that this may draw to the screen if there's no active pass. */\n    framebuffer: (_, s = state) => getPass(s)?.framebuffer,\n    ...passCommand\n  });\n\n  /** Any merged `texture`'s update, set up if not already given. */\n  merge && (merge.update ??= updateMerge);\n\n  /** Executes the next step and all its passes. */\n  to.run = (s = state) => {\n    const { steps, step, merge } = s;\n    const stepNow = s.stepNow = s.stepNow+1 || 0;\n    const mergeUpdate = merge?.update;\n    const { pass, onPass, onStep } = step;\n    const stepProps = onStep?.(s, wrap(stepNow, steps)) ?? s;\n    const { clearPass } = cache;\n\n    each((p, i) => {\n        stepProps.passNow = i;\n\n        const passProps = onPass?.(stepProps, p) ?? stepProps;\n\n        /** @todo Remove unnecessary `clear` call? */\n        ((clearPass.framebuffer = getPass(passProps)?.framebuffer) &&\n          clear(clearPass));\n\n        pass(passProps);\n        // Update any merged `texture` upon each pass.\n        mergeUpdate?.(passProps);\n      },\n      stepProps.maps.passes);\n\n    return s;\n  };\n\n  return to;\n}\n\n/**\n * @todo [Fix `@callback`:  nested `@param`, `@return`/`@see`/etc details](https://github.com/TypeStrong/typedoc/issues/1896)\n *\n * @callback buffer\n * Function to set up a `GL` buffer; from a `GL` API.\n *\n * **See**\n * - {@link getStep}\n *\n * **Returns**\n * - `buffer` A `GL` buffer to use for vertex attributes, or an\n *   object serving that purpose.\n * - `[buffer.count]` The buffer element/vertex count.\n * - `[buffer.length]` The length of the buffer data `array`.\n *\n * @param {array.<number>|object.<number>} data Buffer data.\n *\n * @returns {object}\n */\n\n/**\n * @todo [Fix `@callback`:  nested `@param`, `@return`/`@see`/etc details](https://github.com/TypeStrong/typedoc/issues/1896)\n *\n * @callback clear\n * Function to clear `GL` output view or `framebuffer`; from a `GL` API.\n *\n * **See**\n * - {@link getStep}\n * - {@link state.framebuffer}\n *\n * @param {object} props The values to clear with.\n * @param {array.<number>} [color] The values to clear any color buffers with.\n * @param {number} [depth] The value to clear any depth buffer with.\n * @param {number} [stencil] The value to clear any stencil buffer with.\n * @param {framebuffer} [framebuffer] Any `framebuffer` to clear; if not given,\n *   clears any active `framebuffer` or the view.\n *\n * @returns {void}\n */\n\n/**\n * @todo [Fix `@callback`:  nested `@param`, `@return`/`@see`/etc details](https://github.com/TypeStrong/typedoc/issues/1896)\n *\n * @callback command\n * Function to create a `GL` render pass execution function, to be called later,\n * with options, for a render pass; from a `GL` API.\n *\n * **See**\n * - {@link getStep}\n * - {@link inputs.getUniforms}\n * - {@link state.framebuffer}\n *\n * **Returns**\n * - Function to execute a `GL` render pass, with options, for a render pass.\n *\n * @param {object} passCommand The properties from which to create the `GL`\n *   render function for a given pass.\n * @param {function} [passCommand.vert] Function hook returning the vertex\n *   shader `GLSL` string for the next render pass.\n * @param {function} [passCommand.frag] Function hook returning the fragment\n *   shader `GLSL` string for the next render pass.\n * @param {object.<buffer>} [passCommand.attributes] The vertex attributes for\n *   the next render pass.\n * @param {object.<function>} [passCommand.uniforms] The uniform hooks for the\n *   given `props`. See `getUniforms`.\n * @param {number} [passCommand.count] The number of elements to draw.\n * @param {object.<boolean,{}>} [passCommand.depth] An object describing the\n *   depth settings for the next render pass; e.g: `passCommand.depth.enable`.\n * @param {function} [passCommand.framebuffer] Function hook returning the\n *   `framebuffer` to draw to in the next render pass. See `framebuffer`.\n *\n * @returns {function}\n */\n\n/**\n * @todo [Fix `@callback`:  nested `@param`, `@return`/`@see`/etc details](https://github.com/TypeStrong/typedoc/issues/1896)\n *\n * @callback subimage\n * Function of a `GL` `texture` to update part of it with new data; from a `GL`\n * API.\n *\n * **See**\n * - {@link getStep}\n * - {@link state.texture}\n *\n * **Returns**\n * - The calling `texture`, with part updated part to `data`.\n *\n * @param {texture} data The data to update into part of the calling `texture`.\n * @param {number} [x=0] Offset on the x-axis within the calling `texture`.\n * @param {number} [y=0] Offset on the y-axis within the calling `texture`.\n *\n * @returns {texture}\n */\n\n/**\n * @todo [Fix `@callback`:  nested `@param`, `@return`/`@see`/etc details](https://github.com/TypeStrong/typedoc/issues/1896)\n *\n * @callback onStep\n * Callback upon each step.\n *\n * **See**\n * - {@link getStep}\n * - {@link state.getState}\n * - {@link state.framebuffer}\n *\n * **Returns**\n * - A `stepProps` object to use for each of the step's next passes; or\n *   `null`ish to use the given `props`.\n *\n * @param {object} [props] The `props` passed to `run`.\n * @param {array.<framebuffer>} step The `framebuffer`s for `props.stepNow` from\n *   `props.steps`, where the next state step will be drawn. See `getState`.\n *\n * @returns {object}\n */\n\n/**\n * @todo [Fix `@callback`:  nested `@param`, `@return`/`@see`/etc details](https://github.com/TypeStrong/typedoc/issues/1896)\n *\n * @callback onPass\n * Callback upon each pass.\n *\n * **See**\n * - {@link getStep}\n * - {@link maps.mapGroups}\n *\n * **Returns**\n * - A `passProps` object to use for the render `command` call; or `null`ish to\n *   use the given `stepProps`.\n *\n * @param {object} [stepProps] The `props` passed to `run` via any `onStep`.\n * @param {array.<number>} pass The maps for the next pass. See `mapGroups`.\n *\n * @returns {object}\n */\n\n/** A wrapper around `updateMerge`, handy for testing. */\nfunction updateMergeTest(state, update = updateMerge, after = 2) {\n  const { color, map: pass } = getPass(state);\n  const { merge: { all, next }, stepNow: s, passNow: p, size, maps } = state;\n  const { channels } = all;\n  const { steps: sl, shape: [w, h], merge: { shape: [wl, hl] } } = size;\n  const tl = maps.textures.length;\n  const y = (s%sl)*h;\n  const lc = y*tl*w;\n  const f = next?.framebuffer;\n  const to = update(state);\n\n  console.warn(s, p, pass, ':');\n  console.warn('- l', 0, 'r', tl*w, 'w', w, 'wl', wl);\n  console.warn('- t', y, 'b', y+h, 'h', h, 'hl', hl);\n  console.warn('- c', channels, 'lc', lc*channels, 'rc', (lc+(w*h))*channels,\n    'sc', w*h*channels, 'slc', wl*hl*channels);\n\n  f({ color: to }).use(() =>\n    console.warn(Array.prototype.reduce.call(regl.read(), (o, v, i) =>\n        o+((i)? ',\\t' : '')+\n        ((!i)? ''\n        : ((i%(tl*w*h*channels) === 0)?\n            `\\n${'='.repeat(100)}step${'='.repeat(100)}\\n`\n        : ((i%(tl*w*channels) === 0)? '\\n'\n        : ((i%(w*channels) === 0)? ' || \\t'\n        : ((i%channels === 0)? ' / \\t' : '')))))+\n        (i*1e-3).toFixed(3).slice(2)+': '+((v)? v.toFixed(2) : '___'),\n      '\\n')));\n\n  if(s && after && s%(sl*after) === 0) { debugger; }\n\n  return to;\n}\n\nexport default getStep;\n","/**\n * **Main `index.js` - see [`readme`](..)**\n *\n * [![`gl-gpgpu` particles demo](media://demo-particles-regl-frames.png)](..)\n *\n * [GPGPU](https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units)\n * state-stepping - declaratively maps optimal draw passes, shaders, `WebGL`\n * resources, inputs, outputs - lets you focus on your logic, BYO-renderer.\n *\n * Decouples logic from rendering approach/engine.\n * The modules and many hooks may be used as given, or piecemeal, or overridden.\n *\n * @module (index)\n * @category Main\n * @category JS\n */\n\nimport { mapValues } from './maps';\nimport { getState } from './state';\nimport { getStep } from './step';\n\n/**\n * Sets up all the maps, inputs, resources, etc for a `gpgpu` process.\n * Each component may also be used individually, see their documentation.\n *\n * @see {@link maps.mapValues}\n * @see {@link maps.mapGroups}\n * @see {@link maps.mapSamples}\n * @see {@link state.getState}\n * @see {@link inputs.getUniforms}\n * @see {@link step.getStep}\n * @see {@link macros.macroPass}\n *\n * @param {object} api An API for `GL` resources. See `getState` and `getStep`.\n * @param {object} [api.limits=api] A map of `GL` resource limits.\n * @param {number} [api.limits.maxDrawbuffers] The maximum number of `GL`\n *   `texture`s a `framebuffer` can bind in a single draw call.\n * @param {object} [state=\\{\\}] State properties to set up; a new `object` by\n *   default. See `getState`, `getUniforms`, and `getStep`.\n * @param {object} [state.maps] How values are grouped per-`texture` per-pass\n *   per-step. Sets up new maps if not given or missing its mapped properties.\n *   See `mapValues`.\n * @param {number} [state.maps.buffersMax=api.limits.maxDrawbuffers] Maximum\n *   number of `texture`s per draw pass. Uses more passes above this limit.\n * @param {object} [to=state] The state `object` to set up. Modifies the given\n *   `state` object by default.\n *\n * @returns {object} The given `to` `object`, set up for a `gpgpu` process.\n *   See `mapValues`, `getState`, `getUniforms`, `getStep` and `macroPass` for\n *   each constituent part.\n */\nexport function gpgpu(api, state = {}, to = state) {\n  const { maxDrawbuffers, glsl } = api.limits ?? api;\n  const { maps = {} } = state;\n  const { buffersMax } = maps;\n\n  to.glsl = parseFloat(glsl.match(/[0-9\\.]+/)?.[0], 10);\n\n  // Set up maps, and undo any modifications to the input.\n  maps.buffersMax = buffersMax ?? maxDrawbuffers;\n  mapValues(maps, to.maps ??= {});\n  maps.buffersMax = buffersMax;\n\n  // Set up the rest.\n  getState(api, state, to);\n  getStep(api, state, to.step ??= {});\n\n  return to;\n}\n\nexport default gpgpu;\n","/**\n * How many vertexes for a given form to cover each entry's steps of state:\n * - If 2 states or form are given, gives a setup of pairs for a line segment\n *   between each entry's steps of state using `gl.LINES`.\n * - If fewer than 2 states or form are given, gives a setup for a point at each\n *   entry's steps of state using `gl.POINTS`.\n *\n * Possibly useful for other forms too.\n *\n * Corresponds to the indexing logic in the `indexForms` `GLSL` function.\n *\n * @module\n * @category JS\n *\n * @see {@link index-forms/index-states.glsl!}\n * @see {@link index-forms/index-entries.glsl!}\n * @see [`gl.LINES`](https://webglfundamentals.org/webgl/lessons/webgl-points-lines-triangles.html)\n *\n * @param {number} [states=1] How many steps of state each entry has.\n * @param {number} [form=2] How many steps of state each form covers.\n * @param {number} [entries=1] How many entries, if any; result to be multiplied\n *   externally if not given.\n *\n * @returns {number} The number of vertexes needed for the given `form` to cover\n *   all steps of `states`; over all `entries` if given, to be multiplied\n *   externally if not given.\n *\n * @remarks [[include:src/index-forms/readme.md]]\n */\nexport const indexForms = (states = 1, form = 2, entries = 1) =>\n  Math.max(1, (states-form)+1)*form*entries;\n\nexport default indexForms;\n","/** Demo implementation of 3D particle Verlet/Euler integration simulation. */\n\nimport getRegl from 'regl';\nimport clamp from 'clamp';\nimport timer from '@epok.tech/fn-time';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\nimport each from '@epok.tech/fn-lists/each';\nimport range from '@epok.tech/fn-lists/range';\nimport wrap from '@epok.tech/fn-lists/wrap';\n\nimport gpgpu from '../../src';\n\nimport { extensionsFloat, extensionsHalfFloat, optionalExtensions }\n  from '../../src/const';\n\nimport { macroPass } from '../../src/macros';\nimport { mapValues } from '../../src/maps';\nimport { getUniforms } from '../../src/inputs';\nimport { getDrawIndexes } from '../../src/size';\nimport indexForms from '../../src/index-forms';\n\nimport stepFrag from './step.frag.glsl';\nimport drawVert from './draw.vert.glsl';\nimport drawFrag from './draw.frag.glsl';\n\nself.gpgpu = gpgpu;\nself.macroPass = macroPass;\nself.mapValues = mapValues;\nself.getUniforms = getUniforms;\nself.getDrawIndexes = getDrawIndexes;\nself.indexForms = indexForms;\n\nconst canvas = document.querySelector('canvas');\n\n// Scroll to the top.\nconst scroll = () => setTimeout(() => canvas.scrollIntoView(true), 0);\n\nscroll();\n\nfunction toggleError(e) {\n  document.querySelector('.error').classList[(e)? 'remove' : 'add']('hide');\n  canvas.classList[(e)? 'add' : 'remove']('hide');\n  scroll();\n}\n\n// Handle query parameters.\n\nconst getQuery = (search = location.search) => new URLSearchParams(search);\n\nfunction setQuery(entries, query = getQuery()) {\n  each(([k, v = null]) => ((v === null)? query.delete(k) : query.set(k, v)),\n    entries);\n\n  return query;\n}\n\nlet query = getQuery();\nconst fragDepth = query.get('depth') === 'frag';\n\n// Set up GL.\n\nconst extend = {\n  halfFloat: extensionsHalfFloat?.(),\n  float: extensionsFloat?.(),\n  other: optionalExtensions?.(),\n  depth: fragDepth && 'ext_frag_depth'\n};\n\nconst pixelRatio = Math.max(devicePixelRatio, 1.5) || 1.5;\n\nconst regl = self.regl = getRegl({\n  canvas, pixelRatio,\n  extensions: extend.required = extend.halfFloat,\n\n  optionalExtensions: extend.optional = ((fragDepth)?\n      [...extend.float, ...extend.other, extend.depth]\n    : [...extend.float, ...extend.other]),\n\n  onDone: toggleError\n});\n\nconsole.group('Extensions');\n\nconsole.log('required',\n  (extend.required &&\n    reduce((o, e) => o+(o && '; ')+e+': '+regl.hasExtension(e),\n      extend.required, '')));\n\nconsole.log('optional',\n  (extend.optional &&\n    reduce((o, e) => o+(o && '; ')+e+': '+regl.hasExtension(e),\n      extend.optional, '')));\n\nconsole.groupEnd();\n\n/**\n * How many state values (channels) are tracked independently of others.\n * The order here is the order used in the shaders and generated macros, but for\n * optimal lookups may be `packed` into channels/textures/passes differently.\n */\nconst valuesMap = (new Map())\n  // Position, uses 3 channels.\n  .set('position', 3)\n  // Motion, uses 3 channels.\n  .set('motion', 3)\n  // Life, uses 1 channel.\n  .set('life', 1);\n\nconst values = [];\nconst valuesIndex = {};\n\nvaluesMap.forEach((v, k) => valuesIndex[k] = values.push(v)-1);\nconsole.log(values, '`values`');\n\n/** Limits of this device and these `values`. */\nconst { maxTextureUnits, maxTextureSize, lineWidthDims, pointSizeDims } =\n  regl.limits;\n\n/** Whether to merge states into one texture; separate textures if not given. */\nconst useMerge = query.get('merge');\n\n/**\n * Merge by default for maximum platform compatibility.\n * @todo Should work in one of these cases:\n * ```\n *   const merge = ((useMerge)? (useMerge !== 'false') : (stepsPast > 1));\n *   const merge = ((useMerge)? (useMerge !== 'false') : (form !== 1));\n * ```\n */\nconst merge = !useMerge || (useMerge !== 'false');\n\n/** How many steps are used for output at a given time. */\nconst bound = 1;\n\n/**\n * Better stay farther under maximum texture size, for errors/crashes.\n * @todo Drawing issues with `scale` and `steps` both over 10.\n */\nconst limits = { scale: [0, Math.log2(maxTextureSize)] };\n/** A scale that seems to work well from experimentation with `WebGL` limits. */\nconst niceScale = clamp(8, ...limits.scale);\n\n/** The data entries count scale, from user input or default best-guess. */\nconst scale = clamp((parseFloat(query.get('scale'), 10) || niceScale),\n  ...limits.scale);\n\n/** The steps of state to track. */\nlimits.steps = [\n  1+bound,\n  ((merge)?\n      // Maximum steps must fit the maximum total texture size if merging.\n      Math.floor(maxTextureSize/(2**scale))\n      // Maximum steps must fit the maximum total texture units if separate.\n    : Math.floor((maxTextureUnits-bound)/reduce((s, v) => s+v, values)*4))\n];\n\nconsole.log('limits', limits, regl.limits);\n\n/**\n * 2 active states, as many others as can be bound; at least 2 past states\n * needed for Verlet integration, 1 for Euler integration.\n */\nconst steps = Math.floor(clamp(parseFloat(query.get('steps'), 10) || 2+bound,\n  ...limits.steps));\n\n/** How many past steps (not bound to outputs) are in the GPGPU state. */\nconst stepsPast = steps-bound;\n/** Whether to allow Verlet integration; within available resource limits. */\nconst canVerlet = stepsPast > 1;\n\n/**\n * Form vertexes to draw; if not given, uses trails of 'lines' if there are\n * enough steps, or 'points' if not.\n */\nconst form = Math.floor(parseFloat(query.get('form'), 10) || 0);\n\n/** How wide the form is; to be scaled by `viewScale`. */\nconst wide = parseFloat(query.get('wide'), 10) || 4e-3*pixelRatio;\n\n/**\n * Variable-step (delta-time) if given falsey/`NaN`; fixed-step (add-step)\n * if given another number; uses default fixed-step if not given.\n */\nconst hasTimestep = query.has('timestep');\n\n/** Whether to use a fixed timestep or render variably as soon as possible. */\nconst timestep = ((hasTimestep)? parseFloat(query.get('timestep'), 10) || null\n  : 1e3/60);\n\nconsole.log(location.search+':\\n', ...([...query.entries()].flat()), '\\n',\n  'steps:', steps, 'scale:', scale, 'form:', form, 'wide:', wide,\n  'depth:', fragDepth, 'timestep:', timestep, 'merge:', merge);\n\n// Set up the links.\n\ndocument.querySelector('#verlet').href = `?${\n  setQuery([['steps', 2+bound], ['scale', 9], ['wide'], ['depth']])}#verlet`;\n\ndocument.querySelector('#euler').href = `?${\n  setQuery([['steps', 1+bound], ['scale', 9], ['wide'], ['depth']])}#euler`;\n\ndocument.querySelector('#long').href = `?${\n  setQuery([['steps', 9+bound], ['scale', 8], ['wide'], ['depth']])}#long`;\n\ndocument.querySelector('#trace').href = `?${\n  setQuery([['steps', 3e2], ['scale', 2], ['wide'], ['depth']])}#trace`;\n\ndocument.querySelector('#trails').href =\n  `?${setQuery([['form', ((form)? ((form+1)%3 || null) : 1)]])}#trails`;\n\ndocument.querySelector('#timestep').href =\n  `?${setQuery([['timestep', ((hasTimestep)? null : 0)]])}#timestep`;\n\ndocument.querySelector('#merge').href =\n  `?${setQuery([['merge',\n    ((!useMerge)? false : ((useMerge === 'false')? true : null))]])}#merge`;\n\n/**\n * How state values map to any past state values they derive from.\n * Denoted as an array, nested 1-3 levels deep:\n * 1. In `values` order, indexes `values` to derive from, 1 step past.\n * 2. Indexes `values` to derive from, 1 step past.\n * 3. Shows how many steps past, then indexes `values` to derive from.\n */\nconst derives = [];\n\n// Position value derives from:\nderives[valuesIndex.position] = [\n  // Position, 2 steps past.\n  [wrap(1, stepsPast), valuesIndex.position],\n  // Position, 1 step past.\n  valuesIndex.position,\n  // Motion, 1 step past.\n  valuesIndex.motion,\n  // Life, 1 step past.\n  valuesIndex.life\n];\n\n// Motion value derives from:\nderives[valuesIndex.motion] = [\n  // Motion, 1 step past.\n  valuesIndex.motion,\n  // Life, 1 step past.\n  valuesIndex.life,\n  // Position, 1 step past.\n  valuesIndex.position\n];\n\n// Life value derives from:\nderives[valuesIndex.life] = [\n  // Life, last step past.\n  [wrap(-1, stepsPast), valuesIndex.life],\n  // Life, 1 step past.\n  valuesIndex.life\n];\n\nconsole.log(derives, '`derives`');\n\n/** The main `gl-gpgpu` state. */\nconst state = gpgpu(regl, {\n  // Logic given as state values, `gl-gpgpu` maps optimal inputs and outputs.\n  maps: {\n    // How many state values (channels) are tracked independently of others.\n    values,\n    // How state values map to any past state values they derive from.\n    derives\n  },\n  // How many steps of state to track.\n  steps,\n  // How many states are bound to frame-buffer outputs at any step.\n  bound,\n  // How many entries to track, here encoded as the power-of-2 size per side\n  // of the data texture: `(2**scale)**2`; can also be given in other ways.\n  scale,\n  // Whether to merge states into one texture; separate textures if not given.\n  merge,\n  // Data type according to platform capabilities.\n  // @todo Seems to move differently with `'half float'` Verlet integration.\n  type: ((extend.float.every(regl.hasExtension))? 'float' : 'half float'),\n  // Configure macro hooks, global or per-shader.\n  macros: {\n    // No macros needed for the `vert` shader; all other macros generated.\n    macroVert: false\n  },\n  // Prefix is usually recommended; use none here to check for naming clashes.\n  pre: '',\n  // Properties for each step of state, and each pass of each step.\n  step: {\n    // A fragment shader to compute each state step, with `gl-gpgpu` macros.\n    // Vertex shaders can also be given.\n    frag: stepFrag,\n    // Macros are prepended to `frag` shader per-pass, cached in `frags`.\n    frags: [],\n    // Custom uniforms in addition to those `gl-gpgpu` provides.\n    uniforms: {\n      dt: (_, { props: { timer: t, rate: r } }) => t.dt*r,\n      dt0: (_, { props: { timer: t, rate: r } }) => t.dts[0]*r,\n      dt1: (_, { props: { timer: t, rate: r } }) => t.dts[1]*r,\n      time: (_, { props: { timer: t, rate: r } }) => t.time*r,\n\n      loop: (_, { props: { timer: t, loop: l } }) =>\n        Math.sin(t.time/l*Math.PI)*l,\n\n      lifetime: regl.prop('props.lifetime'),\n      useVerlet: regl.prop('props.useVerlet'),\n      epsilon: regl.prop('props.epsilon'),\n      moveCap: regl.prop('props.moveCap'),\n      source: regl.prop('props.source'),\n      sink: regl.prop('props.sink'),\n      g: regl.prop('props.g'),\n      scale: regl.prop('props.scale'),\n\n      // One option in these arrays is used, by Euler/Verlet respectively.\n      spout: (_, { props: { spout: ss, useVerlet: u } }) => ss[+u],\n      // drag: (_, { props: { drag: ds, useVerlet: u } }) => ds[+u]\n    }\n  },\n  // Custom properties to be passed to shaders mixed in with `gl-gpgpu` ones.\n  props: {\n    // Set up the timer.\n    timer: timer((timestep)?\n        // Fixed-step (add-step).\n        { step: timestep, dts: range(2, 0) }\n        // Real-time (variable delta-time).\n      : { step: '-', now: () => regl.now()*1e3, dts: range(2, 0) }),\n\n    // Speed up or slow down the passage of time.\n    rate: 1,\n    // Loop time over this period to avoid instability of parts of the demo.\n    loop: 3e3,\n    // A particle's lifetime range, and whether it's allowed to spawn.\n    lifetime: [3e2, 4e3, +true],\n    // Whether to use Verlet (midpoint) or Euler (forward) integration.\n    useVerlet: +canVerlet,\n    // A small number greater than 0; avoids speeds exploding.\n    epsilon: 1e-5,\n    // How faar a particle can move in any frame.\n    moveCap: 4e-2,\n    // Whether to invert particle flow towards rather than away from source.\n    invert: false,\n    // The position around which particles spawn.\n    source: [0, 0, 0.4],\n    // Sink position, and universal gravitational constant.\n    sink: [\n      // Sink position.\n      0, 0, 0.6,\n      // Universal gravitational constant (scaled).\n      6.674e-11*5e10\n    ],\n    // Constant acceleration of gravity; and whether to use it or the `sink`.\n    g: [\n      // Constant acceleration of gravity.\n      0, -9.80665, 0,\n      // Whether to use it or the `sink`.\n      +false\n    ],\n    // For numeric accuracy, encoded as exponent `[b, p] => b*(10**p)`.\n    scale: [1, -7],\n\n    // One option in these arrays is used, by Euler/Verlet respectively.\n\n    // The distance from the `source`, and speed, that particles spawn with.\n    spout: [[0, 3e3], [0, 2e2]],\n    // Drag coefficient.\n    // drag: [range(3, 1e-3), range(3, 1e-1)]\n  }\n});\n\nconsole.log(self.state = state);\n\nconsole.group('How `values` are `packed` to fit texture channels efficiently');\nconsole.log(state.maps.values, '`values` (referred to by index)');\nconsole.log(state.maps.packed, '`packed` (indexes `values`)');\nconsole.log(...state.maps.textures, '`textures` (indexes `values`)');\nconsole.log(state.maps.valueToTexture, '`valueToTexture` (indexes `textures`)');\nconsole.groupEnd();\n\n// Set up rendering.\n\n/**\n * Draw all states with none bound as outputs.\n * @todo Errors without `merge`; why, if the framebuffer isn't bound?\n */\nconst drawBound = +(!merge);\n\nconst drawSteps = steps-drawBound;\nconst useLines = merge && (drawSteps > 1);\n\nconsole.log('drawSteps', drawSteps, 'useLines', useLines);\n\n/**\n * Vertex counts by form; how many steps a form covers, for all entries;\n * respectively for: none, points, lines.\n * Note `state.size.count` will equal the value returned by `countDrawIndexes`.\n */\nconst drawCounts = map((_, f) => indexForms(drawSteps, f, state.size.count),\n  range(2+useLines), 0);\n\nconst viewScale = ({ drawingBufferWidth: w, drawingBufferHeight: h }) =>\n  Math.min(w, h);\n\n/** Reuse the `gpgpu` state, mix in drawing-specific state. */\nconst drawState = {\n  ...state,\n  bound: drawBound,\n  // Drawing, not data - so no `output` macros. Also, don't need `frag` macros.\n  macros: { output: 0, frag: 0 },\n  drawProps: {\n    // How many vertexes per form.\n    form: clamp(form || 2, 1, 1+useLines),\n    // Vertex counts by form; how many steps a form covers, for all entries.\n    count: null,\n    counts: drawCounts,\n    // Which primitives can be drawn.\n    primitive: null,\n    primitives: [, 'points', 'lines'],\n    // How wide the form is; to be scaled by `viewScale`.\n    wide,\n\n    // One option in these arrays is used, by Euler/Verlet respectively.\n\n    // Speed-to-colour scaling, as `[multiply, power]`.\n    pace: [[1e-3, 0.6], [3e2, 0.6]]\n  },\n  // Map everything similarly to the GPGPU step, `mapValues` can be reused to\n  // create new mappings with some additions for drawing.\n  maps: mapValues({\n    ...state.maps,\n    // This one pass can bind textures for input; not output across passes.\n    texturesMax: maxTextureUnits,\n\n    /**\n     * One set of lookups/reads of all values in one pass.\n     * Passing `true` adds all values at that level of nesting:\n     * `pass|[values|[value|[step, value]]]`\n     * Thus, this example means that the _first_ value derives from:\n     * - All values 1 step past (`true`).\n     * - The position value 2 steps past.\n     * Makes `reads_0_i` macros for each `i => [step, value]` of\n     * `[[0, 0], [0, 1], [0, 2], [1, 0]]`\n     */\n    derives: [[true, [wrap(1, drawSteps), valuesIndex.position]]]\n  })\n};\n\n/** The `WebGL` render command pipeline state. */\nconst drawCommand = {\n  // Use GPGPU macro mappings by prepending macros from a single pass.\n  vert: macroPass(drawState)+drawVert,\n  frag: drawFrag,\n  // Maximum count here to set up buffers, can be partly used later.\n  attributes: { index: getDrawIndexes(Math.max(...drawCounts)) },\n  // Hook up GPGPU uniforms by adding them here.\n  uniforms: getUniforms(drawState, {\n    ...drawState.step.uniforms,\n    scale: regl.prop('props.scale'),\n    // How many vertexes per form.\n    form: regl.prop('drawProps.form'),\n    pace: (_, { drawProps: dp, props: p }) => dp.pace[+p.useVerlet],\n    pointSize: (c, p) => clamp(p.drawProps.wide*viewScale(c), ...pointSizeDims)\n  }),\n  lineWidth: (c, p) => clamp(p.drawProps.wide*viewScale(c), ...lineWidthDims),\n  // Vertex counts by form; how many steps a form covers, for all entries.\n  count: (_, { drawProps: { count: c, counts: cs, form: f } }) => c ?? cs[f],\n  depth: { enable: true },\n  blend: { enable: true, func: { src: 'one', dst: 'one minus src alpha' } },\n\n  primitive: (_, { drawProps: { primitive: p, primitives: ps, form: f } }) =>\n    p ?? ps[f]\n};\n\nconsole.log((self.drawState = drawState), (self.drawCommand = drawCommand));\n\n/** Function to execute the render command pipeline state every frame. */\nconst draw = regl(drawCommand);\n\nfunction stepTime(state) {\n  const { dts } = state;\n\n  dts[0] = dts[1];\n  dts[1] = timer(state).dt;\n\n  return state;\n}\n\nconst clearView = { color: [0, 0, 0, 0], depth: 1 };\n\nregl.frame(() => {\n  try {\n    stepTime(state.props.timer);\n    // Compute the next step of state.\n    state.step.run();\n    drawState.stepNow = (state.stepNow+1)-drawBound;\n    regl.clear(clearView);\n    draw(drawState);\n  }\n  catch(e) { toggleError(e); }\n});\n\nfunction stopEvent(e) {\n  e.stopPropagation();\n  e.preventDefault();\n}\n\n/** Pause the spawning while pointer is held down. */\nlet hold;\n\n/** Pause particles spawning. */\ncanvas.addEventListener('contextmenu', (e) => {\n  // Whether a particle's allowed to spawn.\n  state.props.lifetime[2] = +false;\n  hold = false;\n  stopEvent(e);\n});\n\n/** Toggle physics and graphics modes. */\ncanvas.addEventListener((('onpointerup' in self)? 'pointerup'\n    : (('ontouchend' in self)? 'touchend' : 'mouseup')),\n  (e) => {\n    /** Unpause the spawning when pointer is released. */\n    const spawned = state.props.lifetime[2];\n    const held = hold;\n\n    // Whether a particle's allowed to spawn.\n    state.props.lifetime[2] = +true;\n    hold = false;\n\n    // Don't switch modes if pointer was being held down, particles weren't\n    // allowed to spawn, or any non-primary button was released.\n    if(held || !spawned || (e.button !== 0)) { return; }\n\n    // Switch between physics/drawing modes if this wasn't press-held.\n\n    const { props: p, drawProps: d } = drawState;\n    const v = canVerlet && (p.useVerlet = 1-p.useVerlet);\n    const f = form || (d.form = 1+(useLines && ((canVerlet)? v : d.form%2)));\n\n    console.log('useVerlet', v, 'form', f,\n      // See how this derives other properties.\n      'count', drawCommand.count(0, drawState),\n      'primitive', drawCommand.primitive(0, drawState));\n  });\n\n/** Move either the source or the sink, according to primary pointer. */\ncanvas.addEventListener((('onpointermove' in self)? 'pointermove'\n    : (('ontouchmove' in self)? 'touchmove' : 'mousemove')),\n  (e) => {\n    const { clientX: x, clientY: y, type, pointerType, isPrimary = true } = e;\n    const { left, top, width: w, height: h } = canvas.getBoundingClientRect();\n    const { source: i, sink: o, invert } = state.props;\n    const touch = ((type === 'touchmove') || (pointerType === 'touch'));\n    /** Move source or sink, switch by primary/other pointer/s or inversion. */\n    const to = ((isPrimary)? ((invert)? o : i) : ((invert)? i : o));\n    const size = Math.min(w, h);\n\n    to[0] = (((x-((w-size)*0.5)-left)/size)*2)-1;\n    to[1] = -((((y-((h-size)*0.5)-top)/size)*2)-1);\n    // For touch devices, don't pause spawn if touch moves while held down.\n    touch && (hold = true);\n  });\n\n/** Switch primary pointer control between source and sink. */\ncanvas.addEventListener('dblclick', (e) => {\n  state.props.invert = !state.props.invert;\n  stopEvent(e);\n});\n\n/** Resize the canvas. */\nfunction resize() {\n  canvas.width = innerWidth*pixelRatio;\n  canvas.height = innerHeight*pixelRatio;\n}\n\naddEventListener('resize', resize);\nresize();\n","/**\n * The update step for a GPGPU particle simulation.\n * Requires setup with preprocessor macros - see `macroPass`.\n * Executed in one or more passes; each chunk depending on a `gpgpu` macro may\n * be combined with others into one pass or separated into its own pass; `gpgpu`\n * preprocessor macros control the combination according to which `values` are\n * currently bound for `output` to the next `state`.\n *\n * @see {@link step.getStep}\n * @see {@link macros.macroPass}\n */\n\n#ifdef GL_EXT_draw_buffers\n  #extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\n\n// Setting up the macros and aliases `gl-gpgpu` provides.\n\n// Note that these `texture_i`/`channels_i`/`reads_i_j` indexes correspond to a\n// value at that index in the `values`/`derives` arrays provided to `gl-gpgpu`;\n// they are defined here to match that arrangement.\n\n// The texture channels each of the `values` is stored in.\n#define positionChannels channels_0\n#define motionChannels channels_1\n#define lifeChannels channels_2\n\n/** Set up sampling logic via `gl-gpgpu` macro. */\nuseSamples\n\n// Set up minimal texture reads logic; only read what a value with a currently\n// bound output `derives` from other `values` for its next state.\n// See `derives` for indexing `reads_${bound value index}_${derives index}`.\n#ifdef output_0\n  #define positionOutput output_0\n  useReads_0\n  #define positionReadPosition0 reads_0_0\n  #define positionReadPosition1 reads_0_1\n  #define positionReadMotion reads_0_2\n  #define positionReadLife reads_0_3\n#endif\n#ifdef output_1\n  #define motionOutput output_1\n  useReads_1\n  #define motionReadMotion reads_1_0\n  #define motionReadLife reads_1_1\n  #define motionReadPosition reads_1_2\n#endif\n#ifdef output_2\n  #define lifeOutput output_2\n  useReads_2\n  #define lifeReadLifeLast reads_2_0\n  #define lifeReadLife1 reads_2_1\n#endif\n\n// The main shader.\n\n// States from `gl-gpgpu`; in separate textures or merged.\n#ifdef mergedStates\n  uniform sampler2D states;\n#else\n  uniform sampler2D states[stepsPast*textures];\n#endif\n\n/** The current step from `gl-gpgpu`. */\nuniform float stepNow;\n\n// Custom inputs for this demo.\n\nuniform float dt0;\nuniform float dt1;\nuniform float loop;\n/** A particle's lifetime range, and whether it's allowed to respawn. */\nuniform vec3 lifetime;\nuniform float useVerlet;\nuniform float epsilon;\nuniform float moveCap;\nuniform vec2 scale;\nuniform vec2 spout;\nuniform vec3 source;\n/** Sink position, and universal gravitational constant. */\nuniform vec4 sink;\n/** Constant acceleration of gravity; and whether to use it or the `sink`. */\nuniform vec4 g;\n// uniform vec3 drag;\n\nvarying vec2 uv;\n\n#pragma glslify: map = require(glsl-map)\n#pragma glslify: le = require(glsl-conditionals/when_le)\n#pragma glslify: random = require(glsl-random)\n\n#ifdef positionOutput\n  /** @todo Try Velocity Verlet integration. */\n  #pragma glslify: verlet = require(@epok.tech/glsl-verlet/p-p-a)\n#endif\n\n#if defined(positionOutput) || defined(motionOutput)\n  #pragma glslify: tau = require(glsl-constants/TWO_PI)\n\n  /** @see [Spherical distribution](https://observablehq.com/@rreusser/equally-distributing-points-on-a-sphere) */\n  vec3 randomOnSphere(float randomAngle, float randomDepth) {\n    float a = randomAngle*tau;\n    float u = (randomDepth*2.0)-1.0;\n\n    return vec3(sqrt(1.0-(u*u))*vec2(cos(a), sin(a)), u);\n  }\n#endif\n\n/**\n * Drag acceleration, constrained within the given velocity.\n * @see [Wikipedia on Verlet](https://en.wikipedia.org/wiki/Verlet_integration#Algorithmic_representation)\n */\n// vec3 dragAcc(vec3 velocity, vec3 drag) {\n//   vec3 l = abs(velocity);\n\n//   return clamp(-0.5*sign(velocity)*dot(velocity, velocity)*drag, -l, l);\n// }\n\nvoid main() {\n  // Sample the desired state values - creates the `data` array.\n  tapState(uv)\n\n  // Read values.\n\n  #ifdef positionOutput\n    vec3 position0 = data[positionReadPosition0].positionChannels;\n  #endif\n\n  // If reads all map to the same value sample, any of them will do.\n  #if defined(positionOutput) || defined(motionOutput)\n    #if defined(positionOutput)\n      #define readMotion positionReadMotion\n      #define readPosition positionReadPosition1\n    #elif defined(motionOutput)\n      #define readMotion motionReadMotion\n      #define readPosition motionReadPosition\n    #endif\n\n    vec3 position1 = data[readPosition].positionChannels;\n    vec3 motion = data[readMotion].motionChannels;\n  #endif\n\n  // If reads all map to the same value sample, any of them will do.\n  #if defined(positionOutput)\n    #define readLife positionReadLife\n  #elif defined(lifeOutput)\n    #define readLife lifeReadLife\n  #elif defined(motionOutput)\n    #define readLife motionReadLife\n  #endif\n\n  float life = data[readLife].lifeChannels;\n\n  #ifdef lifeOutput\n    float lifeLast = data[lifeReadLifeLast].lifeChannels;\n  #endif\n\n  // Update and output values.\n  // Note that the update/output logic components within each `#if` macro\n  // block from `gpgpu` are independent modules, as the `gpgpu` macros\n  // determine whether they're executed across one or more passes - they could\n  // also be coded in separate files called from here, however they're coded\n  // inline here for brevity, relevance, and easy access to shared variables.\n\n  /** Whether the particle is ready to respawn. */\n  float spawn = le(life, 0.0);\n\n  #if defined(positionOutput) || defined(motionOutput)\n    // Workaround for switching Euler/Verlet; interpret `motion` data as\n    // acceleration/velocity, respectively.\n    vec3 velocity = motion;\n    vec3 acceleration = motion;\n\n    /** Spawn randomly on a sphere around the source, move in that direction. */\n    vec3 spoutSpawn = random(loop-(uv*dt0))*\n      randomOnSphere(random((uv+loop)/dt1), random((uv-loop)*dt0));\n  #endif\n\n  #ifdef positionOutput\n    /** For numeric accuracy, encoded as exponent `[b, p] => b*(10**p)`. */\n    float size = scale.s*pow(10.0, scale.t);\n\n    /**\n     * Constrain Verlet movement; handle here for better numerical accuracy.\n     * Any position changes below the movement cap remain the same; any\n     * bigger clamped towards current position, by the ratio over the limit.\n     */\n    vec3 back = mix(position0, position1,\n      clamp((distance(position1, position0)/moveCap)-1.0, 0.0, 1.0));\n\n    // Use either Euler integration...\n    vec3 positionTo = mix(position1+(velocity*dt1*size),\n      // ... or Verlet integration...\n      verlet(back, position1, acceleration*size, dt0, dt1),\n      // ... according to which is currently active.\n      useVerlet);\n\n    /** Spawn around the source. */\n    vec3 positionSpawn = source+(spout.x*spoutSpawn);\n\n    /** Output the next position value to its channels in the state texture. */\n    positionOutput = mix(positionTo, positionSpawn, spawn);\n  #endif\n  #ifdef motionOutput\n    /**\n     * Gravitate towards the sink point (simplified).\n     * @see [Wikipedia on gravitation](https://en.wikipedia.org/wiki/Newton%27s_law_of_universal_gravitation)\n     */\n    vec3 gravity = sink.xyz-position1;\n\n    gravity *= sink.w/max(dot(gravity, gravity), epsilon);\n\n    /** Use sink point, or constant acceleration due to gravity. */\n    acceleration = mix(gravity, g.xyz, g.w);\n\n    /** Can also combine other forces, e.g: drag. */\n    // acceleration += dragAcc(mix(velocity, acceleration*dt1, useVerlet), drag);\n\n    vec3 motionTo = mix(velocity+(acceleration*dt1), acceleration, useVerlet);\n    vec3 motionNew = spout.y*spoutSpawn;\n\n    /** Output the next motion value to its channels in the state texture. */\n    motionOutput = mix(motionTo, motionNew, spawn);\n  #endif\n  #ifdef lifeOutput\n    float lifeTo = max(life-dt1, 0.0);\n    float lifeNew = map(random(uv*loop), 0.0, 1.0, lifetime.s, lifetime.t);\n    /** Whether the oldest of this trail has faded. */\n    float faded = le(lifeLast, 0.0);\n\n    /**\n     * Output the next life value to its channels in the state texture.\n     * Only spawn life once the oldest step reaches the end of its lifetime\n     * (past and current life are both 0), and if it's allowed to respawn.\n     */\n    lifeOutput = mix(lifeTo, lifeNew, spawn*faded*lifetime.z);\n  #endif\n}\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see {@link macros.macroPass}\n * @see {@link macros.macroValues}\n */\n\nprecision highp float;\n\n// The texture channels each of the `values` is stored in.\n#define positionChannels channels_0\n#define motionChannels channels_1\n#define lifeChannels channels_2\n// Set up sampling logic.\nuseSamples\n// Only the first value derives from all values, giving these minimal `reads`.\nuseReads_0\n// All `derives` here are in one pass (`0`), and in the same order as `values`.\n// See `values` for indexing `reads_0_${derives index == values index}`.\n#define readPosition1 reads_0_0\n#define readMotion reads_0_1\n#define readLife reads_0_2\n#define readPosition0 reads_0_3\n\nattribute float index;\n\n// States from `gl-gpgpu`; in separate textures or merged.\n#ifdef mergedStates\n  uniform sampler2D states;\n#else\n  uniform sampler2D states[stepsPast*textures];\n#endif\n\n// Must be defined when using the default `tapStates` or `tapStatesBy`.\nuniform float stepNow;\n\nuniform vec4 stateShape;\nuniform vec2 viewShape;\nuniform float pointSize;\nuniform float dt;\nuniform vec3 lifetime;\nuniform vec2 pace;\nuniform float useVerlet;\nuniform float form;\n\nvarying vec4 color;\nvarying vec3 center;\nvarying float radius;\n\n#pragma glslify: aspect = require(@epok.tech/glsl-aspect/contain)\n#pragma glslify: gt = require(glsl-conditionals/when_gt)\n\n#pragma glslify: indexUV = require(../../src/lookup/index-uv)\n#pragma glslify: offsetUV = require(../../src/lookup/offset-uv)\n\n#if stepsPast > 1\n  // If multiple steps are given, shift into past steps.\n  // Lookups mostly equivalent; input and result iteration order differ.\n  #define indexFormsStates\n  #ifdef indexFormsStates\n    #pragma glslify: indexStates = require(../../src/index-forms/index-states)\n  #else\n    #pragma glslify: indexEntries = require(../../src/index-forms/index-entries)\n  #endif\n#endif\n\nconst vec4 noPosition = vec4(0, 0, -1, 0);\n\nvoid main() {\n  #if stepsPast > 1\n    // If multiple steps are given, find past step and entry.\n    // Lookups mostly equivalent; input and result iteration order differ.\n    #ifdef indexFormsStates\n      vec2 stepEntry = indexStates(index, stepsPast, form);\n    #else\n      vec2 stepEntry = indexEntries(index, count, form);\n    #endif\n\n    float stepPast = stepEntry.s;\n    float entry = stepEntry.t;\n  #else\n    // If only 1 step is given, past step and entry are known.\n    float stepPast = 0.0;\n    float entry = index;\n  #endif\n\n  // Turn 1D index into 2D texture UV; offset to texel center, avoids errors.\n  vec2 st = offsetUV(indexUV(entry, stateShape.xy), stateShape.xy);\n\n  // Can also use the `reads` logic to take the minimum possible samples here.\n  // Sample the desired state values; creates the `data` array.\n  #if stepsPast > 1\n    // Shift into past steps.\n    tapStateBy(st, stepPast, 0)\n  #else\n    // No past steps, no shift.\n    tapState(st)\n  #endif\n\n  // Read values.\n  vec3 position0 = (data[readPosition0].positionChannels);\n  vec3 position1 = (data[readPosition1].positionChannels);\n  vec3 motion = (data[readMotion].motionChannels);\n  float life = (data[readLife].lifeChannels);\n\n  #if stepsPast > 1\n    float ratioNow = 1.0-(stepPast/float(stepsPast-1));\n  #else\n    float ratioNow = 1.0;\n  #endif\n\n  float alive = gt(life, 0.0);\n  vec2 ar = aspect(viewShape);\n  vec4 vertex = mix(noPosition, vec4(position1.xy*ar, position1.z, 1), alive);\n  float depth = clamp(1.0-(vertex.z/vertex.w), 0.1, 1.0);\n  float a = clamp(pow(life/lifetime.t, 0.3)*pow(ratioNow, 0.3), 0.0, 1.0);\n  float size = pointSize*depth*a;\n\n  gl_Position = vertex;\n  gl_PointSize = size;\n\n  radius = size*0.5;\n\n  /**\n   * Convert vertex position to `gl_FragCoord` window-space.\n   * @see [SO](https://stackoverflow.com/a/7158573)\n   * @todo Might need the viewport `x` and `y` offset as well as `w` and `h`?\n   */\n  center = vec3(viewShape*((1.0+vertex.xy)/vertex.w)*0.5, vertex.z);\n\n  float speed = length(mix(motion, position1-position0, useVerlet)/dt);\n\n  color = a*vec4(mix(0.2, 1.0, ratioNow), mix(0.2, 1.0, entry/float(count)),\n    clamp(pow(speed*pace.s, pace.t), 0.0, 1.0), a);\n}\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see {@link macros.macroPass}\n * @see {@link macros.macroValues}\n */\n\n#ifdef GL_EXT_frag_depth\n  #extension GL_EXT_frag_depth : enable\n#endif\n\nprecision highp float;\n\nvarying vec4 color;\nvarying vec3 center;\nvarying float radius;\n\nvoid main() {\n  // Fade out to transparent when the fragment is beyond the radius.\n  vec2 vc = center.xy-gl_FragCoord.xy;\n  float vcl2 = dot(vc, vc);\n  float r2 = radius*radius;\n\n  if(vcl2 > r2) { discard; }\n\n  float d2 = vcl2/r2;\n\n  gl_FragColor = vec4(color.rgb, mix(color.a, 0.0, d2));\n\n  #ifdef GL_EXT_frag_depth\n    gl_FragDepthEXT = center.z+d2;\n  #endif\n}\n"],"names":["$fd65c668c84a029d$exports","value","min","max","$60359228a7d3fb28$export$be3f796aed065412","diff","dt","pause","add","$60359228a7d3fb28$export$7548f4bc1b09ff22","$60359228a7d3fb28$export$85b884786400d38f","$60359228a7d3fb28$export$eb8a9b7a1ebec59a","Date","now","$60359228a7d3fb28$export$2e2bcd8739ae039","state","out","time","t0","step","n","_step","s","ref","ref1","t","t1","isNaN","$ee5851911330bf41$var$r","Array","prototype","reduce","$ee5851911330bf41$export$533b26079ad0b4b","f","a","to","undefined","call","$ee5851911330bf41$export$2e2bcd8739ae039","$6d8e5906de1cf303$export$2e2bcd8739ae039","v","i","$6f535731e26073af$var$e","forEach","$6f535731e26073af$export$2e2bcd8739ae039","fill","$5ebc876929a0439f$var$fill","isFinite","$5ebc876929a0439f$var$isFinite","Number","floor","$5ebc876929a0439f$var$floor","Math","$5ebc876929a0439f$export$2e2bcd8739ae039","l","start","end","$4ad49746d3e88695$export$2e2bcd8739ae039","$0764a650e9f35d5a$export$2e2bcd8739ae039","length","$b587055a99d7210b$export$ba60520149d1328e","$b587055a99d7210b$export$878041e1e4cd4218","flat","$699ea889147b78f1$export$dc207adda608f979","$parcel$interopDefault","$699ea889147b78f1$export$ac0cd3cc21f80dfc","$699ea889147b78f1$export$5d97924d29f48e83","$699ea889147b78f1$export$4bceda1224fc5ab8","$699ea889147b78f1$export$b4781c2237bde956","$699ea889147b78f1$export$26945b8c914b7fc","$699ea889147b78f1$export$154f256b9eac9103","$699ea889147b78f1$export$b6267c3f91c57c78","$699ea889147b78f1$export$b029aceb5666f022","$699ea889147b78f1$export$617a37502ff8853","$699ea889147b78f1$export$ff01eb58fe4e69","$699ea889147b78f1$export$cfdc3a7c4cb854c6","$699ea889147b78f1$export$27fb0dad99ae5dd2","$699ea889147b78f1$export$47b10f415de592b1","$699ea889147b78f1$export$1fb689c67b965bff","$699ea889147b78f1$export$8d7f4a48e1f2b2a","$699ea889147b78f1$export$a211ab2c8ecded9a","$699ea889147b78f1$export$a1b7c201e9365814","$699ea889147b78f1$export$d5373eb478d25864","$699ea889147b78f1$export$497faa7f0daf9da","$65ce5154e50f483f$var$_cache","$65ce5154e50f483f$var$_step","$65ce5154e50f483f$var$_reads","$65ce5154e50f483f$var$_pass","$65ce5154e50f483f$var$_ref","$65ce5154e50f483f$var$_value","isInteger","$65ce5154e50f483f$var$isInteger","$65ce5154e50f483f$export$69a3209f1a06c04d","packed","$65ce5154e50f483f$export$5ca26c99531348ec","channelsMax","console","error","$65ce5154e50f483f$export$9d1d9285bd6d8c57","values","_","channels","fitIndex","fitSize","Infinity","fit","pack","$65ce5154e50f483f$export$574963e692b662ec","maps","derives","passes","textures","valueToTexture","reads","cache","all","getAddSample","pass","set","derive","d","texture","findIndex","push","samples","p","valueDerives","getAddSamples","$65ce5154e50f483f$export$825e789796ab7275","buffersMax","valueToPass","textureToPass","getValue","getIndex","index","$65ce5154e50f483f$export$96707a1f51900f3d","$cf3851181e517041$var$isFinite","$cf3851181e517041$var$isInteger","$cf3851181e517041$export$3c49c185de0c2bfc","width","w","x","shape","size","side","v0","ref2","ref3","ref4","ref5","$cf3851181e517041$export$c08559766941f856","height","h","y","v1","$cf3851181e517041$var$ref","$cf3851181e517041$var$ref1","$cf3851181e517041$var$ref2","$cf3851181e517041$export$87ed20f81f3c66ff","count","$cf3851181e517041$export$a495db45d4904b10","$cf3851181e517041$export$f99427edb65f5558","scale","$b0900dfbab0ef3c9$var$_textures","$b0900dfbab0ef3c9$var$_step","$b0900dfbab0ef3c9$var$_passes","$b0900dfbab0ef3c9$var$_step1","$b0900dfbab0ef3c9$var$isInteger","$b0900dfbab0ef3c9$export$50fdfeece43146fd","framebuffer","steps","stepNow","passNow","merge","type","mag","wrap","depth","stencil","scaled","channelsMin","texturesMap","passChannels","sum","mergeChannels","_length","framebuffers","colors","colorPool","addTexture","c","color","entry","map","addPass","mScaled","mw","ref6","ref7","mh","_all","_next","next","$7b02a589e8d7c18a$var$start","$7b02a589e8d7c18a$var$end","split","$7b02a589e8d7c18a$export$bf9fb029d174d554","toString","slice","$8b3b066d03fa4cc4$var$_cache","$8b3b066d03fa4cc4$var$_ref","$8b3b066d03fa4cc4$export$cbfbec548517f2b6","$8b3b066d03fa4cc4$export$4e46ac54fc82cf3b","$8b3b066d03fa4cc4$var$id","JSON","stringify","$8b3b066d03fa4cc4$export$11949c6f5fba7dcd","$8b3b066d03fa4cc4$export$feaf5ffc92c2af94","props","key","on","macros","Object","$8b3b066d03fa4cc4$var$ref","$8b3b066d03fa4cc4$export$83d01c7b88bc16d5","name","qualify","init","join","$8b3b066d03fa4cc4$export$45db4de6da38aa8d","$8b3b066d03fa4cc4$export$3df19e70a88cb8cd","$8b3b066d03fa4cc4$export$1c7039c93eddfba","$8b3b066d03fa4cc4$export$c346962e7dd3191","glsl","trim","$8b3b066d03fa4cc4$var$ref1","$8b3b066d03fa4cc4$export$d38b14fb9031108e","hook","bound","pre","passesL","stepsL","$8b3b066d03fa4cc4$export$84186522bf5a7d4d","$8b3b066d03fa4cc4$export$49873e279ff642c0","passSamples","passReads","$8b3b066d03fa4cc4$export$9cb6037fa2a40c2e","glsl3","tap","by","aka","akaBy","st","tapsSamples","$8b3b066d03fa4cc4$export$562ddd36066ad650","$b32a66f4c5b7b75f$export$abee0037e1db715","z","$d276511382b6b0bc$var$_uniforms","$d276511382b6b0bc$export$4e06fab977536f8e","uniforms","texturesL","stateShape","viewShape","m","drawingBufferWidth","drawingBufferHeight","addTextures","ago","b","ts","pl","$1a374edfd27fba4d$var$_verts","$1a374edfd27fba4d$var$_p","$1a374edfd27fba4d$var$_frags","$1a374edfd27fba4d$var$_p1","$1a374edfd27fba4d$var$_merge","$1a374edfd27fba4d$var$scale","vec2","$1a374edfd27fba4d$export$69a3209f1a06c04d","clearPass","copyFrame","copyImage","copy","$1a374edfd27fba4d$export$d86e3abd7686c23f","ps","$1a374edfd27fba4d$export$12661000d11a17d2","sl","cf","ci","use","subimage","$1a374edfd27fba4d$var$_step","$1a374edfd27fba4d$export$89e7bec3b8bce705","api","buffer","clear","command","positions","_count","passCommand","vert","verts","frag","frags","_positions","vs","fs","attributes","enable","_update","update","run","mergeUpdate","onPass","onStep","stepProps","passProps","$48449d871f87e3df$var$_to","$48449d871f87e3df$var$_to1","$48449d871f87e3df$export$2e2bcd8739ae039","_limits","maxDrawbuffers","limits","parseFloat","match","_maps","$7be1562a8ac0a4e2$export$2e2bcd8739ae039","states","form","entries","self","gpgpu","macroPass","mapValues","getUniforms","getDrawIndexes","indexForms","$9a6b765804fb9ec0$var$canvas","document","querySelector","$9a6b765804fb9ec0$var$scroll","setTimeout","scrollIntoView","$9a6b765804fb9ec0$var$toggleError","e","classList","$9a6b765804fb9ec0$var$getQuery","search","location","URLSearchParams","$9a6b765804fb9ec0$var$setQuery","query","k","delete","$9a6b765804fb9ec0$var$query","$9a6b765804fb9ec0$var$fragDepth","get","$9a6b765804fb9ec0$var$extend","halfFloat","float","other","$9a6b765804fb9ec0$var$pixelRatio","devicePixelRatio","$9a6b765804fb9ec0$var$regl","regl","$2a263769c476450e$exports","extensions","required","optionalExtensions","optional","onDone","group","log","o","hasExtension","groupEnd","$9a6b765804fb9ec0$var$valuesMap","Map","$9a6b765804fb9ec0$var$values","$9a6b765804fb9ec0$var$valuesIndex","maxTextureUnits","$9a6b765804fb9ec0$var$maxTextureUnits","maxTextureSize","$9a6b765804fb9ec0$var$maxTextureSize","lineWidthDims","$9a6b765804fb9ec0$var$lineWidthDims","pointSizeDims","$9a6b765804fb9ec0$var$pointSizeDims","$9a6b765804fb9ec0$var$useMerge","$9a6b765804fb9ec0$var$merge","$9a6b765804fb9ec0$var$limits","log2","$9a6b765804fb9ec0$var$niceScale","$9a6b765804fb9ec0$var$scale","$9a6b765804fb9ec0$var$steps","$9a6b765804fb9ec0$var$stepsPast","$9a6b765804fb9ec0$var$canVerlet","$9a6b765804fb9ec0$var$form","$9a6b765804fb9ec0$var$wide","$9a6b765804fb9ec0$var$hasTimestep","has","$9a6b765804fb9ec0$var$timestep","href","$9a6b765804fb9ec0$var$derives","position","motion","life","$9a6b765804fb9ec0$var$state","every","macroVert","timer","rate","r","dt0","dts","dt1","loop","sin","PI","lifetime","prop","useVerlet","epsilon","moveCap","source","sink","g","spout","ss","u","invert","$9a6b765804fb9ec0$var$drawBound","$9a6b765804fb9ec0$var$drawSteps","$9a6b765804fb9ec0$var$useLines","$9a6b765804fb9ec0$var$drawCounts","$9a6b765804fb9ec0$var$viewScale","$9a6b765804fb9ec0$var$drawState","output","drawProps","counts","primitive","primitives","pace","texturesMax","$9a6b765804fb9ec0$var$drawCommand","dp","pointSize","wide","lineWidth","cs","blend","func","src","dst","drawState","drawCommand","$9a6b765804fb9ec0$var$draw","$9a6b765804fb9ec0$var$clearView","$9a6b765804fb9ec0$var$stopEvent","stopPropagation","preventDefault","$9a6b765804fb9ec0$var$hold","$9a6b765804fb9ec0$var$resize","innerWidth","innerHeight","frame","$9a6b765804fb9ec0$var$stepTime","addEventListener","spawned","held","button","clientX","clientY","pointerType","isPrimary","left","top","getBoundingClientRect","touch"],"version":3,"file":"index.02680b41.js.map"}