{"mappings":"kqBAyKAA,EAoMAC,EAsEwCC,EA6HxCC,EAAWC,mRAxhBXC,KAAKC,MAAQC,EAAAD,MACbD,KAAKG,UAAYC,EAAAD,UACjBH,KAAKK,QAAUC,EAAAD,QACfL,KAAKO,YAAcC,EAAAD,YACnBP,KAAKS,eAAiBC,EAAAD,eACtBT,KAAKW,WAAaC,EAAAC,QAElB,IAAMC,EAASC,SAASC,cAAc,UAGhCC,EAAS,WAAM,OAAAC,YAAW,WAAM,OAAAJ,EAAOK,gBAAe,KAAO,aAI1DC,EAAYC,GACjBN,SAASC,cAAc,UAAUM,UAAWD,EAAI,SAAW,OAAO,QAClEP,EAAOQ,UAAWD,EAAI,MAAQ,UAAU,QACxCJ,IALJA,IAUA,IAAMM,EAAW,SAAQC,OAAPC,OAAM,IAAAD,EAAGE,SAASD,OAAMD,EAAK,OAAA,IAAIG,gBAAgBF,aAE1DG,EAASC,EAASC,OAAAC,OAAkB,IAAlBD,EAAQP,IAARO,EAIvB,OAHAE,EAAAnB,SAAK,SAAQW,wBAANS,EAACC,EAAA,GAAEC,EAAQD,EAAA,GAARE,OAAQ,IAARD,EAAI,KAAJA,EAAe,OAAO,OAANC,EAAaL,EAAMM,OAAOJ,GAAKF,EAAMO,IAAIL,EAAGG,KAClEP,GAEGE,EAGX,IAAIQ,EAAQhB,IACNiB,EAAoC,SAAvBD,EAAME,IAAI,SAIvBC,EAAS,CACXC,UAA8B,OAAnBC,EAAAC,0BAAA,IAAAD,EAAAC,yBAAA,EAAAD,EAAAC,sBACXC,MAAsB,OAAfF,EAAAG,sBAAA,IAAAH,EAAAG,qBAAA,EAAAH,EAAAG,kBACPC,MAAyB,OAAlBJ,EAAAK,yBAAA,IAAAL,EAAAK,wBAAA,EAAAL,EAAAK,qBACPC,MAAQV,GAAa,kBAGnBW,EAAcC,KAAKC,IAAIC,iBAAkB,MAAQ,IAEjDC,EAAOvD,KAAKuD,KAAOC,EAAAC,EAAA,CAAQ,CAC7B3C,OAAAA,EAAQqC,WAAAA,EACRO,WAAYhB,EAAOiB,SAAWjB,EAAOC,UAErCM,mBAAoBP,EAAOkB,SAAapB,EAASqB,EAAAhD,QACrC6B,EAAOI,OAAKgB,OAAAD,EAAAhD,QAAK6B,EAAOM,OAA5B,CAAmCN,EAAOQ,QAAMW,EAAAhD,QAC5C6B,EAAOI,OAAKgB,OAAAD,EAAAhD,QAAK6B,EAAOM,QAEpCe,OAAQ,SAAC1C,GAAM,OAAAD,EAAYC,MAG/B2C,QAAQC,MAAM,cAEdD,QAAQE,IAAI,WAAaxB,EAAOiB,UAC5BQ,EAAAtD,SAAO,SAACuD,EAAG/C,GAAM,OAAA+C,GAAGA,GAAK,MAAM/C,EAAE,KAAKkC,EAAKc,aAAahD,KACpDqB,EAAOiB,SAAU,KAEzBK,QAAQE,IAAI,WAAaxB,EAAOkB,UAC5BO,EAAAtD,SAAO,SAACuD,EAAG/C,GAAM,OAAA+C,GAAGA,GAAK,MAAM/C,EAAE,KAAKkC,EAAKc,aAAahD,KACpDqB,EAAOkB,SAAU,KAEzBI,QAAQM,WAGR,IAMMC,GAAa,IAAIC,KAElBlC,IAAI,WAAY,GAEhBA,IAAI,SAAU,GAEdA,IAAI,OAAQ,GAEXmC,EAAS,GACTC,EAAc,GAEpBH,EAAUI,SAAQ,SAACvC,EAAGH,GAAM,OAAAyC,EAAYzC,GAAKwC,EAAOG,KAAKxC,GAAG,KAE5D4B,QAAQE,IAAIO,EAAQ,YAGpB,IACII,EAAAtB,EAAKuB,OADDC,EACJF,EADIE,gBAAiBC,EACrBH,EADqBG,eAAgBC,EACrCJ,EADqCI,cAAeC,EACpDL,EADoDK,cAIlDC,EAAW5C,EAAME,IAAI,SAErB2C,GAAUD,GAA0B,UAAbA,EAMvBL,EAAS,CAAEO,MAAO,CAAC,EAAGjC,KAAKkC,KAAKN,KAEhCO,EAAY/B,EAAAgC,GAAAC,WAAA,EAAA,CAAM,GAAN3B,OAAyBD,EAAAhD,QAAbiE,EAAOO,SAE/BA,EAAQ7B,EAAAgC,GAAAC,WAAA,EAAA,CAAOC,WAAWnD,EAAME,IAAI,SAAU,KAAO8C,GAA7CzB,OACMD,EAAAhD,QAAbiE,EAAOO,SAEdP,EAAOa,MAAQ,CACX,EACEP,EAGE5B,EAAAgC,EAAA,CAAMpC,KAAKwC,MAAMZ,EAAeK,GAAQ,EAAG,KAE3CjC,KAAKwC,OAAOb,EAhDN,GAgD6BZ,EAAAtD,SAAO,SAACgF,EAAGzD,GAAM,OAAAyD,EAAEzD,IAAGqC,GAAQ,IAGzET,QAAQE,IAAI,SAAUY,EAAQvB,EAAKuB,QAInC,IAAMa,EAAQnC,EAAAgC,GAAAC,WAAA,EAAA,CAAOK,SAASvD,EAAME,IAAI,SAAU,KAAO,GAA3CqB,OACMD,EAAAhD,QAAbiE,EAAOa,SAGRI,GAAYJ,EA3DJ,EA6DRK,GAAaD,GAAY,EAIzBE,GAAQH,SAASvD,EAAME,IAAI,QAAS,KAAO,EAE3CyD,GAAQR,WAAWnD,EAAME,IAAI,QAAS,KAAO,KAAKU,EAIlDgD,GAAc5D,EAAM6D,IAAI,YAExBC,GAAaF,GAAeT,WAAWnD,EAAME,IAAI,YAAa,KAAO,KACnE,IAAI,IAEZ9C,EAAAqE,SAAQE,IAARuB,MAAA9F,EAAA,CAAY+B,SAASD,OAAO,OAA5BqC,OAEgED,EAAAhD,QAAAgD,EAAAhD,QAFrB0B,EAAMV,WAAWyE,QAA5D,CAAqE,KACjE,SAAUX,EAAO,SAAUN,EAAO,QAASY,GAAM,QAASC,GAC1D,SAAU1D,EAAW,YAAa6D,GAAU,SAAUjB,KAI1DrE,SAASC,cAAc,WAAWuF,KAC7B,IAAyDzC,OAAtDlC,EAAS,CAAC,CAAC,SAAU,CAAC,SAAU,CAAC,QAAS,CAAC,WAAW,WAE9Db,SAASC,cAAc,UAAUuF,KAAQ,IAGlCzC,OAHqClC,EAAS,CAC7C,CAAC,QAAS,GAAU,CAAC,QAASwB,KAAKoD,IAAIjB,EAAU,EAAGT,EAAOO,MAAM,KACjE,CAAC,QAAS,CAAC,WACZ,UAEPtE,SAASC,cAAc,SAASuF,KAAQ,IAGjCzC,OAHoClC,EAAS,CAC5C,CAAC,QAASwB,KAAKoD,IAAI,GAAI1B,EAAOa,MAAM,KACpC,CAAC,QAASvC,KAAKC,IAAIkC,EAAU,EAAGT,EAAOO,MAAM,KAAM,CAAC,QAAS,CAAC,WAC/D,SAEPtE,SAASC,cAAc,UAAUuF,KAAQ,IAGlCzC,OAHqClC,EAAS,CAC7C,CAAC,QAASkD,EAAOa,MAAM,IAAK,CAAC,QAASnC,EAAAgC,GAAAC,WAAA,EAAA,CAAM,GAAN3B,OAAyBD,EAAAhD,QAAbiE,EAAOO,UACzD,CAAC,QAAS,CAAC,WACZ,UAEPtE,SAASC,cAAc,SAASuF,KAAQ,IAGjCzC,OAHoClC,EAAS,CAC5C,CAAC,QAASwB,KAAKC,IAAIyB,EAAOa,MAAM,GAAIb,EAAOa,MAAM,GAAG,IACpD,CAAC,QAASvC,KAAKC,IAAIkC,EAAWT,EAAOO,MAAM,GAAG,IAAK,CAAC,QAAS,CAAC,WAC/D,SAEPtE,SAASC,cAAc,WAAWuF,KAC7B,IAA4DzC,OAAzDlC,EAAS,CAAC,CAAC,OAAUqE,IAASA,GAAK,GAAG,GAAK,KAAQ,KAAM,WAEjElF,SAASC,cAAc,aAAauF,KAC/B,IAAuDzC,OAApDlC,EAAS,CAAC,CAAC,WAAcuE,GAAc,KAAO,KAAM,aAE5DpF,SAASC,cAAc,UAAUuF,KAC5B,IACmEzC,OADhElC,EAAS,CAAC,CAAC,SACRuD,GAAiC,UAAbA,GAA+B,QAAU,UAQxE,IAAMsB,GAAU,GAGhBA,GAAQ/B,EAAYgC,UAAY,CAE5B,CAACC,EAAA9F,QAAK,EAAGkF,IAAYrB,EAAYgC,UAEjChC,EAAYgC,SAEZhC,EAAYkC,OAEZlC,EAAYmC,MAIhBJ,GAAQ/B,EAAYkC,QAAU,CAE1BlC,EAAYkC,OAEZlC,EAAYmC,KAEZnC,EAAYgC,UAIhBD,GAAQ/B,EAAYmC,MAAQ,CAExB,CAACF,EAAA9F,SAAK,EAAIkF,IAAYrB,EAAYmC,MAElCnC,EAAYmC,MAGhB7C,QAAQE,IAAIuC,GAAS,aAGrB,IAAMK,GAAQ5G,EAAAD,MAAMsD,EAAM,CAEtBwD,KAAM,CAEFtC,OAAAA,EAEAgC,QAAAA,IAGJd,MAAAA,EAEAqB,MAvKU,EA0KV3B,MAAAA,EAEAD,MAAAA,EAGA6B,KAAQvE,EAAOI,MAAMoE,MAAM3D,EAAKc,cAAgB,QAAU,aAE1D8C,OAAQ,CAEJC,MAAM,GAGVC,IAAK,GAELC,KAAM,CAGFC,KAAM/D,EAAAgE,GAENC,MAAO,GAEPC,SAAU,CACNC,GAAI,SAACC,EAACpG,WAAIqG,MAAwC,OAApBC,EAAXC,MAASJ,GAAaG,EAAPE,MAClCC,IAAK,SAACL,EAACpG,WAAIqG,MAAoD,OAA/CC,EAAIC,MAASG,IAAO,GAAkBJ,EAAPE,MAC/CG,IAAK,SAACP,EAACpG,WAAIqG,MAAoD,OAA/CC,EAAIC,MAASG,IAAO,GAAkBJ,EAAPE,MAC/CI,KAAM,SAACR,EAACpG,WAAIqG,MAA6C,OAAxCC,EAAIC,MAASK,KAAkBN,EAAPE,MAEzCK,KAAM,SAACT,EAACpG,WAAIqG,MAAwBS,EAAnBR,EAAIC,MAASK,KAAiBG,EAACT,EAAPO,KACrC,OAAAjF,KAAKoF,IAAIF,EAAEC,EAAEnF,KAAKqF,IAAIF,GAE1BG,SAAUnF,EAAKoF,KAAK,kBACpBC,UAAWrF,EAAKoF,KAAK,mBACrBE,QAAStF,EAAKoF,KAAK,iBACnBG,QAASvF,EAAKoF,KAAK,iBACnBI,OAAQxF,EAAKoF,KAAK,gBAClBK,KAAMzF,EAAKoF,KAAK,cAChBM,EAAG1F,EAAKoF,KAAK,WACbtD,MAAO9B,EAAKoF,KAAK,eAGjBO,MAAO,SAACtB,EAACpG,WAAIqG,MAAyC,OAAvBC,EAAToB,OAAuBpB,EAAZc,cAMzCf,MAAO,CAEHE,MAAOoB,EAAAtI,QAAOwF,GAEN,CAAEiB,KAAMjB,GAAU6B,IAAKkB,EAAAvI,QAAM,EAAG,IAEhC,CAAEyG,KAAM,IAAK+B,IAAK,WAAM,OAAW,IAAX9F,EAAK8F,OAAWnB,IAAKkB,EAAAvI,QAAM,EAAG,KAG9DmH,KAAM,EAENK,KAAM,IAENK,SAAU,CAAC,IAAK,IAAK,GAErBE,WAAY5C,GAEZ6C,QAAS,KAETC,QAAS,MAETQ,QAAQ,EAERP,OAAQ,CAAC,EAAG,EAAG,IAEfC,KAAM,CAEF,EAAG,EAAG,GAEN,oBAIJC,EAAG,CAEC,GAAG,QAAU,EAEb,GAGJ5D,MAAO,CAAC,GAAG,GAKX6D,MAAO,CAAC,CAAC,EAAG,KAAM,CAAC,EAAG,SAM9BlF,QAAQE,IAAIlE,KAAKuJ,MAAQzC,IAEzB9C,QAAQC,MAAM,iEACdD,QAAQE,IAAI4C,GAAMC,KAAKtC,OAAQ,mCAC/BT,QAAQE,IAAI4C,GAAMC,KAAKyC,OAAQ,gCAC/B5J,EAAAoE,SAAQE,IAARuB,MAAA7F,EAAOiE,EAAAhD,QAAQiG,GAAMC,KAAK0C,UAAQ3F,OAAlC,CAAoC,mCACpCE,QAAQE,IAAI4C,GAAMC,KAAK2C,eAAgB,yCACvC1F,QAAQM,WAMR,IAAMqF,KAAevE,EACfwE,GAAYjE,EAAMgE,GAClBE,GAAYzE,GAAUwE,GAAY,EAExC5F,QAAQE,IAAI,YAAa0F,GAAW,WAAYC,IAKhD,IAAMC,GAAaC,EAAAlJ,SAAI,SAAC+G,EAAGoC,GAAM,OAAApJ,EAAAC,QAAW+I,GAAWI,EAAGlD,GAAMmD,KAAKC,SACjEd,EAAAvI,QAAM,EAAEgJ,IAAW,GAEjBM,GAAY,SAAQ3I,OAAe4I,EAAC5I,EAArB6I,mBAA4CC,EAAC9I,EAAtB+I,oBACxC,OAAAnH,KAAKoD,IAAI4D,EAAGE,IAGVE,GAASC,EAAA5J,QAAA,GACRiG,GAAK,CACRE,MAAO2C,GAEPxC,OAAQ,CAAEuD,OAAU,EAAGnD,KAAQ,GAC/BoD,UAAW,CAEP1E,KAAMzC,EAAAgC,EAAA,CAAOS,IAAQ,EAAI,EAAG,EAAE4D,IAE9BK,MAAO,KACPU,OAAQd,GAERe,UAAW,KACXC,WAAY,EAAG,SAAU,SAEzB5E,KAAAA,GAKA6E,KAAM,CAAC,CAAC,KAAM,IAAM,CAAC,IAAK,MAI9BhE,KAAMzG,EAAAD,QAAOoK,EAAA5J,QAAA,GACNiG,GAAMC,KAAI,CAEbiE,YAAajG,EAWb0B,QAAS,CAAC,EAAC,EAAM,CAACE,EAAA9F,QAAK,EAAG+I,IAAYlF,EAAYgC,iBAIpDuE,GAAc,CAEhB7D,KAAMhH,EAAAD,UAAUqK,IAAWhH,EAAA0H,GAAU3D,KAAM/D,EAAA2H,GAE3CC,WAAY,CAAEC,MAAO3K,EAAAD,gBAAeZ,EAAAuD,MAAKC,IAALoC,MAAA5F,EAAIgE,EAAAhD,QAAQiJ,OAEhDpC,SAAUlH,EAAAD,YAAYiK,GAASC,EAAA5J,QAAA,GACxB2J,GAAUlD,KAAKI,SAAQ,CAC1BrC,MAAO9B,EAAKoF,KAAK,eAEjB1C,KAAM1C,EAAKoF,KAAK,kBAChBoC,KAAM,SAACnD,EAACpG,GAA0D,SAAtDmJ,UAAaI,MAAIvJ,EAAOqG,MAASe,YAE7C0C,UAAW,SAACC,EAAC/J,OAAuB4I,IAAnBO,UAAazE,KAC1B,OAAA1C,EAAAgC,GAAAC,WAAA,EAAA,CAAM2E,EAAED,GAAUoB,IAAlBzH,OAAuCD,EAAAhD,QAAdqE,SAEjCsG,UAAW,SAACD,EAAC/J,OAAuB4I,IAAnBO,UAAazE,KAC1B,OAAA1C,EAAAgC,GAAAC,WAAA,EAAA,CAAM2E,EAAED,GAAUoB,IAAlBzH,OAAuCD,EAAAhD,QAAdoE,MAG7BiF,MAAO,SAACtC,EAACpG,WAAImJ,UAAoBY,EAACE,EAARvB,MAAkBwB,EAAED,EAAVb,OAAkBZ,EAACyB,EAAPxF,KAAgB,OAAAsF,MAAAA,EAAAA,EAAKG,EAAG1B,IACxE9G,MAAO,CAAEyI,QAAQ,GACjBC,MAAO,CAAED,QAAQ,EAAME,KAAM,CAAEC,IAAK,MAAOC,IAAK,wBAEhDlB,UAAW,SAACjD,EAACpG,WAAImJ,UAAwBqB,EAACP,EAAZZ,UAA0BoB,EAAER,EAAdX,WAAsBd,EAACyB,EAAPxF,KACxD,OAAA+F,MAAAA,EAAAA,EAAKC,EAAGjC,KAGhBhG,QAAQE,IAAKlE,KAAKwK,UAAYA,GAAaxK,KAAKiL,YAAcA,IAE9D,IAAMiB,GAAO3I,EAAK0H,IAWlB,IAoBIkB,GApBEC,GAAY,CAAEC,MAAO,CAAC,EAAG,EAAG,EAAG,GAAInJ,MAAO,YAcvCoJ,GAAUjL,GACfA,EAAEkL,kBACFlL,EAAEmL,0BAgEGC,KACL3L,EAAO4L,MAAQC,WAAWxJ,EAC1BrC,EAAO8L,OAASC,YAAY1J,EAhFhCI,EAAKuJ,OAAM,WACP,IAZcvD,EAaDzC,GAAMe,MAAME,OAZjBG,EAAQqB,EAARrB,KAEJ,GAAKA,EAAI,GACbA,EAAI,GAAKiB,EAAAtI,QAAM0I,GAAO5B,GAWlBb,GAAMQ,KAAKyF,MACXvC,GAAUwC,QAAUlG,GAAMkG,QAAQ,EAAErD,GACpCpG,EAAK0J,MAAMb,IACXF,GAAK1B,IAET,MAAMnJ,GAAKD,EAAYC,OApBTkI,EACNrB,KA+BZpH,EAAOoM,iBAAiB,eAAe,SAAC7L,GAEpCyF,GAAMe,MAAMa,SAAS,GAAK,EAC1ByD,IAAO,EACPG,GAAUjL,MAIdP,EAAOoM,iBAAmB,gBAAiBlN,KAAO,YACtC,eAAgBA,KAAO,WAAa,WAAa,SAACqB,GAE1D,IAAM8L,EAAUrG,GAAMe,MAAMa,SAAS,GAC/B0E,EAAOjB,GAQb,GALArF,GAAMe,MAAMa,SAAS,GAAK,EAC1ByD,IAAO,GAIJiB,GAASD,GAAyB,IAAb9L,EAAEgM,OAA1B,CAIA,IAAerB,EAAoBxB,GAA3B3C,MAAqByF,EAAM9C,GAAjBG,UACZvI,EAAK4D,KAAcgG,EAAEpD,UAAY,EAAEoD,EAAEpD,WACrCoB,EAAK/D,KAASqH,EAAErH,KAAO,GAAG4D,KAAc7D,GAAY5D,EAAIkL,EAAErH,KAAK,KAErEjC,QAAQE,IAAI,YAAa9B,EAAG,OAAQ4H,EAEhC,QAASiB,GAAYf,MAAM,EAAGM,IAC9B,YAAaS,GAAYJ,UAAU,EAAGL,SAI9C1J,EAAOoM,iBAAmB,kBAAmBlN,KAAO,cACxC,gBAAiBA,KAAO,YAAc,aAAe,SAACqB,GAC9D,IAAiBkM,EAAuDlM,EAAhEmM,QAAqBC,EAA2CpM,EAApDqM,QAAYzG,EAAwC5F,EAAxC4F,KAAM0G,EAAkCtM,EAAlCsM,YAAWC,EAAuBvM,EAArBwM,UAAAA,OAAS,IAAAD,GAAOA,EAC5B9F,EAAAhB,GAAMe,MAA7BiG,EAAuBhG,EAA/BiB,OAAiB3E,EAAc0D,EAApBkB,KAASM,EAAWxB,EAAXwB,OACtByE,EAAmB,cAAT9G,GAA0C,UAAhB0G,EAEpCK,EAAOH,EAAcvE,EAASlF,EAAI0J,EAAOxE,EAASwE,EAAI1J,EACtD6F,EAAO7G,KAAKoD,IAAImG,WAAYE,aAElCmB,EAAG,IAAQT,EAAqB,IAAjBZ,WAAW1C,IAAYA,EAAM,EAAG,EAC/C+D,EAAG,MAAUP,EAAsB,IAAlBZ,YAAY5C,IAAYA,EAAM,EAAG,GAEjD8D,IAAU5B,IAAO,MAItBrL,EAAOoM,iBAAiB,YAAY,SAAC7L,GACjCyF,GAAMe,MAAMyB,QAAUxC,GAAMe,MAAMyB,OAClCgD,GAAUjL,MASd6L,iBAAiB,SAAUT,IAC3BA,KAEAwB,MAAAA,GAAW,QAAXnO,EAAAmO,EAAQC,WAAR,IAAApO,GAAmB,QAARC,EAAXD,EAAaqO,cAAb,IAAmBpO,GAA2BA,EAA9CqO,KAAAtO,GAAsB,WAAM,OAAA4B,SAAS2M,4DChjBGC,EAAKC,EAAKC,GAYhD,OAXID,KAAOD,EACTG,OAAOC,eAAeJ,EAAKC,EAAK,CAC9BC,MAAOA,EACPG,YAAY,EACZC,cAAc,EACdC,UAAU,IAGZP,EAAIC,GAAOC,EAGNF,+JCV6BQ,GACpC,IAAK,IAAIhB,EAAI,EAAGA,EAAIiB,UAAUC,OAAQlB,IAAK,CACzC,IAAI/E,EAAyB,MAAhBgG,UAAUjB,GAAaiB,UAAUjB,GAAK,GAC/CmB,EAAUR,OAAOS,KAAKnG,GAEkB,mBAAjC0F,OAAOU,wBAChBF,EAAUA,EAAQnL,OAAO2K,OAAOU,sBAAsBpG,GAAQqG,QAAO,SAAUC,GAC7E,OAAOZ,OAAOa,yBAAyBvG,EAAQsG,GAAKV,gBAIxDM,EAAQtK,SAAQ,SAAU4J,GACxBgB,EAAA1O,QAAeiO,EAAQP,EAAKxF,EAAOwF,OAIvC,OAAOO,4ICd8BU,EAAK1B,GAC1C,OAAO2B,EAAA5O,QAAe2O,IAAQE,EAAA7O,QAAqB2O,EAAK1B,IAAM6B,EAAA9O,2DCLxB2O,GACtC,GAAII,MAAMC,QAAQL,GAAM,OAAOA,gGCDQM,GACvC,GAAIC,OAAOC,YAAYvB,OAAOqB,IAAkD,uBAAzCrB,OAAOwB,UAAUC,SAAS9B,KAAK0B,GAAgC,OAAOF,MAAMO,KAAKL,mGCAxH,MAAM,IAAIM,UAAU,+OCGqBZ,GACzC,OAAOa,EAAAxP,QAAkB2O,IAAQE,EAAA7O,QAAgB2O,IAAQc,EAAAzP,2DCLhB2O,GACzC,GAAII,MAAMC,QAAQL,GAAM,CACtB,IAAK,IAAI1B,EAAI,EAAGyC,EAAO,IAAIX,MAAMJ,EAAIR,QAASlB,EAAI0B,EAAIR,OAAQlB,IAC5DyC,EAAKzC,GAAK0B,EAAI1B,GAGhB,OAAOyC,mGCLT,MAAM,IAAIH,UAAU,4kpHCDtBnC,EAAAuC,iBAEehC,EAAOhI,EAAKnD,GACzB,OAAOmD,EAAMnD,EACRmL,EAAQhI,EAAMA,EAAMgI,EAAQnL,EAAMA,EAAMmL,EACxCA,EAAQnL,EAAMA,EAAMmL,EAAQhI,EAAMA,EAAMgI,sFCDxC,MAAMiC,EAAQ,CACjBC,KAAM,IAAK/I,GAAI,IAAK,IAAG,IACrBgJ,MAAK,EAAG,IAAG,EACXC,IAAG,IAAK,IAAG,KAGJC,EAAUJ,EAAMC,KAChBI,EAAW,EACXC,EAAS,EAAGN,EAAMC,MAAOM,KAAK3H,KAAMoH,EAAMG,KAAM,IAAI,IAyEjE,IAAAK,WAzBsB1H,EAAOF,EAAK6H,EAAM3H,GAEpC,MAAQnB,KAAM+I,EAAKL,EAAQxJ,KAAEA,EAAOuJ,EAASxH,IAAK+H,GAAM7H,EAE7C,IAAA8H,EAAX,MAAMxL,EAAe,QAAVwL,EAAAZ,EAAMnJ,UAAK,IAAX+J,EAAAA,EAAe/J,EACpBoJ,EAAQ7K,IAAM4K,EAAMC,KACf,IAAA5Q,EAAAC,EAAX,MAAMuI,EAAyB,QAApBvI,EAAQ,QAARD,EAAAuJ,MAAAA,EAAAA,EAAO+H,SAAC,IAARtR,EAAAA,EAAYiR,EAAOlL,UAAE,IAArB9F,EAAAA,EAAyB8F,EAM9ByL,EAAQzL,GAAW6K,EAAO,EAAIS,IAAMI,MAAMjJ,GAAKA,IAAMA,GAAzC6I,EACZxJ,EAAK2J,EAAGH,EAGd,OAAID,GAEJA,EAAI9I,KAAOkJ,EACXJ,EAAIvJ,GAAKA,EACTuJ,EAAI5J,KAAOA,EAEJ4J,GANaR,EAAO/I,EAAK2J,mIC5EpC,MAAME,EAAI5B,MAAMK,UAAUwB,OAiBbC,EAAM,CAAI1H,EAAG2H,EAAG3D,SAEhB4D,IAAP5D,EAAmBwD,EAAEpD,KAAKuD,EAAG3H,GAAKwH,EAAEpD,KAAKuD,EAAG3H,EAAGgE,OAErD6D,EAAeH,0GCMfI,EAPgB,CAAI9H,EAAG2H,EAAGI,EAAK,KAAO5N,EAAAsN,QAAM,CAAEzD,EAAI5L,EAAG0L,KAC7CE,EAAGF,GAAK9D,EAAE5H,EAAG0L,EAAG6D,EAAG3D,GAEZA,IAEX2D,EAAII,GAAMJ,sFCzBd,MAAMK,EAAIpC,MAAMK,UAAUtL,YAkB1BsN,EANiB,CAAIjI,EAAG2H,KACpBK,EAAE5D,KAAKuD,EAAG3H,GAEH2H,sFCfX,MAAOO,KAACC,GAASvC,MAAMK,WAChBmC,SAACC,GAAaC,QACd1M,MAAC2M,GAAUnP,SAmBlBoP,EAHkB,CAAIjK,EAAI,EAAGiG,EAAOiE,EAAOC,IACvCP,EAAK/D,KAAOiE,EAAS9J,GAAKqH,MAAM2C,EAAMhK,IAAMA,EAAIiG,EAAOiE,EAAOC,2GCClEC,EAHiB,CAAI7E,EAAGvF,EAAGmK,EAAMnK,EAAEyG,SAC7B0D,GAAgB,IAARA,EAAanK,EAAEqK,EAAA/R,QAAUiN,EAAG4E,IAAQE,EAAA/R,QAAUiN,EAAGvF,0FCD/DsK,EAFsB,CAAI/E,EAAGvF,KAAQuF,EAAEvF,EAAGA,GAAGA,kVC0C1BuK,EAIMC,kDAbTC,EAAMC,EAAKzR,EAAYM,OAKdhC,EAJa+E,MADX0E,OAAU,IAAV/H,EAAQ,GAARA,EAAYwM,OAAU,IAAVlM,EAAKyH,EAALzH,EACD/B,EAAU,QAAV8E,EAAAoO,EAAInO,cAAM,IAAVD,EAAAA,EAAcoO,EAAxCC,EAA0BnT,EAA1BmT,eAAgBC,EAAUpT,EAAVoT,KACnBC,EAAiB7J,EAAdxC,KAAAA,OAAI,IAAAqM,EAAG,GAAEA,EACTC,EAAetM,EAAfsM,WAYR,OAVArF,EAAGmF,KAAOzN,WAAqB,QAAV5F,EAAAqT,EAAKG,MAAK,mBAAV,IAAAxT,OAAA,EAAAA,EAAyB,GAAI,IAGlDiH,EAAKsM,WAAcA,MAAAA,EAAAA,EAAcH,EACjC5S,EAAAD,QAAQ0G,EAAc,QAAVwM,GAAGT,EAAA9E,GAAGjH,YAAI,IAAAwM,EAAAA,EAAPT,EAAG/L,KAAS,IAC3BA,EAAKsM,WAAaA,EAElBG,EAAAC,SAASR,EAAK1J,EAAOyE,GACrB0F,EAAAC,QAAQV,EAAK1J,EAAe,QAAV8H,GAAG0B,EAAA/E,GAAG1G,YAAI,IAAA+J,EAAAA,EAAP0B,EAAGzL,KAAS,IAE1B0G,0JC6TH4F,EAyBEC,EAAAC,eA7XFC,EAAczB,OAAd0B,UAGKC,EAAkB,GAalBC,EAAa,SAAC1F,EAAKhN,OAAE2S,OAAW,IAAA3S,EAAGoB,EAAAwR,eAAc5S,EACzD,OAAC,GAAKgN,GAAWA,GAAS2F,KACrBnQ,QAAQqQ,MAAO,gCAAuCvQ,OAAN0K,EAAM,kBACnD,qCAAiD1K,OAAZqQ,EAAY,iBAClD3F,EAAO2F,aAkLHG,EAAU9S,EAAW+S,OAAXxN,OAAS,IAATvF,EAAO,GAAPA,EAAWuQ,OAAS,IAATwC,EAAKxN,EAALwN,EACjC,IAAIxN,EAAQ,OAAOgL,EAEnB,IAAKyC,EAKGzN,EAJAtC,OAAAA,OAAM,IAAA+P,EAAG5R,EAAA6R,YAASD,EAAAE,EAIlB3N,EAHAoN,YAAAA,OAAW,IAAAO,EAAG9R,EAAAwR,eAAcM,EAAAC,EAG5B5N,EAH8BsM,WAAAA,OAAU,IAAAsB,EAAG/R,EAAAgS,cAAaD,EAAAE,EAGxD9N,EADAyC,OAAAA,OAAM,IAAAqL,WAzJSpQ,EAAQjD,EAA8BM,OAA9BqS,OAA4B,IAA5B3S,EAAcoB,EAAAwR,eAAd5S,EAA8BwM,OAAO,IAAPlM,EAAK,GAALA,EAC7DiI,EAAAlJ,SAAI,SAAC+G,EAAGkG,GAAM,OAAAA,IAAGrJ,EAAQuJ,GAAIgB,OAASvK,EAAOuK,OAU7C,IAPA,IAAI8F,EAAWX,EAEX3K,EAAS,EAETuL,EAAW,EACXC,EAAUC,EAAAA,EAENC,EAAI,EAAG1L,EAAS/E,EAAOuK,QAAS,CACpC,IAAM5M,EAAIoH,EAAO0L,EACX1G,EAAQ/J,EAAOuJ,EAAG5L,IAExB,IAAI8R,EAAW1F,EAAO2F,GAAgB,OAAOnG,EAG7C,IAAMmH,EAAML,EAAStG,EAQrB,GANI2G,GAAO,GAAOA,EAAMH,IACpBA,EAAUG,EACVJ,EAAW3S,GAIC,IAAZ4S,GAAmB5S,EAAIqC,EAAOuK,OAAO,IAAQkG,MAC5C,CAED,IAAME,EAAOpH,EAAG+G,GAEhB/G,EAAG+G,GAAY/G,EAAGxE,GAClBwE,EAAGxE,GAAU4L,GAGVN,GAAYrQ,EAAO2Q,IAAS,IAAON,EAAWX,GAEjDY,IAAavL,EACbwL,EAAUC,EAAAA,EACVC,EAAI,GAIZ,OAAOlH,EA8GUqH,CAAW5Q,EAAQ0P,EAAaF,GAAYY,EAG7D9C,EAAGtN,OAASA,EACZsN,EAAGsB,WAAaA,EAChBtB,EAAGoC,YAAcA,EACjBpC,EAAGvI,OAASA,EAEZ,IAAM8L,EAASvD,EAAGuD,OAAS,CAAC,IACtB7L,EAAWsI,EAAGtI,SAAW,CAAC,IAC1BC,EAAiBqI,EAAGrI,eAAiB,GACrC6L,EAAcxD,EAAGwD,YAAc,GAC/BC,EAAgBzD,EAAGyD,cAAgB,GAErCV,EAAW,EAETW,EAAajM,EAAU,SAAC5B,EAAGkG,GAAM,OAAArJ,EAAOqJ,IAAO,SAAC1L,GAAM,OAAAA,GACtDsT,EAAalM,EAAU,SAACsE,GAAM,OAAAtE,EAAOsE,IAAO,SAACA,GAAM,OAAAA,GAEzD,OAAO3J,EAAAtD,SAAO,SAACmN,EAAI5L,EAAG0L,GACd,IAAMzC,EAAQqK,EAAS5H,GACjBU,EAAQiH,EAASrT,EAAGiJ,GAE1B,IAAI6I,EAAW1F,EAAO2F,GAAgB,OAAOnG,EAE7C,IAAIhC,EAAIsJ,EAAOtG,OAAO,EAClB2G,EAAOL,EAAOtJ,GACd1D,EAAImB,EAASuF,OAAO,EACpB4G,EAAUnM,EAASnB,GAqBvB,OAnBIwM,GAAYtG,GAAS2F,GACrBW,EAAWtG,EACXlG,EAAImB,EAAS7E,KAAKgR,EAAU,IAAI,EAE9BD,EAAK3G,QAAUqE,IACZrH,EAAIsJ,EAAO1Q,KAAK+Q,EAAO,IAAI,GAEhCA,EAAK/Q,KAAK0D,GACVkN,EAAc5Q,KAAKoH,IAEC,IAAhB2J,EAAK3G,SACT2G,EAAK/Q,KAAK0D,GACVkN,EAAc5Q,KAAKoH,IAGvB4J,EAAQhR,KAAKyG,GACb3B,EAAe2B,GAAS/C,EACxBiN,EAAYlK,GAASW,EAEdgC,IAEXvJ,EAAQsN,YAwFA8D,EAAW9O,EAAM+O,OAAAC,OAAS,IAATD,EAAK/O,EAAL+O,EACvBrP,EAAUM,MAAAA,OAAA,EAAAA,EAAMN,QAEtB,IAAIA,EAAW,OAAOsP,EAEtB,MAAQT,EAAqCvO,EAArCuO,OAAQ7L,EAA6B1C,EAA7B0C,SAAUC,EAAmB3C,EAAnB2C,eACpBsM,EAAQD,EAAGC,MAAQ,GACnBC,EAAQ,GAEdF,EAAGtP,QAAUA,EAEb,IAAMyP,EAAM,SAAQ1U,OAAP8F,OAAI,IAAA9F,EAAG,EAACA,EACjB,OAAU,QAAJ6P,GAANuC,EAAAqC,GAAM3O,UAAI,IAAA+J,EAAAA,EAAVuC,EAAMtM,GAAUyC,EAAAlJ,SAAI,SAACyH,EAAGlG,GAAM,MAAA,CAACkF,EAAMlF,KAAIsH,IAEvCyM,EAAe,SAACR,EAAMnH,GAAU,OAAA,SAASoC,EAAItO,EAAK8T,EAAQ9I,GAC5D,IACIsI,EADAtO,EAAO,EAGX,IAAc,IAAX8O,EAAmB,OAAOjS,EAAAtD,QAAO+P,EAAKsF,EAAI5O,GAAOhF,GAC/C,GAAGyR,EAAUqC,GAAWR,EAAUlM,EAAe0M,OACjD,CAAA,IAAiB,IAAdA,EAAO,GAAe,OAAOjS,EAAAtD,QAAO+P,EAAKsF,EAAIE,EAAO,IAAK9T,GAE7DgF,EAAO8O,EAAO,GACdR,EAAUlM,EAAe0M,EAAO,IAGpC,IAAKrC,EAAUzM,KAASyM,EAAU6B,GAC9B,OAAO5R,QAAQqQ,MAAM,uCACjB5N,EAASM,EAAM4O,EAAMnH,EAAO4H,EAAQ9I,EAAGhG,EAAMsO,GAIrD,QAAM5H,EAAM1L,GAAO,GAEbwL,EAAIE,EAAGqI,WAAU,SAAQ7U,wBAANqE,EAAC3D,EAAA,GAAEoG,EAACpG,EAAA,GAAM,OAAC2D,IAAMyB,GAAUgB,IAAMsN,KAO1D,OAJ2B,WAAzB9B,EAAU,QAAQwC,GAAlBzC,EAAAmC,GAAML,UAAI,IAAAW,EAAAA,EAAVzC,EAAM8B,GAAU,IAAInH,UAAK,IAAA+H,EAAAA,EAAzBzC,EAAoBtF,GAAW,IAE5B5J,KAAMkJ,EAAI,EAAIE,EAAGpJ,KAAK,CAAC0C,EAAMsO,IAAU,EAAI9H,GAEzCE,IAiBX,OALA+H,EAAGS,QAAUzM,EAAAlJ,SAAI,SAAC8U,EAAM3J,GAAM,OAAA7H,EAAAtD,SAAO,SAACyB,EAAKsT,GAC/B,OAAAzR,EAAAtD,QAVU,SAAC8U,GAAS,OAAA,SAACrT,EAAKkM,GAClC,IAAMiI,GAA6B,IAAZhQ,EAAmBA,EAAUA,EAAQ+H,GAE5D,OAAUiI,GAAkC,IAAjBA,GACD,IAAjBA,GAA0B1C,EAAU0C,GACjCN,EAAaR,EAAMnH,EAAnB2H,CAA0B7T,EAAKmU,GAC/BtS,EAAAtD,QAAOsV,EAAaR,EAAMnH,GAAQiI,EAAcnU,GAHXA,GAOlCoU,CAAc1K,GAAIvC,EAASmM,GAAUtT,KAChDqT,EAAM,QACVL,EAAQ,IAELS,EAoBJ,IAAMY,EAAU,SAAC5P,EAAIvF,GACxB,OAAAqU,EAAW9O,EAAMuN,EAAUvN,OADC,IAAAvF,EAAGuF,EAAIvF,2lCC7a1BoV,cAAkB,WAC3B,MAAA,CAAC,oBAAqB,8BAGbC,EAAsB,WAC/B,MAAA,CAAC,yBAA0B,gCAGlBC,EAAqB,WAAM,MAAA,CAAC,uBAG5BC,EAAS,SAQTC,EAAiB,EAOjBC,EAAiB,EAGjBC,EAAgB,EAMhBC,EAAW,EAYXC,EAAWhU,KAAAiU,IAAA,EANA,GAYXC,EAAYlU,KAAAiU,IAAA,EAZD,GAeXE,EAAW,EAGXC,EAAY,WAAM,MAAA,CAACP,IAEnBQ,EAAe,WAAO,OAAM5T,EAAAhD,QAAH6W,EAAAC,YAKzBC,EAAU,QAEVC,EAAS,UAETC,EAAS,UAETC,EAAU,QAEVC,GAAW,EAEXC,GAAa,EAMbC,GAAW,uFC7FjB,MAAMC,EAAW,CAAC,EAAC,GAAI,GAAK,EAAC,EAAI,GAAI,CAAC,GAAG,IAcnCC,GAZQD,EAASnJ,OAYLmJ,EAAS7R,6CCpBlC2H,EAAAuC,QAAe,kcC2aG6H,EA6CAC,EAsBbxE,mEAzdGyE,EAAcjG,OAAd0B,mBAuTQwE,EAAShX,EAA0BM,EAAYyS,OASlCkE,EAAA1Y,EACC2Y,EAAAC,EAVH/C,EAAFpU,EAAEoU,QAASgD,EAAXpX,EAAWoX,YAAerP,OAAU,IAAVzH,EAAQ,GAARA,EAAYiQ,OAAU,IAAVwC,EAAKhL,EAALgL,EACtDsE,EAKGtP,EAJA5D,MAAAA,OAAK,IAAAkT,EAAGjW,EAAAkW,SAAQD,EAAE7L,EAIlBzD,EAJkByD,QAAS+L,EAI3BxP,EAJ2BwP,QAAShS,EAIpCwC,EAJoCxC,KAAIiS,EAIxCzP,EAJ0CnE,MAAAA,OAAK,IAAA4T,EAAGpW,EAAAqW,SAAQD,EAAE3T,EAI5DkE,EAJ4DlE,MAAK6T,EAIjE3P,EAFAtC,KAAAA,OAAI,IAAAiS,EAAGtW,EAAAuW,QAAOD,EAAAE,EAEd7P,EAFgB/C,IAAA6S,OAAG,IAAAD,EAAGxW,EAAA0W,OAAMF,EAAAG,EAE5BhQ,EAF8BiQ,IAAAA,OAAG,IAAAD,EAAG3W,EAAA6W,OAAMF,EAAAG,EAE1CnQ,EAF4CoQ,KAAAA,OAAI,IAAAD,EAAG9W,EAAAgX,QAAOF,EAAAG,EAE1DtQ,EADArG,MAAAA,OAAK,IAAA2W,EAAGjX,EAAAkX,SAAQD,EAAAE,EAChBxQ,EADkByQ,QAAAA,OAAO,IAAAD,EAAGnX,EAAAqX,WAAUF,EAGxCG,EAASxZ,EAAAyZ,UAAU9U,GACnBqH,EAAQtJ,KAAKwC,MAA+B,QAAzB7F,EAAc,QAAd0Y,EAAA/X,EAAA0Z,SAAS7Q,UAAM,IAAfkP,EAAAA,EAAmByB,SAAM,IAAzBna,EAAAA,EAA6B6C,EAAAyX,UAChDzN,EAASxJ,KAAKwC,MAAgC,QAA1B+S,EAAe,QAAfD,EAAAhY,EAAA4Z,UAAU/Q,UAAM,IAAhBmP,EAAAA,EAAoBwB,SAAM,IAA1BvB,EAAAA,EAA8B/V,EAAA2X,WAExDxI,EAAGhL,KAAOA,EACVgL,EAAG/E,QAAUA,EACb+E,EAAGgH,QAAUA,EAEb,IAAKvE,EAGGzN,EAFAtC,OAAAA,OAAM,IAAA+P,EAAG5R,EAAA6R,YAASD,EAAAgG,EAElBzT,EADA0T,YAAAA,OAAW,IAAAD,EAAG5X,EAAA8X,eAAcF,EAAYG,EACxC5T,EAD8B0C,SAGtC1C,EAAK0T,YAAcA,EACnB1T,EAAKtC,OAASA,EAId,IAeYmW,EAURC,EAzBEC,EAAe,SAACnF,EAAMoF,GAAQ,OAAA5W,EAAAtD,SAAO,SAAC2F,EAAK8B,GACzC,OAAAlF,KAAKC,IAAImD,EAAKrC,EAAAtD,SAAO,SAACma,EAAK5Y,GAAM,OAAA4Y,EAAIvW,EAAOrC,KAAIuY,EAAYrS,GAAI,MACpEqN,EAAMoF,IAOJE,EAAmB7V,EACjBjB,EAAAtD,SAAO,SAAC2F,EAAKwF,GAAM,OAAA8O,EAAa9O,EAAGxF,KAAMO,EAAKuO,OAAQmF,GAD7B,KAI3BxQ,EAAO8H,EAAG9H,KAAO,CACnBhD,KAAAA,EAAM/D,MAAAA,EAAO8W,QAAAA,EAASS,YAAcQ,MAAAA,EAAAA,EAAiBR,EACrD9U,MAAoB,QAAZiV,EAAAjV,EAAMqJ,cAAM,IAAZ4L,EAAAA,EAAgBjV,EACxB2P,OAAQ,EAAG4F,aAAc,EAAGzR,SAAU,EAAG0R,OAAQ,EACjDzO,MAAAA,EAAOE,OAAAA,EAAQwO,MAAO,CAAC1O,EAAOE,GAAS1C,MAAOwC,EAAME,GAIlDnD,EAAWsI,EAAGtI,SAAW,GAEzB4R,GAAStJ,EAAGuD,OAAS,GAQrBgG,GAAa,SAACxG,EAAU1K,EAAGE,EAAGhD,EAAMqO,UAAS,SAACtK,EAAOE,EAAG3D,EAAGyE,GAE7D,IAAM2B,EAAK,CAAE8G,SAAAA,EAAUpI,MAAOtC,EAAGwC,OAAQtC,EAAGrD,KAAAA,EAAMT,IAAA6S,EAAKG,IAAAA,EAAKG,KAAAA,GAOxD4B,EAAQhQ,EACRjD,EAAI+D,MAAAA,OAAA,EAAAA,EAAQkP,GAGZjT,IACAA,EAAIsN,MAAAA,OAAA,EAAAA,EAAU5H,GACduN,EAAQtR,EAAKR,YAMjB,MAAM+R,EAAQjD,EAAU5C,IAAS,KAejC,OAZA3H,EAAG4H,QAAUtN,EAEb0F,EAAGuN,MAAQA,EAEXvN,EAAG3B,MAASmP,GAAQvR,EAAKkR,SACzBnN,EAAG1G,KAAOA,EACV0G,EAAG2H,KAAOA,EACV3H,EAAG3C,MAAQA,EACX2C,EAAGyN,IAAMd,EAAYtP,GAIVmQ,GAAQjD,EAAUjR,IAASiR,EAAUlN,KAEzB,QAFqCgG,GAElDgH,EAAA5O,GAASnC,UAAI,IAAA+J,EAAAA,EAAbgH,EAAS/Q,GAAU,IAAI+D,GAAS2C,GAAI4H,QAFY5H,IASxD0N,GAAU,SAACpU,EAAM+E,UAAU,SAACsJ,EAAMtK,OAKlBvL,IAAZgV,EAAkC,QAAtBhV,EAAAuM,MAAAA,EAAAA,EAAS4O,SAAa,IAAtBnb,EAAAA,EACZ6V,EAAOmF,EAAanF,EAAM8E,GAAeA,EAKzCzM,EAAK,CACP9K,MAAAA,EAAO8W,QAAAA,EAAStN,MAAAA,EAAOE,OAAAA,EAEvBP,MAAQA,MAAAA,EAAAA,EACJtC,EAAAlJ,QAAIya,GAAWxG,EAAUpI,EAAOE,EAAQtF,EAAM+D,GAAQsK,EAGhDvQ,EAASyV,MAAAA,EAAAA,EAAAA,EAAc,GAAM,KAkB3C,OAdA7M,EAAG4K,YAAcA,MAAAA,OAAA,EAAAA,EAAc5K,GAK/BA,EAAGuN,MAAQtR,EAAKiR,eAEhBlN,EAAG2H,KAAQA,GAAQ1L,EAAKqL,SACxBtH,EAAG1G,KAAOA,EACV0G,EAAG3C,MAAQA,EACX2C,EAAGyN,IAAM9F,EAIEA,GAAQ4C,EAAUjR,IAASiR,EAAUlN,KAE3B,QAFuCgG,GAElDiH,EAAA+C,IAAO/T,UAAI,IAAA+J,EAAAA,EAAXiH,EAAOhR,GAAU,IAAI+D,GAAS2C,GAAI4K,YAFc5K,IAa9D,GAPA+D,EAAGpM,MAAQoE,EAAAlJ,SAAI,SAACyU,EAAQhO,GAEf,OAAAgO,GAAUvL,EAAAlJ,QAAI6a,GAAQpU,GAAOP,EAAKuO,UAErCiD,EAAU5S,GAASyD,EAAAvI,QAAM8E,GAASA,EAAQ,IAG5CP,EAAS,OAAO2M,EAKpB,IAEW4J,GAAAC,GACAC,GAAAC,MAHLC,GAAUrb,EAAAyZ,UAAU/U,EAAMC,OAE1B2W,GAA+B,QAA1BJ,GAAc,QAAdD,GAAAjb,EAAA0Z,SAAShV,UAAM,IAAfuW,GAAAA,GAAmBI,UAAO,IAA1BH,GAAAA,GAA8B7U,EAAK0C,SAASuF,OAAOtC,EACxDuP,GAAgC,QAA3BH,GAAe,QAAfD,GAAAnb,EAAA4Z,UAAUlV,UAAM,IAAhByW,GAAAA,GAAoBE,UAAO,IAA3BD,GAAAA,GAA+B7R,EAAKtE,MAAMiH,EASrD,OAJW,YAFVkH,EAAA/B,EAAG3M,OAAoB,IAAVA,EAAiBkW,GAAWL,EAAee,GAAIC,GAA9BX,GAAsClW,GAEhE8W,cAAM,IAAAC,KAFVrI,EAEIoI,OAAWR,GAAQ,MAAM,EAAdA,IAEhBzR,EAAK7E,MAAQ,CAAEsH,MAAOsP,GAAIpP,OAAQqP,GAAIb,MAAO,CAACY,GAAIC,IAAK/R,MAAO8R,GAAGC,IAE1DlK,gPC3dNjS,EAAAC,EAAA2Y,EAAAC,EAAAgD,EAAAC,EAwBAC,EAAAC,EAAArD,EAAA2D,EAAAC,EAAAC,EAuBAC,4BAhDQC,EAAW,SAAQhb,OAALkL,EAAKlL,EAALkL,MAAOtC,EAAC5I,EAAD4I,EAAGmD,EAAC/L,EAAD+L,EAAG6N,EAAK5Z,EAAL4Z,MAAOnR,EAAIzI,EAAJyI,KAAMwS,EAAIjb,EAAJib,KAAS9K,EAACnQ,EAAJ,GACtD,OAEQ,QAFRoa,EAEG,QAFHD,EACmD,QADnDhD,EACuB,QADvBD,EAAe,QAAf3Y,EAAU,QAAVD,EAAA4M,MAAAA,EAAAA,EAAStC,SAAC,IAAVtK,EAAAA,EAAcyN,SAAC,IAAfxN,EAAAA,EACAqb,GAASoB,EAASpB,UAAO,IADzB1C,EAAAA,EAC8BzO,GAAQuS,EAASvS,UAAM,IADrD0O,EAAAA,EAED8D,SAAI,IAFHd,EAAAA,EAEOhK,SAAC,IAFRiK,EAAAA,EAEY3R,GAqBJyS,EAAY,SAAQlb,OAALoL,EAAMpL,EAANoL,OAAQtC,EAAC9I,EAAD8I,EAAGmD,EAACjM,EAADiM,EAAG2N,EAAK5Z,EAAL4Z,MAAOnR,EAAIzI,EAAJyI,KAAMwS,EAAIjb,EAAJib,KAAS9K,EAACnQ,EAAJ,GACxD,OAEQ,QAFR8a,EAEG,QAFHD,EACqD,QADrDD,EACwB,QADxB3D,EAAgB,QAAhBqD,EAAW,QAAXD,EAAAjP,MAAAA,EAAAA,EAAUtC,SAAC,IAAXuR,EAAAA,EAAepO,SAAC,IAAhBqO,EAAAA,EACAV,GAASsB,EAAUtB,UAAO,IAD1B3C,EAAAA,EAC+BxO,GAAQyS,EAAUzS,UAAM,IADvDmS,EAAAA,EAEDK,SAAI,IAFHJ,EAAAA,EAEO1K,SAAC,IAFR2K,EAAAA,EAEYrS,GAgCJ0S,EAAiB,SAAC1S,GAAS,OAAAF,EAAAlJ,SAAI,SAAC+G,EAAGkG,GAAM,OAAAA,IAClD1E,EAAAvI,QAAMyR,OAAO0B,UAAU/J,GAAOA,EAbF,SAACA,EAAM2C,GAClC,OAAU,QAAV2P,EAAAtS,EAAKC,aAAK,IAAVqS,EAAAA,EAAcC,EAASvS,GAAMyS,EAAU9P,MAAAA,EAAAA,EAAU,GAYbgQ,CAAiB3S,IAAQ,IASrD4S,EAAY,SAACxX,GAAW,OAACiN,OAAOF,SAAS/M,GAASjC,KAAAiU,IAAA,EAAGhS,GAAQ,6FCmG/CyX,EACAC,EAoCZC,EAjE2BC,yHAvJpCC,EAAgB,GAETC,EACE,CAAE9Q,MAAO,CAAC,EAAG,EAAG,EAAG,GAAInJ,MAAO,EAAG8W,QAAS,GAD5CmD,EAEE,CAAE9Q,MAAO,MAFX8Q,EAGE,CAAEC,MAAM,GAeVC,EAAU,SAAQ7b,OAC3B1B,EAD8BmM,EAAEzK,EAAV8T,OAAqBzP,EAACrE,EAAVwL,QAAqBhB,EAACxK,EAAVuX,eACpC,QAAVjZ,EAAA6G,EAAA9F,QAAKgF,EAAGoG,UAAR,IAAAnM,OAAA,EAAAA,EAAckM,aA2BDsR,EAAY/T,GACzB,IAA6BzJ,EAAAud,EAAQ9T,GAA7B8C,EAAqBvM,EAArBuM,MAAYsJ,EAAS7V,EAAd2b,IACVzC,EAAwDzP,EAArDnE,MAAkB4I,EAAEgL,EAAXpD,QAAasG,EAAMlD,EAANkD,OAAmBrW,EAAY0D,EAArByD,QAAY/C,EAASV,EAATU,KAC9CD,EAAIkS,MAAAA,OAAA,EAAAA,EAAQtD,YAGlB,KAAK5K,GAAMhE,GAAKqC,GAASsJ,KAAS9P,GAAY,IAANA,EAAc,OAAOmI,EAE7D,IAAeuP,EAAsBtT,EAA7BtE,MAAK6X,EAAAC,EAAA5c,QAAwBoJ,EAAlBmR,MAAK,GAAGhR,EAACoT,EAAA,GAEtB/P,EAAK5H,EAAE0X,EAFkBC,EAAA,GAGZE,EAAsBP,EAAPQ,EAAOR,EAOzC,OALAnb,EAAAnB,SAAK,SAAC0K,EAAGuC,GAEA,OAAC4P,EAAGrR,MAAQd,IAAMvB,EAAE0T,GAAIE,KAAI,WAAM,OAAA5P,EAAG6P,SAASF,EAAIhI,EAAK7H,GAAG1D,EAAGqD,QAClEpB,GAEG2B,WAqFK8P,EAAQ7K,EAAK1J,EAAOzH,OAOhBya,IAPgBvO,OAAuB,IAAvBlM,EAAgB,QAAVmb,EAAA1T,EAAMjC,YAAI,IAAV2V,EAAAA,EAAc,GAApBnb,EACxBic,EAAiC9K,EAAjC8K,OAAQ9Q,EAAyBgG,EAAzBhG,MAAK+Q,EAAoB/K,EAAlBgL,QAAAA,OAAO,IAAAD,EAAG/K,EAAG+K,EACpB1I,EAAgD/L,EAAxDxC,KAAQuO,OAAU4I,EAAsC3U,EAAtCnE,MAAY+Y,EAA0B5U,EAA/BlC,IAAK+J,OAAU,IAAV+M,EAAIvb,EAAAwb,OAAJD,EAAUE,EAAgB9U,EAAdjC,KAAAgX,OAAI,IAAAD,EAAGrQ,EAAEqQ,EACxDE,EAAkCD,EAA/B3G,UAAAA,OAAS,IAAA4G,EAAG3b,EAAA4b,eAAYD,EAGtBE,EAEAH,EAFAG,YAAWC,EAEXJ,EAFalX,KAAAA,OAAI,IAAAsX,EAAGlb,EAAAmb,GAAOD,EAAEE,EAE7BN,EAF6BM,MAAOrX,EAEpC+W,EAFoC/W,KAAME,EAE1C6W,EAF0C7W,MAAOC,EAEjD4W,EAFiD5W,SAAQmX,EAEzDP,EADApU,MAAAA,OAAK,IAAA2U,EAAkB,QAAftC,EAAA5E,EAAUzN,aAAK,IAAfqS,EAAAA,EAAmB5E,EAAU3I,OAAOkO,EAAU2B,EAU9D,GAPA7Q,EAAG5G,KAAOA,EACV4G,EAAGzG,KAAOA,EACVyG,EAAGtG,SAAWlH,EAAAD,YAAYgJ,EAAO7B,GACjCsG,EAAG9D,MAAQA,EACXyN,EAAY3J,EAAG2J,UAAYoG,EAAOpG,GAG/BiH,GAASnX,EAAO,CAEf,IAAQsR,EAAYxP,EAAZwP,QAEP6F,IAAU5Q,EAAG4Q,MAAQA,GACrBnX,IAAUuG,EAAGvG,MAAQA,GAEtBzF,EAAAnB,SAAK,SAAC8U,EAAM3J,WAEJzC,EAAMwP,QAAU/M,EAEf4S,IAAiB,QAAZE,GAAKhC,EAAA8B,GAAM5S,UAAC,IAAA8S,IAAPhC,EAAM9Q,GAAO5L,EAAAD,UAAUoJ,EAAO,QAAQnC,IAChDK,IAAiB,QAAZsX,GAAKhC,EAAAtV,GAAMuE,UAAC,IAAA+S,IAAPhC,EAAM/Q,GAAO5L,EAAAD,UAAUoJ,EAAO,QAAQhC,MAErD+N,GAGJ/L,EAAMwP,QAAUA,EA4DpB,OAxDA/K,EAAG2H,KAAOsI,EAAQjQ,EAAGyQ,YAAWhU,EAAA5J,SAAAme,EAAA,eAE5B,QAAA,SAAKpX,EAAGC,GACJ,IAIO/H,EAJUkM,EAAYnE,EAArBkR,QAAYzR,EAASO,EAATP,KACNnF,EAAgCmF,EAAlC,KAAElF,OAAQ,IAARD,EAAIiF,EAAJjF,EAAiB8c,EAAe3X,EAAtBsX,MAAOM,OAAU,IAAVD,EAAKL,EAALK,EAG/B,OAAa,QAANnf,EAAAof,MAAAA,OAAA,EAAAA,EAAKlT,UAAE,IAAPlM,EAAAA,EAAWM,EAAAD,UAAU0H,EAAO,QAAQzF,KAC9CmN,EAAA1O,QAAAme,EACD,QAAA,SAAKpX,EAAGC,GACJ,IAIO/H,EAJUkM,EAAYnE,EAAd,QAAKP,EAASO,EAATP,KACNnF,EAAgCmF,EAAlC,KAAE0C,OAAQ,IAAR7H,EAAIoF,EAAJpF,EAAiBgd,EAAe7X,EAAtBG,MAAO2X,OAAU,IAAVD,EAAK1X,EAAL0X,EAG/B,OAAa,QAANrf,EAAAsf,MAAAA,OAAA,EAAAA,EAAKpT,UAAE,IAAPlM,EAAAA,EAAWM,EAAAD,UAAU0H,EAAO,QAAQmC,KAC9CuF,EAAA1O,QAAAme,EACD,aAAUzP,EAAA1O,QAAA,GACLuQ,EAAE,YAAa,SAACxJ,EAACpG,OAAuBW,IAAnBmF,KAAQqQ,UAAiC,YAAT,IAAbxV,EAAIwV,EAAJxV,kBAE7C,WAAAuF,GAAQ6H,EAAA1O,QAAAme,EAAE,QAAA9U,GAAKqF,EAAA1O,QAAAme,EACf,QAAO,CAAErT,QAAQ,IACsD4D,EAAA1O,QAAAme,EACvE,eAAa,SAACpX,EAACpG,OAAoB1B,SAAa,QAAbA,EAAAud,OAAb,IAAA7b,EAAG+H,EAAK/H,UAAK,IAAA1B,OAAA,EAAAA,EAAgB8Y,kBAChD6F,IAINP,IAAsB,QAAjBmB,GAAKrC,EAAAkB,GAAMoB,cAAM,IAAAD,IAAZrC,EAAMsC,OAAWhC,IAG5BtP,EAAGjB,IAAM,SAAQvL,OAKMkX,EALb7Q,OAAK,IAAArG,EAAG+H,EAAK/H,EACXmE,EAAuBkC,EAAvBlC,MAAO2B,EAAgBO,EAAhBP,KAAMlC,EAAUyC,EAAVzC,MACf4H,EAAUnF,EAAMmF,QAAWnF,EAAMmF,QAAQ,GAAK,EAC9CuS,EAAcna,MAAAA,OAAA,EAAAA,EAAOka,OACnB3J,EAAyBrO,EAAzBqO,KAAM6J,EAAmBlY,EAAnBkY,OAAQC,EAAWnY,EAAXmY,OAChBC,EAAgD,QAAnChH,EAAA+G,MAAAA,OAAA,EAAAA,EAAS5X,EAAOlB,EAAA9F,QAAKmM,EAASrH,WAAO,IAArC+S,EAAAA,EAAyC7Q,EACpD8X,EAAcxC,EAiBtB,OAfAnb,EAAAnB,SAAK,SAACmL,EAAG8B,OAMyBhO,EAHRC,EAFlB2f,EAAU3G,QAAUjL,EAEpB,IAAM8R,EAAiC,QAArB7f,EAAAyf,MAAAA,OAAA,EAAAA,EAASE,EAAW1T,UAAE,IAAtBjM,EAAAA,EAA0B2f,GAG1CC,EAAU/G,YAA+B,QAAjB9Y,EAAAud,EAAQuC,UAAR,IAAA9f,OAAA,EAAAA,EAAoB8Y,cAC1C3L,EAAM0S,GAEVhK,EAAKiK,GAELL,MAAAA,GAAAA,EAAcK,KAElBF,EAAU3Y,KAAKuO,QAEZzN,GAGJmG,4FC4HC4F,EAiHAiM,EAsJAC,EA6HYC,EAjoBAnE,sDAvGXoE,EAAK,QAELC,EAAO,OAEPC,EAAQ,GAERC,EAAK,SAAC/d,GAAM,OAAAge,KAAKC,UAAUje,IAG3Bke,EAEE,GAFFA,EAII,SAJJA,EAI2B,SAJ3BA,EAKK,UALLA,EAK2B,gBAiDxBC,EAAU1Y,EAAO0G,EAAK/M,EAASM,OAAT0e,OAAO,IAAPhf,EAAK,GAALA,EAAS2F,OAAsB,IAAtBrF,EAAS+F,MAAAA,OAAA,EAAAA,EAAOV,OAAhBrF,EAC3C,IAAwB,KAApBqF,MAAAA,GAAAA,GAA4B,OAAO,KAClC,IAAIA,EAAU,MAAO,GAE1B,IAAMmB,EAAImY,EAAAxZ,KAAKE,GAEf,MAAe,aAANmB,EAAmBnB,EAAOU,EAAO0G,EAAKiS,EAAIrZ,GACrC,WAANmB,EAAiBnB,EAChBA,aAAkBsH,QAAYF,KAAOpH,EACtCoZ,EAAU1Y,EAAO0G,EAAKiS,EAAIrZ,EAAOoH,IACjCiS,EAAKD,EAAU1Y,GAAS0G,EAAMA,EAAI,IAAM,IAAIiS,EAAI,GAAIrZ,GACpD,KAyBL,IAw5BFpH,EAx5BQ2gB,EAAkB,SAACzZ,EAAM0Z,EAAMhP,EAACnQ,EAAA+S,OAAEqM,OAAO,IAAApf,EAAG,GAAEA,EAAEqf,OAAI,IAAAtM,EAAGtN,EAAIsN,QACnE,aAAwBzQ,OAAZ6c,EAAK,SAAgB7c,OAAT6N,EAAE3C,OAAO,KAClC7K,EAAAtD,SAAO,SAACgF,EAAGzD,EAAG0L,OAEM4K,SADZ7S,EAAEma,GAAIY,GAAWA,EAAQ,KAAK3Z,EAAM,IAAWnD,OAAR6c,EAAK,KACxC7c,OAD2CgK,EAAE,OACrChK,OAAR+c,EAAK,KAAuB/c,OAAP,QAAb8X,EAAM,QAANlD,EAAAtW,EAAE0e,YAAF,IAAApI,OAAA,EAAAA,EAAAtK,KAAAhM,EAAS,aAAK,IAAdwZ,EAAAA,EAAkBxZ,EAAE,QACpCuP,EAAG,KAyBEoP,EAAmB,SAAC9Z,EAAM0Z,EAAMhP,EAACnQ,EAAAsU,GAC1C,OAAA4K,EAAgBzZ,EAAM0Z,EAAMhP,OADuB,IAAAnQ,EAAG,GAAEA,OAAM,IAAAsU,EAAG7O,EAAI6O,GACvB,KAG7C,mBAAuChS,OAApB6c,EAAK,eAAoB7c,OAAL6c,EAAK,yBACxC,mBAAwB7c,OAAL6c,EAAK,uBAC5B,WAAuB7c,OAAb6c,EAAK,UAEL7c,OAFaK,EAAAtD,SAAO,SAACgF,EAAGzD,EAAG0L,GAC7B,OAACA,EAAK,UAAgBhK,OAAPgK,EAAE,OAAahK,OAAR6c,EAAK,KAAU7c,OAAPgK,EAAE,OAAOhK,OAAF+B,EAAE,KAAM,GAAU/B,OAAR6c,EAAK,KAAK7c,OAAFgK,KAC5D6D,EAAG,IAAI,OA2BFqP,EAAoB,SAAC/Z,EAAM0Z,EAAMhP,EAACnQ,EAAAyf,OAAEL,OAAO,IAAApf,EAAG,GAAEA,EACzD,OAAAkf,EAAgBzZ,EAAM0Z,EAAMhP,EAAGiP,OADgC,IAAAK,EAAGha,EAAIga,GACxBjB,GAC7CY,GAAWA,EAAQ,KAAK3Z,EAAM,IAAWnD,OAAR6c,EAAK,KAAQ7c,OAAL6c,EAAK,QAC/Cxc,EAAAtD,SAAO,SAACgF,EAAG+B,EAAGkG,GAAM,OAAAjI,EAAEma,EAAGW,EAAM,IAAW7c,OAARgK,EAAE,QAAchK,OAAR6c,EAAK,KAAK7c,OAAFgK,EAAE,OAAI6D,EAAG,IAAI,KAC9D,WAAuB7N,OAAb6c,EAAK,UAAa7c,OAAL6c,EAAK,UAuBpBO,EAAe,SAACja,EAAM0Z,EAAMhP,EAACnQ,EAAA2f,OAAEP,OAAO,IAAApf,EAAG,GAAEA,EAAEqf,OAAI,IAAAM,EAAGla,EAAIka,EACjE,OAAAT,EAAgBzZ,EAAM0Z,EAAMhP,EAAGiP,EAASC,GAAMb,GAC7CY,GAAWA,EAAQ,KAAK3Z,EAAM,IAAWnD,OAAR6c,EAAK,KAAgB7c,OAAb6c,EAAK,UAAgB7c,OAAR+c,EAAK,KACxD/c,OAD2D6c,EAAK,QACX7c,OAArDK,EAAAtD,SAAO,SAACgF,EAAG+B,EAAGkG,GAAM,OAACjI,GAAKA,EAAE,MAAM8a,EAAK,IAAI7S,IAAG6D,EAAG,IAAI,QACxD,WAAuB7N,OAAb6c,EAAK,UAAa7c,OAAL6c,EAAK,UA8CpBS,EAAc,SAACna,EAAM0Z,EAAMhP,EAACnQ,EAAA6f,EAA0BR,OAAxBD,OAAO,IAAApf,EAAG,GAAEA,EACnD,aADyD,IAAA6f,EAAG,EAACA,IACnD,EAAIH,EACS,UAAnBN,EAAQU,OACRP,EAAmBC,GAAoB/Z,EAAM0Z,EAAMhP,EAAGiP,EAASC,IAswBhE,IAAMU,EAAY,SAAChY,EAAOiX,GAC5B,OAAoC,QAApCzgB,EAAAwgB,EAAUhX,EAAO+W,EAAiBE,UAAG,IAArCzgB,EAAAA,WArqBuBwJ,EAAOiX,GAC/B,IAAMjS,EAAM+R,EACNkB,EAAOjB,EAAUhX,EAAOgF,EAAKiS,GAEnC,GAAY,OAATgB,EAAiB,OAAOA,EAE3B,IAEgB5G,IAFR7T,EAAyDwC,EAAzDxC,KAAMpB,EAAmD4D,EAAnD5D,MAAK8b,EAA8ClY,EAA5CvC,MAAAA,OAAK,IAAAya,EAAG7e,EAAA8e,SAAQD,EAAExX,EAA0BV,EAA1BU,KAAW9H,EAAeoH,EAApBlC,IAAK+J,OAAU,IAAVjP,EAAIS,EAAAwb,OAAJjc,EAC1CsC,EAAkDsC,EAAlDtC,OAAQgF,EAA0C1C,EAA1C0C,SAA4BkY,EAAc5a,EAAhCuO,OAAUtG,OAC9B4S,EAAsB,QAAZhH,EAAAjV,EAAMqJ,cAAM,IAAZ4L,EAAAA,EAAgBjV,EAC1BuE,EAAQD,MAAAA,OAAA,EAAAA,EAAMC,MAEdqB,EAAK,GAASzH,OAAPyK,EAAI,KAAQzK,OAALsN,EAAE,KAAYtN,OAATkD,EAAM,KAAiBlD,OAAdqc,EAAG1b,GAAQ,KAAmBX,OAAhBqc,EAAG1W,GAAU,KACrD3F,OADwD8d,EAAO,KACpD9d,OAAX6d,EAAQ,KAAS7d,OAANoG,GAEnB,OAAe,QAAT2X,GAAEjO,EAAAsM,GAAM3U,UAAC,IAAAsW,EAAAA,EAAPjO,EAAMrI,GACVpH,EAAAtD,SAAO,SAACihB,EAAGlM,EAAStN,EAAGV,EAACpG,OAAEsM,OAAC,IAAAtM,EAAG,EAACA,EAAK,OAAA2C,EAAAtD,SAAO,SAACgF,EAAGzD,GAAM,OAAAyD,EACxC,WAAsB/B,OAAZsN,EAAE,YAAetN,OAAL1B,EAAE,KAAK0B,OAAFwE,EAAE,MAC7B,WAAuBxE,OAAbsN,EAAE,aACTtN,OADoB1B,EAAE,KACU0B,OAAhCmc,EAAK8B,MAAMjU,EAAIA,GAAKrJ,EAAOrC,IAAK,UACxCwT,EAASkM,KACbrY,EAAU,KACZS,EAAS,iBAAsBpG,OAANoG,EAAM,MAAM,IACtC,WAAuBpG,OAAbsN,EAAE,aAA2BtN,OAAhB2F,EAASuF,OAAO,MACvC,WAAqBlL,OAAXsN,EAAE,WAAiBtN,OAAR6d,EAAQ,MAC7B,WAAwB7d,OAAdsN,EAAE,cAAyBtN,OAAb8d,EAAO5a,EAAM,MACrC,WAAoBlD,OAAVsN,EAAE,UAAetN,OAAP8d,EAAO,MAC3B,WAAoB9d,OAAVsN,EAAE,UAActN,OAANkD,EAAM,QA4oB3Bgb,CAAYzY,YAljBQA,EAAOiX,GAC/B,IAAMjS,EAAM+R,EACNkB,EAAOjB,EAAUhX,EAAOgF,EAAKiS,GAEnC,GAAY,OAATgB,EAAiB,OAAOA,EAE3B,MAAiBxV,EAA6BzC,EAAtCwP,QAAYhS,EAA0BwC,EAA1BxC,KAAW5E,EAAeoH,EAApBlC,IAAK+J,OAAU,IAAVjP,EAAIS,EAAAwb,OAAJjc,EACvBsC,EAA6BsC,EAA7BtC,OAAQgF,EAAqB1C,EAArB0C,SAAU6L,EAAWvO,EAAXuO,OACpBK,EAAOL,EAAOtJ,GACdT,EAAK,GAASzH,OAAPyK,EAAI,KAAQzK,OAALsN,EAAE,KAAQtN,OAALkI,EAAE,KAAiBlI,OAAdqc,EAAG1b,GAAQ,KAAmBX,OAAhBqc,EAAG1W,GAAU,KAAc3F,OAAXqc,EAAG7K,IAE/D,OAAe,QAATuM,GAAEhC,EAAAK,GAAM3U,UAAC,IAAAsW,EAAAA,EAAPhC,EAAMtU,GACT,WAAsBzH,OAAZsN,EAAE,YAAYtN,OAAFkI,EAAE,MACzB7H,EAAAtD,SAAO,SAACohB,EAAGrM,EAAS5O,EAAOY,EAACpG,OAAEsM,OAAC,IAAAtM,EAAG,EAACA,EAAK,OAAA2C,EAAAtD,SAAO,SAACgF,EAAGzD,GAAM,MAAC,GAAI0B,OAAF+B,EAAE,MACjD,WAAoB/B,OAAVsN,EAAE,UAAatN,OAAL1B,EAAE,KAAW0B,OAAR8R,EAAQ,MACjC,WAAqB9R,OAAXsN,EAAE,WAActN,OAAL1B,EAAE,KAAS0B,OAANkD,EAAM,MAChC,WAAqBlD,OAAXsN,EAAE,WAA0BtN,OAAjB1B,EAAE,iBAA0B0B,OAAXsN,EAAE,WACrCtN,OAD8C1B,EAAE,MAChB0B,OAAhCmc,EAAK8B,MAAMjU,EAAIA,GAAKrJ,EAAOrC,IAAK,QACxCqH,EAASmM,GAAUqM,KACvBtM,EAAM,IAAI,KA+hBKuM,CAAY3Y,YA7ZVA,EAAOiX,GAChC,IAAMjS,EAAM+R,EACNkB,EAAOjB,EAAUhX,EAAOgF,EAAKiS,GAEnC,GAAY,OAATgB,EAAiB,OAAOA,EAE3B,MAAiBrf,EAAuCoH,EAAhDwP,QAAS/M,OAAK,IAAL7J,EAAI,EAAJA,EAAO4E,EAAgCwC,EAAhCxC,KAAMoM,EAA0B5J,EAA1B4J,KAAW8L,EAAe1V,EAApBlC,IAAK+J,OAAU,IAAV6N,EAAIrc,EAAAwb,OAAJa,EACjCzI,EAAmBzP,EAAnByP,QAAS2L,EAAUpb,EAAViP,MACXoM,EAAc5L,MAAAA,OAAA,EAAAA,EAAUxK,GACxBqW,EAAYF,MAAAA,OAAA,EAAAA,EAAQnW,GACpBT,EAAK,GAASzH,OAAPyK,EAAI,KAAQzK,OAALsN,EAAE,KAAQtN,OAALkI,EAAE,KAAsBlI,OAAnBqc,EAAGiC,GAAa,KAAoBte,OAAjBqc,EAAGkC,GAAW,KAAQve,OAALqP,GAElE,OAAe,QAAT0O,GAAE/B,EAAAI,GAAM3U,UAAC,IAAAsW,EAAAA,EAAP/B,EAAMvU,IACP6W,EACE,WAAwBte,OAAdsN,EAAE,cAEZtN,OAFwBkc,EACrBoB,EAAY,QAAShQ,EAAE,UAAWgR,EAAa,QAASjP,GAC3D,MAHY,KAIdkP,EACCle,EAAAtD,SAAO,SAACgF,EAAGmQ,EAAO5T,GACV,MAAC,GAAc0B,OAAZ+B,EAAE,YAAuB/B,OAAbsN,EAAE,aAAetN,OAAJ1B,GAE3B0B,OAF+Bkc,EAC5BoB,EAAY,MAAOhQ,EAAE,SAAShP,EAAG4T,EAAO,QAAS7C,GACpD,QACLkP,EAAW,IALJ,IA6YfC,CAAa/Y,YAnTKA,EAAOiX,OAOT1gB,EANdyO,EAAM+R,EACNkB,EAAOjB,EAAUhX,EAAOgF,EAAKiS,GAEnC,GAAY,OAATgB,EAAiB,OAAOA,EAE3B,IAAiBrf,EAA8CoH,EAAvDwP,QAAS/M,OAAK,IAAL7J,EAAI,EAAJA,EAAO4E,EAAuCwC,EAAvCxC,KAAM3B,EAAiCmE,EAAjCnE,MAAO+N,EAA0B5J,EAA1B4J,KAAWgL,EAAe5U,EAApBlC,IAAK+J,OAAU,IAAV+M,EAAIvb,EAAAwb,OAAJD,EAC1CiE,EAA0B,QAAZtiB,EAAAiH,EAAKyP,eAAL,IAAA1W,OAAA,EAAAA,EAAekM,GAC7BX,GAASjG,EACTmG,EAAK,GAASzH,OAAPyK,EAAI,KAAQzK,OAALsN,EAAE,KAAQtN,OAALkI,EAAE,KAAsBlI,OAAnBqc,EAAGiC,GAAa,KAAYte,OAATuH,EAAM,KAAQvH,OAALqP,GAE1D,GAAG5H,KAAK2U,EAAS,OAAOA,EAAM3U,GAG9B,MAiBmCoQ,EAjB7B4G,EAASpP,GAAQ,EACjByC,EAAU,WAAY2M,EAAQ,GAAK,MAEnCvY,EAAIoH,EAAE,WACNoR,EAAM,WAAWxY,EAGjByY,EAAM,oBAENC,EAAO,WAAkB5e,OAARkG,EAAE,QAAWlG,OAALkc,EAAGhW,GAC5B2Y,EAAS,WAAqB7e,OAAXkG,EAAE,WAAelG,OAAN2e,EAAG,KAAQ3e,OAALkc,EAAGhW,GAEvC4Y,EAAKxR,EAAE,WAEP9I,EAAI,IAAI8I,EAERyR,EAAiC,QAAtBlK,GAAGoH,EAAAG,GAAM3R,EAAI,kBAAS,IAAAoK,EAAAA,EAAnBoH,EAAMxR,EAAI,WAAe,GACvCuU,EAAQD,EAAY7T,OAA4B,QAAnB2M,EAAAyG,MAAAA,OAAA,EAAAA,EAAapT,cAAM,IAAnB2M,EAAAA,EAAuB,EAG1D,OAAQuE,EAAM3U,IAAOF,EAAQ,GAAM,WAAYvH,OAAFsN,EAAE,sBACxC0R,GACCzX,EAEA,yJAGC,WAA+CvH,OAApCsN,EAAE,kCAAoCtN,OAAFwE,EAAE,cAClDka,EAAK,0BAAyBxC,EAEzB,aAAclc,OAAFwE,EAAE,wBAAsB0X,EACpC,QAASlc,OAAFwE,EAAE,mBAAiB0X,EAE3BoB,EAAY,OAAQhQ,EAAE,OAClBrH,EAAAlJ,SAAI,SAAC+G,EAAGkG,GAAM,OAAA8H,EAAQ,WAET,QAAkB9R,OAAX8e,EAAG9U,EAAE,QAAmBhK,OAAbwE,EAAE,aAAgBxE,OAAL8e,EAAG9U,EAAE,OACxC,MAAOhK,OAAFwE,EAAE,UACZ8Z,EAAaS,GACjB,GAAI1P,GAfZ,6DAiBC,mDAAsDrP,OAAH2e,EAAG,QACtD,WAA+C3e,OAApCsN,EAAE,kCAAoCtN,OAAFwE,EAAE,cAClDka,EAAK,6BAA+B1e,OAAH2e,EAAG,KAAGzC,EAElC,aAAclc,OAAFwE,EAAE,yBAAuB0X,EACrC,SAAyBlc,OAAjBwE,EAAE,iBAAkBxE,OAAH2e,EAAG,MAAIzC,EAChC,QAASlc,OAAFwE,EAAE,oBAAkB0X,EAE5BoB,EAAY,OAAQhQ,EAAE,OAClBrH,EAAAlJ,SAAI,SAAC+G,EAAGkG,GAAM,OAAA8H,EAAQ,WAET,SAAmB9R,OAAX8e,EAAG9U,EAAE,QAAkBhK,OAAZwE,EAAE,YAAYxE,OAAFwE,EAAE,UAEjC,OAAiBxE,OAAX8e,EAAG9U,EAAE,QAAQhK,OAAFwE,EAAE,UACvB,MAAOxE,OAAFwE,EAAE,WACZ8Z,EAAaS,GACjB,GAAI1P,GAjCZ,sEAmCAuP,EAAK,SAAoB5e,OAAZsN,EAAE,YAAYtN,OAAFsN,EAAE,eAC3BuR,EAAO,WAAsB7e,OAAZsN,EAAE,YAAwBtN,OAAdsN,EAAE,cAAetN,OAAH2e,EAAG,OAE9C,8IAGC,WAA+C3e,OAApCsN,EAAE,kCAAoCtN,OAAFwE,EAAE,cAClDka,EAAK,0CAAyCxC,EAEzC,QAASlc,OAAFwE,EAAE,+BAA6B0X,EACtC,QAA0Blc,OAAnBwE,EAAE,mBAAmBxE,OAAFwE,EAAE,OAAK0X,EAEjC,QAA4Blc,OAArBwE,EAAE,qBAAqBxE,OAAFwE,EAAE,OAAK0X,EAInC,QAASlc,OAAFwE,EAAE,qCAAmC0X,EAE7CoB,EAAY,OAAQhQ,EAAE,OAElBrH,EAAAlJ,SAAI,SAAC+G,EAAGkG,GAAM,OAAA8H,EAAS,kBAAmB9R,OAAFwE,EAAE,cAE7B,SAAoBxE,OAAZ8e,EAAG9U,EAAE,SAAehK,OAARwE,EAAE,QAAQxE,OAAFwE,EAAE,WACnC8Z,EAAaS,GACjB,GAAI1P,GArBhB,6DAuBC,WAA+CrP,OAApCsN,EAAE,kCAAoCtN,OAAFwE,EAAE,cAClDka,EAAK,6CAA+C1e,OAAH2e,EAAG,KAAGzC,EAElD,QAASlc,OAAFwE,EAAE,gCAA8B0X,EACvC,QAA2Blc,OAApBwE,EAAE,oBAAoBxE,OAAFwE,EAAE,QAAM0X,EAEnC,QAA6Blc,OAAtBwE,EAAE,sBAAsBxE,OAAFwE,EAAE,QAAM0X,EAIrC,QAAsBlc,OAAfwE,EAAE,eAAgBxE,OAAH2e,EAAG,qCAAmCzC,EAE7DoB,EAAY,OAAQhQ,EAAE,OAElBrH,EAAAlJ,SAAI,SAAC+G,EAAGkG,GAAM,OAAA8H,EAAS,kBAAmB9R,OAAFwE,EAAE,eAE7B,SAAoBxE,OAAZ8e,EAAG9U,EAAE,SAAgBhK,OAATwE,EAAE,SAASxE,OAAFwE,EAAE,YACpC8Z,EAAaS,GACjB,GAAI1P,GAAM,MACnBoP,EASC,8OAIC,WAA+Cze,OAApCsN,EAAE,kCAAoCtN,OAAFwE,EAAE,cAClDka,EAAK,0CAAyCxC,EAGzC,QAASlc,OAAFwE,EAAE,+BAA6B0X,EACtC,QAA0Blc,OAAnBwE,EAAE,mBAAmBxE,OAAFwE,EAAE,OAAK0X,EAEjC,SAAsBlc,OAAdwE,EAAE,cAAcxE,OAAFwE,EAAE,SAAO0X,EAE/B,SAAUlc,OAAFwE,EAAE,yBAAuB0X,EACjC,SAAuBlc,OAAfwE,EAAE,eAAexE,OAAFwE,EAAE,OAAK0X,EAE/BoB,EAAY,OAAQhQ,EAAE,OAElBrH,EAAAlJ,SAAI,SAAC+G,EAAGkG,GAAM,OAAA8H,EAAQ,uBAEb,GAAmB9R,OAAjBwE,EAAE,iBAA0BxE,OAAX8e,EAAG9U,EAAE,QAAQhK,OAAFwE,EAAE,UAChC,GAAIxE,OAAFwE,EAAE,WAGJ,UAAoBxE,OAAX8e,EAAG9U,EAAE,QAAchK,OAARwE,EAAE,QAAQxE,OAAFwE,EAAE,YACnC8Z,EAAaS,GACjB,GAAI1P,GA1BZ,6DA4BC,WAA+CrP,OAApCsN,EAAE,kCAAoCtN,OAAFwE,EAAE,cAClDka,EAAK,6CAA+C1e,OAAH2e,EAAG,KAAGzC,EAGlD,QAASlc,OAAFwE,EAAE,gCAA8B0X,EACvC,QAAgDlc,OAAzCwE,EAAE,yCAAyCxE,OAAFwE,EAAE,QAAM0X,EAExD,SAAuBlc,OAAfwE,EAAE,eAAexE,OAAFwE,EAAE,UAAQ0X,EAEjC,SAAUlc,OAAFwE,EAAE,uCAAqC0X,EAC/C,SAAwBlc,OAAhBwE,EAAE,gBAAgBxE,OAAFwE,EAAE,QAAM0X,EAEjCoB,EAAY,OAAQhQ,EAAE,OAElBrH,EAAAlJ,SAAI,SAAC+G,EAAGkG,GAAM,OAAA8H,EAAQ,uBAEb,GAAoB9R,OAAlBwE,EAAE,kBAA2BxE,OAAX8e,EAAG9U,EAAE,QAAQhK,OAAFwE,EAAE,WACjC,GAAIxE,OAAFwE,EAAE,YAGJ,UAAoBxE,OAAX8e,EAAG9U,EAAE,QAAehK,OAATwE,EAAE,SAASxE,OAAFwE,EAAE,aACpC8Z,EAAaS,GACjB,GAAI1P,GAlDZ,gEAoDAuP,EAAK,SAAoB5e,OAAZsN,EAAE,YAAuBtN,OAAbsN,EAAE,aAAsBtN,OAAXsN,EAAE,WAAWtN,OAAFsN,EAAE,eACnDuR,EAAO,WACS7e,OAAZsN,EAAE,YAAuBtN,OAAbsN,EAAE,aAAsBtN,OAAXsN,EAAE,WAAuBtN,OAAdsN,EAAE,cAAetN,OAAH2e,EAAG,OA9DzD,+DACAC,EAAK,SAAoB5e,OAAZsN,EAAE,YAAuBtN,OAAbsN,EAAE,aAAsBtN,OAAXsN,EAAE,WAAWtN,OAAFsN,EAAE,eACnDuR,EAAO,WACS7e,OAAZsN,EAAE,YAAuBtN,OAAbsN,EAAE,aAAsBtN,OAAXsN,EAAE,WAAuBtN,OAAdsN,EAAE,cAAetN,OAAH2e,EAAG,SA4DjE,KAnJW,IAgRSM,CAAUxZ,oFCvhCtC,OAASyF,OAAQgU,IAAUhU,OAAQiU,IAAS,kBAAkBC,MAAM,UAWvDC,EAAQ5V,GAAM2C,SAAS9B,KAAKb,GAAGwU,MAAMiB,GAAQC,8FCgFjBG,4EAAzBC,EAAY9Z,EAAOzH,OAEhB8Y,EAS0BjC,EAXV3K,OAA2B,IAA3BlM,EAAoB,QAAdshB,EAAA7Z,EAAM7B,gBAAQ,IAAd0b,EAAAA,EAAkB,GAAxBthB,EAClBmd,EAA8C1V,EAAnDlC,IAAK+J,OAAU,IAAV6N,EAAIrc,EAAAwb,OAAJa,EAAYtZ,EAAkC4D,EAAlC5D,MAAOoB,EAA2BwC,EAA3BxC,KAAI0a,EAAuBlY,EAArBvC,MAAAA,OAAK,IAAAya,EAAG7e,EAAA8e,SAAQD,EAChDG,EAAqB,QAAZhH,EAAAjV,EAAMqJ,cAAM,IAAZ4L,EAAAA,EAAgBjV,EACvB8D,EAAa1C,EAAb0C,SACF6Z,EAAY7Z,EAASuF,OACrBuU,EAAY,GACZC,EAAY,GAElBxV,EAAGoD,EAAE,WAAa,SAACxJ,EAACpG,GAAqB,OAAPA,EAAVwL,SAExBgB,EAAGoD,EAAE,aAAe,SAACxJ,EAACpG,OACmBzB,EADT8F,EAACrE,EAAPyI,YAAkBpE,MAAAA,OAAA,EAAAA,EAAGuV,OACvCqI,EAAAC,MAAAje,WAAA,EAAA,CAAM8d,GAANzf,OAA4DD,EAAAhD,QAAxCgF,EAAEuV,OAAKvX,EAAAhD,QAAoB,QAAd8X,EAAO,QAAP5Y,EAAA8F,EAAET,aAAF,IAAArF,OAAA,EAAAA,EAASqb,aAAK,IAAdzC,EAAAA,EAAkB9S,EAAEuV,SADLuI,KAAKJ,IAG7DvV,EAAGoD,EAAE,aAAe,SAAQ5P,OAAe4I,EAAC5I,EAArB6I,mBAA4CC,EAAC9I,EAAtB+I,oBAC1C,OAAAkZ,EAAAG,MAAMJ,EAAWpZ,EAAGE,IAGxB0D,EAAGoD,EAAE,UAAY,SAACxJ,EAACpG,OAAWqiB,EAACriB,EAAR4D,aAAeye,MAAAA,OAAA,EAAAA,EAAGjO,SAezC,IATA,IAAMkO,EAAc,SAACC,UAGjB/hB,EAAAnB,SAAK,SAAC+G,EAAGU,UAAM0F,EAAGoD,EAAG,UAA2BtN,OAAjBigB,EAAIT,EAAWhb,EAAE,MACxC,SAACV,EAACpG,OACQ1B,EAAiB4Y,EADZ7S,EAACrE,EAAVwL,QAAmB7K,EAASX,EAAhBwF,MAAOgd,OAAS,IAAT7hB,EAAI6E,EAAJ7E,EAAkB0hB,EAACriB,EAAR4D,MAAoB6e,EAAEziB,EAAZiI,gBACzCoa,IAAqB,QAAhB/jB,EAAA6G,EAAA9F,QAAKgF,EAAEme,EAAED,EAAKE,UAAd,IAAAnkB,GAAqB,QAAC4Y,EAAtB5Y,EAAoBwI,UAApB,IAAqBoQ,OAArB,EAAsBA,EAAE9C,YACtCnM,IAGAya,EAAM,EAAGC,EAAKvC,EAAO5a,EAAOkd,EAAMC,IAAMD,EAAOJ,EAAYI,GAEnE,OAAOlW,gIC7HJ,MAAMoW,EAAK,CAAIlT,EAAK3D,EAAGE,MAAQyD,IAAQA,EAAM,IAAMA,EAAI,GAAK3D,EAAK2D,EAAI,GAAKzD,EAAIyD,GAExEmT,EAAK,CAAInT,EAAK3D,EAAGE,EAAG6W,EAAGla,MAAQ8G,IAAQA,EAAM,IACrDA,EAAI,GAAK3D,EACT2D,EAAI,GAAKzD,EACTyD,EAAI,GAAKoT,EACTpT,EAAI,GAAK9G,EACV8G,sFCkBG,IAQPqT,EAR0B,SAAQ/iB,EAAAM,EAAAyS,OAAPiQ,OAAM,IAAAhjB,EAAG,EAACA,EAAEyE,OAAI,IAAAnE,EAAG,EAACA,EAAED,OAAO,IAAA0S,EAAG,EAACA,EACxD,OAAAnR,KAAKC,IAAI,EAAGmhB,EAAOve,EAAK,GAAGA,EAAKpE,wCC1BpCoM,EAAAuC,QAAe,0/XCAfvC,EAAAuC,QAAe,k0gBCAfvC,EAAAuC,QAAe","sources":["demo/particles-regl/index.js","node_modules/@swc/helpers/src/_define_property.js","node_modules/@swc/helpers/src/_object_spread.js","node_modules/@swc/helpers/src/_sliced_to_array.js","node_modules/@swc/helpers/src/_array_with_holes.js","node_modules/@swc/helpers/src/_iterable_to_array.js","node_modules/@swc/helpers/src/_non_iterable_rest.js","node_modules/@swc/helpers/src/_to_consumable_array.js","node_modules/@swc/helpers/src/_array_without_holes.js","node_modules/@swc/helpers/src/_non_iterable_spread.js","node_modules/clamp/index.js","node_modules/@epok.tech/fn-time/dist/es/index.js","node_modules/@epok.tech/fn-lists/reduce.js","node_modules/@epok.tech/fn-lists/map.js","node_modules/@epok.tech/fn-lists/each.js","node_modules/@epok.tech/fn-lists/range.js","node_modules/@epok.tech/fn-lists/wrap.js","node_modules/@epok.tech/fn-lists/wrap-index.js","index.js","maps.js","const.js","node_modules/@epok.tech/gl-screen-triangle/dist/esm/index.js","index.vert.glsl","state.js","size.js","step.js","macros.js","node_modules/@epok.tech/is-type/type.js","inputs.js","node_modules/@thi.ng/vectors/setc.js","index-forms/index.js","demo/particles-regl/step.frag.glsl","demo/particles-regl/draw.vert.glsl","demo/particles-regl/draw.frag.glsl"],"sourcesContent":["/** Demo implementation of 3D particle Verlet/Euler integration simulation. */\n\nimport getRegl from 'regl';\nimport clamp from 'clamp';\nimport timer from '@epok.tech/fn-time';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\nimport each from '@epok.tech/fn-lists/each';\nimport range from '@epok.tech/fn-lists/range';\nimport wrap from '@epok.tech/fn-lists/wrap';\n\nimport { gpgpu, extensionsFloat, extensionsHalfFloat, optionalExtensions }\n    from '../../index';\n\nimport { macroPass } from '../../macros';\nimport { mapFlow } from '../../maps';\nimport { getUniforms } from '../../inputs';\nimport { getDrawIndexes } from '../../size';\nimport indexForms from '../../index-forms';\n\nimport stepFrag from './step.frag.glsl';\nimport drawVert from './draw.vert.glsl';\nimport drawFrag from './draw.frag.glsl';\n\nself.gpgpu = gpgpu;\nself.macroPass = macroPass;\nself.mapFlow = mapFlow;\nself.getUniforms = getUniforms;\nself.getDrawIndexes = getDrawIndexes;\nself.indexForms = indexForms;\n\nconst canvas = document.querySelector('canvas');\n\n// Scroll to the top.\nconst scroll = () => setTimeout(() => canvas.scrollIntoView(true), 0);\n\nscroll();\n\nfunction toggleError(e) {\n    document.querySelector('.error').classList[(e)? 'remove' : 'add']('hide');\n    canvas.classList[(e)? 'add' : 'remove']('hide');\n    scroll();\n}\n\n// Handle query parameters.\n\nconst getQuery = (search = location.search) => new URLSearchParams(search);\n\nfunction setQuery(entries, query = getQuery()) {\n    each(([k, v = null]) => ((v === null)? query.delete(k) : query.set(k, v)),\n        entries);\n\n    return query;\n}\n\nlet query = getQuery();\nconst fragDepth = (query.get('depth') === 'frag');\n\n// Set up GL.\n\nconst extend = {\n    halfFloat: extensionsHalfFloat?.(),\n    float: extensionsFloat?.(),\n    other: optionalExtensions?.(),\n    depth: (fragDepth && 'EXT_frag_depth')\n};\n\nconst pixelRatio = (Math.max(devicePixelRatio, 1.5) || 1.5);\n\nconst regl = self.regl = getRegl({\n    canvas, pixelRatio,\n    extensions: extend.required = extend.halfFloat,\n\n    optionalExtensions: extend.optional = ((fragDepth)?\n            [...extend.float, ...extend.other, extend.depth]\n        :   [...extend.float, ...extend.other]),\n\n    onDone: (e) => toggleError(e)\n});\n\nconsole.group('Extensions');\n\nconsole.log('required', (extend.required &&\n    reduce((o, e) => o+(o && '; ')+e+': '+regl.hasExtension(e),\n        extend.required, '')));\n\nconsole.log('optional', (extend.optional &&\n    reduce((o, e) => o+(o && '; ')+e+': '+regl.hasExtension(e),\n        extend.optional, '')));\n\nconsole.groupEnd();\n\n// How many frame-buffers are bound at a given time.\nconst bound = 1;\n\n// How many state values (channels) are tracked independently of others.\n// The order here is the order used in the shaders and generated macros, but for\n// optimal lookups may be `packed` into channels/textures/passes differently.\n\nconst valuesMap = (new Map())\n    // Position, uses 3 channels.\n    .set('position', 3)\n    // Motion, uses 3 channels.\n    .set('motion', 3)\n    // Life, uses 1 channel.\n    .set('life', 1);\n\nconst values = [];\nconst valuesIndex = {};\n\nvaluesMap.forEach((v, k) => valuesIndex[k] = values.push(v)-1);\n\nconsole.log(values, '`values`');\n\n// Limits of this device and these `values`.\nconst { maxTextureUnits, maxTextureSize, lineWidthDims, pointSizeDims } =\n    regl.limits;\n\n// Whether to merge states into one texture; separate textures if not given.\nconst useMerge = query.get('merge');\n// Merge by default for maximum platform compatibility.\nconst merge = (!useMerge || (useMerge !== 'false'));\n// @todo Should work in one of these cases:\n// const merge = ((useMerge)? (useMerge !== 'false') : (stepsPast > 1));\n// const merge = ((useMerge)? (useMerge !== 'false') : (form !== 1));\n\n// Better stay farther under maximum texture size, or errors/crashes.\nconst limits = { scale: [0, Math.log2(maxTextureSize)] };\n\nconst niceScale = clamp(8, ...limits.scale);\n\nconst scale = clamp((parseFloat(query.get('scale'), 10) || niceScale),\n    ...limits.scale);\n\nlimits.steps = [\n    1+bound,\n    ((merge)?\n        // Maximum steps must fit the maximum total texture size if merging; and\n        // within a sane arbitrary limit.\n        clamp(Math.floor(maxTextureSize/scale), 2, 1e2)\n        // Maximum steps must fit the maximum total texture units if separate.\n    :   Math.floor((maxTextureUnits-bound)/reduce((s, v) => s+v, values)*4))\n];\n\nconsole.log('limits', limits, regl.limits);\n\n// 2 active states, as many others as can be bound; at least 2 past states\n// needed for Verlet integration, 1 for Euler integration.\nconst steps = clamp((parseInt(query.get('steps'), 10) || 2+bound),\n    ...limits.steps);\n\n// How many past steps (not bound to outputs) are in the GPGPU state.\nconst stepsPast = steps-bound;\n// Whether to allow Verlet integration; according to available resource limits.\nconst canVerlet = (stepsPast > 1);\n\n// Form vertexes to draw; if not given, uses trails of 'lines' if there are\n// enough steps, or 'points' if not.\nconst form = (parseInt(query.get('form'), 10) || 0);\n// How wide the form is; to be scaled by `viewScale`.\nconst wide = (parseFloat(query.get('wide'), 10) || 4e-3*pixelRatio);\n\n// Variable-step (delta-time) if given falsey/`NaN`; fixed-step (add-step)\n// if given another number; uses default fixed-step if not given.\nconst hasTimestep = query.has('timestep');\n\nconst timestep = ((hasTimestep)? (parseFloat(query.get('timestep'), 10) || null)\n    :   1e3/60);\n\nconsole.log(location.search+':\\n', ...([...query.entries()].flat()), '\\n',\n    'steps:', steps, 'scale:', scale, 'form:', form, 'wide:', wide,\n    'depth:', fragDepth, 'timestep:', timestep, 'merge:', merge);\n\n// Set up the links.\n\ndocument.querySelector('#verlet').href =\n    `?${setQuery([['steps'], ['scale'], ['wide'], ['depth']])}#verlet`;\n\ndocument.querySelector('#euler').href = `?${setQuery([\n        ['steps', 1+bound], ['scale', Math.min(niceScale+1, limits.scale[1])],\n        ['wide'], ['depth']\n    ])}#euler`;\n\ndocument.querySelector('#long').href = `?${setQuery([\n        ['steps', Math.min(10, limits.steps[1])],\n        ['scale', Math.max(niceScale-1, limits.scale[0])], ['wide'], ['depth']\n    ])}#long`;\n\ndocument.querySelector('#trace').href = `?${setQuery([\n        ['steps', limits.steps[1]], ['scale', clamp(3, ...limits.scale)],\n        ['wide'], ['depth']\n    ])}#trace`;\n\ndocument.querySelector('#high').href = `?${setQuery([\n        ['steps', Math.max(limits.steps[0], limits.steps[1]-3)],\n        ['scale', Math.max(niceScale, limits.scale[1]-5)], ['wide'], ['depth']\n    ])}#high`;\n\ndocument.querySelector('#trails').href =\n    `?${setQuery([['form', ((form)? ((form+1)%3 || null) : 1)]])}#trails`;\n\ndocument.querySelector('#timestep').href =\n    `?${setQuery([['timestep', ((hasTimestep)? null : 0)]])}#timestep`;\n\ndocument.querySelector('#merge').href =\n    `?${setQuery([['merge',\n        ((!useMerge)? true : ((useMerge !== 'false')? false : null))]])}#merge`;\n\n// How state values map to any past state values they derive from.\n// Denoted as an array, nested 1-3 levels deep:\n// 1. In `values` order, indexes `values` to derive from, 1 step past.\n// 2. Indexes `values` to derive from, 1 step past.\n// 3. Shows how many steps past, then indexes `values` to derive from.\n\nconst derives = [];\n\n// Position value derives from:\nderives[valuesIndex.position] = [\n    // Position, 2 steps past.\n    [wrap(1, stepsPast), valuesIndex.position],\n    // Position, 1 step past.\n    valuesIndex.position,\n    // Motion, 1 step past.\n    valuesIndex.motion,\n    // Life, 1 step past.\n    valuesIndex.life\n];\n\n// Motion value derives from:\nderives[valuesIndex.motion] = [\n    // Motion, 1 step past.\n    valuesIndex.motion,\n    // Life, 1 step past.\n    valuesIndex.life,\n    // Position, 1 step past.\n    valuesIndex.position\n];\n\n// Life value derives from:\nderives[valuesIndex.life] = [\n    // Life, last step past.\n    [wrap(-1, stepsPast), valuesIndex.life],\n    // Life, 1 step past.\n    valuesIndex.life\n];\n\nconsole.log(derives, '`derives`');\n\n// The main `gl-gpgpu` state.\nconst state = gpgpu(regl, {\n    // Logic given as state values, `gl-gpgpu` maps optimal inputs and outputs.\n    maps: {\n        // How many state values (channels) are tracked independently of others.\n        values,\n        // How state values map to any past state values they derive from.\n        derives\n    },\n    // How many steps of state to track.\n    steps,\n    // How many states are bound to frame-buffer outputs at any step.\n    bound,\n    // How many entries to track, here encoded as the power-of-2 size per side\n    // of the data texture: `(2**scale)**2`; can also be given in other ways.\n    scale,\n    // Whether to merge states into one texture; separate textures if not given.\n    merge,\n    // Data type according to platform capabilities.\n    // @todo Seems to move differently with `'half float'` Verlet integration.\n    type: ((extend.float.every(regl.hasExtension))? 'float' : 'half float'),\n    // Configure macro hooks, global or per-shader.\n    macros: {\n        // No macros needed for the `vert` shader; all other macros generated.\n        vert: false\n    },\n    // Prefix is usually recommended; use none here to check for naming clashes.\n    pre: '',\n    // Properties for each step of state, and each pass of each step.\n    step: {\n        // A fragment shader to compute each state step, with `gl-gpgpu` macros.\n        // Vertex shaders can also be given.\n        frag: stepFrag,\n        // Macros are prepended to `frag` shader per-pass, cached in `frags`.\n        frags: [],\n        // Custom uniforms in addition to those `gl-gpgpu` provides.\n        uniforms: {\n            dt: (_, { props: { timer: { dt }, rate: r } }) => dt*r,\n            dt0: (_, { props: { timer: { dts: { 0: dt } }, rate: r } }) => dt*r,\n            dt1: (_, { props: { timer: { dts: { 1: dt } }, rate: r } }) => dt*r,\n            time: (_, { props: { timer: { time: t }, rate: r } }) => t*r,\n\n            loop: (_, { props: { timer: { time: t }, loop: l } }) =>\n                Math.sin(t/l*Math.PI)*l,\n\n            lifetime: regl.prop('props.lifetime'),\n            useVerlet: regl.prop('props.useVerlet'),\n            epsilon: regl.prop('props.epsilon'),\n            moveCap: regl.prop('props.moveCap'),\n            source: regl.prop('props.source'),\n            sink: regl.prop('props.sink'),\n            g: regl.prop('props.g'),\n            scale: regl.prop('props.scale'),\n\n            // One option in these arrays is used, by Euler/Verlet respectively.\n            spout: (_, { props: { spout: ss, useVerlet: u } }) => ss[+u],\n            // drag: (_, { props: { drag: ds, useVerlet: u } }) => ds[+u]\n        }\n    },\n\n    // Custom properties to be passed to shaders mixed in with `gl-gpgpu` ones.\n    props: {\n        // Set up the timer.\n        timer: timer((timestep)?\n                // Fixed-step (add-step).\n                { step: timestep, dts: range(2, 0) }\n                // Real-time (variable delta-time).\n            :   { step: '-', now: () => regl.now()*1e3, dts: range(2, 0) }),\n\n        // Speed up or slow down the passage of time.\n        rate: 1,\n        // Loop time over this period to avoid instability of parts of the demo.\n        loop: 3e3,\n        // A particle's lifetime range, and whether it's allowed to spawn.\n        lifetime: [3e2, 4e3, +true],\n        // Whether to use Verlet (midpoint) or Euler (forward) integration.\n        useVerlet: +canVerlet,\n        // A small number greater than 0; avoids speeds exploding.\n        epsilon: 1e-5,\n        // How faar a particle can move in any frame.\n        moveCap: 1.5e-3,\n        // Whether to invert particle flow towards rather than away from source.\n        invert: false,\n        // The position around which particles spawn.\n        source: [0, 0, 0.4],\n        // Sink position, and universal gravitational constant.\n        sink: [\n            // Sink position.\n            0, 0, 0.6,\n            // Universal gravitational constant (scaled).\n            6.674e-11*5e10\n        ],\n        // Constant acceleration due to gravity; and whether to use it, uses\n        // sink if not.\n        g: [\n            // Constant acceleration due to gravity.\n            0, -9.80665, 0,\n            // Whether to use it, uses sink if not.\n            +false\n        ],\n        // For numeric accuracy, encoded as exponent `[b, p] => b*(10**p)`.\n        scale: [1, -7],\n\n        // One option in these arrays is used, by Euler/Verlet respectively.\n\n        // The distance from the `source`, and speed, that particles spawn with.\n        spout: [[0, 3e3], [0, 2e2]],\n        // Drag coefficient.\n        // drag: [range(3, 1e-3), range(3, 1e-1)]\n    }\n});\n\nconsole.log(self.state = state);\n\nconsole.group('How `values` are `packed` to fit texture channels efficiently');\nconsole.log(state.maps.values, '`values` (referred to by index)');\nconsole.log(state.maps.packed, '`packed` (indexes `values`)');\nconsole.log(...state.maps.textures, '`textures` (indexes `values`)');\nconsole.log(state.maps.valueToTexture, '`valueToTexture` (indexes `textures`)');\nconsole.groupEnd();\n\n// Set up rendering.\n\n// Draw all states with none bound as outputs.\n// @todo Errors without `merge`; why, if the framebuffer isn't bound?\nconst drawBound = +(!merge);\nconst drawSteps = steps-drawBound;\nconst useLines = (merge && (drawSteps > 1));\n\nconsole.log('drawSteps', drawSteps, 'useLines', useLines);\n\n// Vertex counts by form; how many steps a form covers, for all entries;\n// respectively for: none, points, lines.\n// Note `state.size.count` will equal the value returned by `countDrawIndexes`.\nconst drawCounts = map((_, f) => indexForms(drawSteps, f, state.size.count),\n    range(2+useLines), 0);\n\nconst viewScale = ({ drawingBufferWidth: w, drawingBufferHeight: h }) =>\n    Math.min(w, h);\n\n// Reuse the GPGPU state, mix in drawing-specific state.\nconst drawState = {\n    ...state,\n    bound: drawBound,\n    // Drawing, don't need to output any data; also don't need `frag` macros.\n    macros: { 'output': 0, 'frag': 0 },\n    drawProps: {\n        // How many vertexes per form.\n        form: clamp((form || 2), 1, 1+useLines),\n        // Vertex counts by form; how many steps a form covers, for all entries.\n        count: null,\n        counts: drawCounts,\n        // Which primitives can be drawn.\n        primitive: null,\n        primitives: [, 'points', 'lines'],\n        // How wide the form is; to be scaled by `viewScale`.\n        wide,\n\n        // One option in these arrays is used, by Euler/Verlet respectively.\n\n        // Speed-to-colour scaling, as `[multiply, power]`.\n        pace: [[1e-3, 0.6], [3e2, 0.6]]\n    },\n    // Map everything similarly to the GPGPU step, `mapFlow` can be reused to\n    // create new mappings with some additions for drawing.\n    maps: mapFlow({\n        ...state.maps,\n        // This one pass can bind textures for input; not output across passes.\n        texturesMax: maxTextureUnits,\n        /**\n         * One set of lookups/reads of all values in one pass.\n         * Passing `true` adds all values at that level of nesting:\n         * `pass|[values|[value|[step, value]]]`\n         * Thus, this example means that the _first_ value derives from:\n         * - All values 1 step past (`true`).\n         * - The position value 2 steps past.\n         * Makes `reads_0_i` macros for each `i => [step, value]` of\n         * `[[0, 0], [0, 1], [0, 2], [1, 0]]`\n         */\n        derives: [[true, [wrap(1, drawSteps), valuesIndex.position]]]\n    })\n};\n\nconst drawCommand = {\n    // Use GPGPU macro mappings by prepending macros from a single pass.\n    vert: macroPass(drawState)+drawVert, frag: drawFrag,\n    // Maximum count here to set up buffers, can be partly used later.\n    attributes: { index: getDrawIndexes(Math.max(...drawCounts)) },\n    // Hook up GPGPU uniforms by adding them here.\n    uniforms: getUniforms(drawState, {\n        ...drawState.step.uniforms,\n        scale: regl.prop('props.scale'),\n        // How many vertexes per form.\n        form: regl.prop('drawProps.form'),\n        pace: (_, { drawProps: { pace: p }, props: { useVerlet: u } }) => p[+u],\n\n        pointSize: (c, { drawProps: { wide: w } }) =>\n            clamp(w*viewScale(c), ...pointSizeDims)\n    }),\n    lineWidth: (c, { drawProps: { wide: w } }) =>\n        clamp(w*viewScale(c), ...lineWidthDims),\n\n    // Vertex counts by form; how many steps a form covers, for all entries.\n    count: (_, { drawProps: { count: c, counts: cs, form: f } }) => c ?? cs[f],\n    depth: { enable: true },\n    blend: { enable: true, func: { src: 'one', dst: 'one minus src alpha' } },\n\n    primitive: (_, { drawProps: { primitive: p, primitives: ps, form: f } }) =>\n        p ?? ps[f]\n};\n\nconsole.log((self.drawState = drawState), (self.drawCommand = drawCommand));\n\nconst draw = regl(drawCommand);\n\nfunction stepTime(state) {\n    const { dts } = state;\n\n    dts[0] = dts[1];\n    dts[1] = timer(state).dt;\n\n    return state;\n}\n\nconst clearView = { color: [0, 0, 0, 0], depth: 1 };\n\nregl.frame(() => {\n    try {\n        stepTime(state.props.timer);\n        // Compute the next step of state.\n        state.step.run();\n        drawState.stepNow = state.stepNow+1-drawBound;\n        regl.clear(clearView);\n        draw(drawState);\n    }\n    catch(e) { toggleError(e); }\n});\n\nfunction stopEvent(e) {\n    e.stopPropagation();\n    e.preventDefault();\n}\n\n// Pause the spawning while pointer is held down.\nlet hold;\n\n// Pause particles spawning.\ncanvas.addEventListener('contextmenu', (e) => {\n    // Whether a particle's allowed to spawn.\n    state.props.lifetime[2] = +false;\n    hold = false;\n    stopEvent(e);\n});\n\n// Toggle physics and graphics modes.\ncanvas.addEventListener((('onpointerup' in self)? 'pointerup'\n        : (('ontouchend' in self)? 'touchend' : 'mouseup')), (e) => {\n    // Unpause the spawning when pointer is released.\n    const spawned = state.props.lifetime[2];\n    const held = hold;\n\n    // Whether a particle's allowed to spawn.\n    state.props.lifetime[2] = +true;\n    hold = false;\n\n    // Don't switch modes if pointer was being held down, particles weren't\n    // allowed to spawn, or any non-primary button was released.\n    if(held || !spawned || (e.button !== 0)) { return; }\n\n    // Switch between physics/drawing modes if this wasn't press-held.\n\n    const { props: p, drawProps: d } = drawState;\n    const v = (canVerlet && (p.useVerlet = 1-p.useVerlet));\n    const f = (form || (d.form = 1+(useLines && ((canVerlet)? v : d.form%2))));\n\n    console.log('useVerlet', v, 'form', f,\n        // See how this derives other properties.\n        'count', drawCommand.count(0, drawState),\n        'primitive', drawCommand.primitive(0, drawState));\n});\n\n// Move either the source or the sink, according to primary pointer.\ncanvas.addEventListener((('onpointermove' in self)? 'pointermove'\n        : (('ontouchmove' in self)? 'touchmove' : 'mousemove')), (e) => {\n    const { clientX: x, clientY: y, type, pointerType, isPrimary = true } = e;\n    const { source: i, sink: o, invert } = state.props;\n    const touch = ((type === 'touchmove') || (pointerType === 'touch'));\n    // Move either source/sink, switch by primary/other pointers or inverting.\n    const to = ((isPrimary)? ((invert)? o : i) : ((invert)? i : o));\n    const size = Math.min(innerWidth, innerHeight);\n\n    to[0] = (((x-((innerWidth-size)*0.5))/size)*2)-1;\n    to[1] = -((((y-((innerHeight-size)*0.5))/size)*2)-1);\n    // For touch devices, don't pause spawn if touch moves while held down.\n    (touch && (hold = true));\n});\n\n// Switch primary pointer control between source and sink.\ncanvas.addEventListener('dblclick', (e) => {\n    state.props.invert = !state.props.invert;\n    stopEvent(e);\n});\n\n// Resize the canvas.\nfunction resize() {\n    canvas.width = innerWidth*pixelRatio;\n    canvas.height = innerHeight*pixelRatio;\n}\n\naddEventListener('resize', resize);\nresize();\n\nmodule?.hot?.accept?.(() => location.reload());\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n","import defineProperty from './_define_property';\n\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import arrayWithHoles from './_array_with_holes';\nimport iterableToArrayLimit from './_iterable_to_array';\nimport nonIterableRest from './_non_iterable_rest';\n\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n","import arrayWithoutHoles from './_array_without_holes';\nimport iterableToArray from './_iterable_to_array';\nimport nonIterableSpread from './_non_iterable_spread';\n\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n","module.exports = clamp\n\nfunction clamp(value, min, max) {\n  return min < max\n    ? (value < min ? min : value > max ? max : value)\n    : (value < max ? max : value > min ? min : value)\n}\n","/**\n * Simple time-stepping - frame, real-time, constant-step - via any API.\n */\n\nexport const steps = {\n    diff: '-', dt: '-', '': '-',\n    pause: 0, '': 0,\n    add: '+', '': '+'\n};\n\nexport const stepDef = steps.diff;\nexport const startDef = 0;\nexport const nowDef = { [steps.diff]: Date.now, [steps.add]: 1e3/60 };\n\n/**\n * Sets up properties needed to track time, starts/steps time in various ways:\n * - Time-difference or time-advance stepping.\n * - Step forwards or backwards in time or pause it.\n * - Current time can be a number or function; or the object's fixed time-step.\n * - Override property, pass the result to new objects.\n *\n * @example\n *     // Initial call sets up properties.\n *     const diff0 = timer({ step: '-' }, 200);\n *     // => { step: '-', time: 200, dt: 200 };\n *     const add0 = timer({ step: 200 });\n *     // => { step: 200, time: 200, dt: 200 };\n *\n *     // Subsequent calls advance time and track difference.\n *\n *     // No time difference here.\n *     timer(diff0, 200); // => { step: '-', time: 200, dt: 0 };\n *     timer(add0, 0); // => { step: 200, time: 200, dt: 0 };\n *\n *     // Time-difference here with a change or step, into a new result target.\n *     const diff1 = timer(diff0, 300, {});\n *     // => { step: '-', time: 300, dt: 100 };\n *     const add1 = timer(add0, null, {});\n *     // => { step: 200, time: 400, dt: 200 };\n *\n *     diff1.time-diff0.time === diff1.dt; // => true;\n *     add1.time-add0.time === add1.dt; // => true;\n *\n * @param {object} state The state being tracked.\n * @param {number} [state.time=startDef] The initial time.\n * @param {string|number} [state.step=stepDef] How time advances:\n *     - Difference since last `time`: `'diff'`/`'dt'`/`'-'`/`''`.\n *     - Pause: `'pause'`/`''`, or number zero (`0`).\n *     - Add `time` step: `'add'`/`'+'`/`''`, or non-zero number (step size).\n * @param {number|function} [now] The time now (clock/frame/step/etc), or a\n *     function giving it; if not given, uses `state.step` if numeric or\n *     `nowDef[state.step]` otherwise.\n * @param {object|false} [out=state] The state to set up; modifies `state` if\n *     not given.\n *\n * @returns {object|number} The given `out` set up with its initial `time`; or\n *     if `out` is falsey, returns the relevant calculated unknown value:\n *     - The difference since last `time` for `diff` step.\n *     - The updated `time` for `add` or `pause` step.\n */\nexport function timer(state, now, out = state) {\n    // Get the initial time and step-step.\n    const { time: t0 = startDef, step = stepDef, now: n } = state;\n    // Get the step mode - from a key into `steps` or a numerical value.\n    const s = (steps[step] ?? step);\n    const diff = (s === steps.diff);\n    const t = (now ?? n ?? nowDef[s] ?? s);\n\n    // Step by `s`:\n    // - `0` or falsey to `pause`\n    // - `steps.diff` for difference since last `time`\n    // - `steps.add` or a number to add a `time` step\n    const t1 = ((!s)? t0 : ((diff)? 0 : t0)+((isNaN(t))? t() : t));\n    const dt = t1-t0;\n\n    // If only returning a value, return the relevant calculated unknown.\n    if(!out) { return ((diff)? dt : t1); }\n\n    out.time = t1;\n    out.dt = dt;\n    out.step = step;\n\n    return out;\n}\n\nexport default timer;\n","const r = Array.prototype.reduce;\n\n/**\n * Reduce an array-like list.\n * Similar to native, but with iteratee-first arguments.\n * Supports the native single-argument behaviour.\n *\n * @see Array.prototype.reduce\n *\n * @param {function} f Iteratee function, called as `Array`'s `reduce` does.\n * @param {array|*} a List to reduce over, array or array-like.\n * @param {*} [to] The initial accumulator, if any; handled like `Array`'s\n *     `reduce` does, given or not.\n *\n * @returns {*} The result of running the reducer iteratee function over all\n *     elements of the list.\n */\nexport const reduce = (f, a, to) =>\n    // Needs separate `call` because native detects even `undefined` parameter.\n    ((to === undefined)? r.call(a, f) : r.call(a, f, to));\n\nexport default reduce;\n","import { reduce } from './reduce';\n\n/**\n * Map an array-like list.\n * Similar to native, but with iteratee-first arguments; and allows the object\n * into which properties will be mapped to be defined (a new array, by default),\n * avoiding always creating new arrays.\n *\n * @see Array.prototype.map\n * @see [reduce]{@link ./reduce.js}\n *\n * @param {function} f The iteratee function, given standard `Array.map`\n *     arguments, and any given `to`.\n * @param {array|*} a The list to map over, array or array-like.\n * @param {false|*} [to=[]] The initial accumulator, if given; `a` if falsey; or\n *     a new array if not given.\n *\n * @returns {*} The result of mapping `to` through the iteratee function over\n *     the `a` list.\n */\nexport const map = (f, a, to = []) => reduce((to, v, i) => {\n        to[i] = f(v, i, a, to);\n\n        return to;\n    },\n    a, (to || a));\n\nexport default map;\n","const e = Array.prototype.forEach;\n\n/**\n * Iterates a function over every element of a list, returning the list.\n *\n * @see Array.prototype.forEach\n *\n * @param {function} f The iteratee function.\n * @param {array|*} a List to iterate over, array or array-like.\n *\n * @returns {array|*} The given list.\n */\nexport const each = (f, a) => {\n    e.call(a, f);\n\n    return a;\n}\n\nexport default each;\n","const { fill } = Array.prototype;\nconst { isFinite } = Number;\nconst { floor } = Math;\n\n/**\n * Fills list with the given items filled via `Array`'s `fill`.\n *\n * @see Array.constructor\n * @see Array.prototype.fill\n * @see Number.isFinite\n *\n * @param {number|array|*} [l=0] How many items to create, or existing list.\n * @param {*} [value] A value to fill the array with; for `Array`'s `fill`.\n * @param {number} [start] Start index, inclusive; for `Array`'s `fill`.\n * @param {number} [end] End index, exclusive; for `Array`'s `fill`.\n *\n * @returns {array|*} List with items filled as given.\n */\nexport const range = (l = 0, value, start, end) =>\n    fill.call(((isFinite(l))? Array(floor(l)) : l), value, start, end);\n\nexport default range;\n","import wrapIndex from './wrap-index';\n\n/**\n * Gives an index wrapped over a given length, or the entry at the wrapped\n * index in a given list; wrapped backwards, forwards, never exceeding bounds.\n *\n * @see [wrapIndex]{@link ./wrap-index.js}\n *\n * @param {number} i The index to wrap.\n * @param {number|array|*} l List to index, array or array-like; or numeric\n *     length for a numeric `wrapIndex` result instead.\n * @param {number} [end=l.length] Length to wrap the index over; allows wrapping\n *     over a sub-range of a list; if not given, tries the list's length.\n *\n * @returns {number|*} The index wrapped over the given length by `wrapIndex`;\n *     or the list entry at the wrapped index, if given a list.\n */\nexport const wrap = (i, l, end = l.length) =>\n    ((end || (end === 0))? l[wrapIndex(i, end)] : wrapIndex(i, l));\n\nexport default wrap;\n","/**\n * Wraps an index over a given length, so that indexes greater than the length\n * loop back past `0`, and indexes less than `0` loop backward from the length.\n * Similar to the indexing behaviour of `Array`'s `slice`.\n * Indexing is the equivalent of a true _modulo_ operator, where JavaScript's\n * `%` operator is actually a _remainder_ operator.\n *\n * @see Array.prototpye.slice\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder\n *\n * @param {number} i Index to wrap.\n * @param {number} l Length to wrap the index over.\n *\n * @returns {number} The index wrapped over the length.\n */\nexport const wrapIndex = (i, l) => ((i%l)+l)%l;\n\nexport default wrapIndex;\n","/**\n * GPGPU state-stepping - maps optimal draw passes, shaders, GL resources,\n * inputs, outputs; lets you focus on your logic - BYORenderer.\n *\n * Decouples logic from rendering approach/engine.\n * The modules and many hooks may be used as given, or piecemeal, or overridden.\n *\n * @module gl-gpgpu\n *\n * @todo Fix GLSL3/D3D error \"sampler array index must be a literal expression\".\n *     See info in `macroSamples` in `macros.js`.\n * @todo Allow passes within/across textures; separate data and texture shapes.\n */\n\nimport { mapFlow } from './maps';\nimport { getState } from './state';\nimport { getStep } from './step';\n\nexport * from './const';\n\n/**\n * Sets up all the maps, inputs, resources, etc for a GPGPU process.\n * Each component may also be used individually, see their documentation.\n *\n * @see {@link module:maps.mapGroups}\n * @see {@link module:maps.mapSamples}\n * @see {@link module:state.getState}\n * @see {@link module:inputs.getUniforms}\n * @see {@link module:step.getStep}\n * @see {@link module:macros.macroPass}\n *\n * @param {object} api An API for GL resources. See `getState` and `getStep`.\n * @param {object} [api.limits=api] A map of GL resource limits.\n * @param {number} [api.limits.maxDrawbuffers] The maximum number of GL textures\n *     a framebuffer can bind in a single draw call.\n * @param {object} [state={}] State properties to set up; a new object by\n *     default. See `getState`, `getUniforms`, and `getStep`.\n * @param {object} [state.maps] How values are grouped per-texture per-pass\n *     per-step. Sets up new maps if not given or missing its mapped properties.\n *     See `mapGroups`.\n * @param {number} [state.maps.buffersMax=api.limits.maxDrawbuffers] The\n *     maximum number of textures to use per draw pass. Uses more passes above\n *     this limit.\n * @param {object} [to=state] The state object to set up. Modifies the given\n *     `state` object by default.\n *\n * @returns {object} The given `to` object, with its properties set up.\n */\nexport function gpgpu(api, state = {}, to = state) {\n    const { maxDrawbuffers, glsl } = (api.limits ?? api);\n    const { maps = {} } = state;\n    const { buffersMax } = maps;\n\n    to.glsl = parseFloat(glsl.match(/[0-9\\.]+/)?.[0], 10);\n\n    // Set up maps, then reset any changes to `state.maps`.\n    maps.buffersMax = (buffersMax ?? maxDrawbuffers);\n    mapFlow(maps, (to.maps ??= {}));\n    maps.buffersMax = buffersMax;\n\n    getState(api, state, to);\n    getStep(api, state, (to.step ??= {}));\n\n    return to;\n}\n\n/**\n * @alias module:gl-gpgpu.default\n * @function\n * @see {@link module:gl-gpgpu.gpgpu}\n */\nexport default gpgpu;\n","/**\n * GPGPU mappings for step/draw shaders input/output.\n *\n * These maps show shaders how to make use of a system's supported features, how\n * to pack/unpack their data from framebuffers/textures, perform only minimal\n * needed samples to retrieve any past values they must derive from, etc.\n * Shaders may declare values they output, values they derive from, groupings of\n * in/dependent values - without handling how these concerns map to the\n * particular system resources they're using.\n * System limits/features/extensions are accounted for, to produce the most\n * efficient mappings available with the least I/O when it comes to drawing\n * (draw passes, texture samples, etc).\n *\n * @module maps\n *\n * @todo Allow passes within/across textures; separate data and texture shapes.\n */\n\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport each from '@epok.tech/fn-lists/each';\n\nimport { valuesDef, channelsMaxDef, buffersMaxDef } from './const';\n\nconst { isInteger } = Number;\n\n/** Cache for optimisation. */\nexport const cache = { packed: [] };\n\n/**\n * Determines whether a given value is valid and can be stored within the\n * channels available.\n *\n * @function\n *\n * @param {number} value A value to validate.\n * @param {number} [channelsMax] The maximum channels available to store values.\n *\n * @returns {boolean} Whether the given `value` is valid.\n */\nexport const validValue = (value, channelsMax = channelsMaxDef) =>\n    ((1 <= value) || (value <= channelsMax) ||\n        !!console.error(`\\`gl-gpgpu\\`: the given value (${value}) exceeds the `+\n            `range of channels available, \\`[1, ${channelsMax}]\\` inclusive.`,\n            value, channelsMax));\n\n/**\n * Minimise resource usage, order `values` to pack into blocks of `channelsMax`;\n * interpreted as indexes into the given `values`.\n *\n * @example\n *     packValues([1, 2, 3], 4, []); // =>\n *     [2, 0, 1];\n *\n *     packValues([3, 2, 1], 4, []); // =>\n *     [0, 2, 1];\n *\n *     packValues([4, 3, 2], 4, []); // =>\n *     [0, 1, 2];\n *\n *     packValues([1, 1, 4, 2], 4, []); // =>\n *     [2, 3, 0, 1];\n *\n * @see {@link module:maps.mapGroups}\n *\n * @param {array<number>} values Each entry is how many interdependent channels\n *     are grouped into one texture in one pass, separate entries may be across\n *     one or more textures/passes. See `mapGroups`.\n * @param {number} [channelsMax=channelsMaxDef] The maximum number of channels\n *     per texture. See `mapGroups`.\n * @param {array} [to=[]] An array to store the result; a new array by default.\n *\n * @returns {array<number>} `to` The indexes of the given `values`, reordered\n *     to pack into the fewest buckets of `channelsMax` size or less; stored in\n *     the given `to` array.\n */\nexport function packValues(values, channelsMax = channelsMaxDef, to = []) {\n    map((_, i) => i, values, to).length = values.length;\n\n    // Counts the number of empty channels in the current group.\n    let channels = channelsMax;\n    // How many values have already been packed.\n    let packed = 0;\n    // Tracks the value that best fits the free channels (fills it tightest).\n    let fitIndex = 0;\n    let fitSize = Infinity;\n\n    for(let i = 0; packed < values.length;) {\n        const v = packed+i;\n        const value = values[to[v]];\n\n        if(!validValue(value, channelsMax)) { return to; }\n\n        // Check how value fits the channels - valid is >= 0, perfect is 0.\n        const fit = channels-value;\n\n        if((fit >= 0) && (fit < fitSize)) {\n            fitSize = fit;\n            fitIndex = v;\n        }\n\n        // Not a perfect fit and can keep searching for better fits - continue.\n        if((fitSize !== 0) && (v < values.length-1)) { ++i; }\n        else {\n            // Got a perfect fit or the search ended - swap in best fit value.\n            const pack = to[fitIndex];\n\n            to[fitIndex] = to[packed];\n            to[packed] = pack;\n\n            // Reduce the free channels by the best value, reset if needed.\n            (((channels -= values[pack]) > 0) || (channels = channelsMax));\n            // Start the search again over the remaining unpacked entries.\n            fitIndex = ++packed;\n            fitSize = Infinity;\n            i = 0;\n        }\n    }\n\n    return to;\n}\n\n/**\n * Groups the `values` of GPGPU data items across draw passes and data textures.\n *\n * @example\n *     const x = 2;\n *     const y = 4;\n *     const z = 1;\n *     const maps = { values: [x, y, z], channelsMax: 4 };\n *\n *     // No optimisations - values not packed, single texture output per pass.\n *     mapGroups({ ...maps, buffersMax: 1, packed: false }); // =>\n *     {\n *         ...maps, packed: false,\n *         textures: [[0], [1], [2]], // length === 3\n *         passes: [[0], [1], [2]], // length === 3\n *         valueToTexture: [0, 1, 2], valueToPass: [0, 1, 2],\n *         textureToPass: [0, 1, 2]\n *     };\n *\n *     // Automatically packed values - values across fewer textures/passes.\n *     mapGroups({ ...maps, buffersMax: 1 }); // =>\n *     {\n *         ...maps, packed: [1, 0, 2],\n *         textures: [[1], [0, 2]], // length === 2\n *         passes: [[0], [1]], // length === 2\n *         valueToTexture: [1, 0, 1], valueToPass: [1, 0, 1],\n *         textureToPass: [0, 1]\n *     };\n *\n *     // Can bind more texture outputs per pass - values across fewer passes.\n *     mapGroups({ ...maps, buffersMax: 4 }); // =>\n *     {\n *         ...maps, packed: [1, 0, 2],\n *         textures: [[1], [0, 2]], // length === 2\n *         passes: [[0, 1]], // length === 1\n *         valueToTexture: [1, 0, 1], valueToPass: [0, 0, 0],\n *         textureToPass: [0, 0]\n *     };\n *\n *     // Custom packed values - fuller control.\n *     mapGroups({ ...maps, buffersMax: 4, packed: [0, 2, 1] }); // =>\n *     {\n *         ...maps, packed: [0, 2, 1],\n *         textures: [[0, 2], [1]], // length === 2\n *         passes: [[0, 1]], // length === 1\n *         valueToTexture: [0, 1, 0], valueToPass: [0, 0, 0],\n *         textureToPass: [0, 0]\n *     };\n *\n *     // Merge dependent values - fuller control, but no map for merged values.\n *     mapGroups({ ...maps, values: [x+z, y], buffersMax: 4 }); // =>\n *     {\n *         ...maps, packed: [1, 0],\n *         textures: [[1], [0]], // length === 2\n *         passes: [[0, 1]], // length === 1\n *         valueToTexture: [1, 0], valueToPass: [0, 0],\n *         textureToPass: [0, 0]\n *     };\n *\n * @see {@link module:maps.packValues}\n *\n * @param {object} [maps={}] Maps and initial settings; new object if not given.\n * @param {array<number>} [maps.values=valuesDef()] An array where each number\n *     denotes how many value channels are grouped into one data texture in one\n *     draw pass (where any value map logic isn't handled here); each separate\n *     number may be computed across one or more data textures/passes.\n *     Each value denotes the number of dependent channels to compute together;\n *     separate values denote channels that are independent, and may be drawn in\n *     the same or separate passes, depending on settings/support.\n *     The order may affect the number of passes/textures needed; can maintain\n *     order as-is, or use a more efficient `packed` order. See `packValues`.\n * @param {number} [maps.channelsMax=channelsMaxDef] Maximum channels per\n *     texture.\n * @param {number} [maps.buffersMax=buffersMaxDef] Maximum textures bound per\n *     pass.\n * @param {array<number>|false} [maps.packed] An array of indexes into `values`\n *     packed into an order that best fits into blocks of `channelsMax` to\n *     minimise resources; or false-y to use `values` in their given order;\n *     uses `packValues` if not given.\n * @param {object} [to=maps] An object to contain the results; modifies `maps`\n *     if not given.\n *\n * @returns {object} `to` The given `to` object; how `values` are grouped\n *     per-texture per-pass per-step, meta information, and given parameters.\n * @returns {array<array<number>>} `to.passes` Textures grouped into passes, as\n *     arrays corresponding to framebuffers in separate draw passes; whose\n *     values are indexes into `to.textures`.\n * @returns {array<array<number>>} `to.textures` Values grouped into\n *     textures, as arrays corresponding to framebuffer attachments, into which\n *     `values` are drawn; whose values are indexes into `to.values`.\n * @returns {array<number>} `to.values` The `values`, as given.\n * @returns {number} `to.buffersMax` The max textures per pass, as given.\n * @returns {number} `to.channelsMax` The max channels per texture, as given.\n * @returns {array<number>} `to.valueToTexture` Inverse map from each index of\n *     `to.values` to the index of the data texture containing it.\n * @returns {array<number>} `to.valueToPass` Inverse map from each index of\n *     `to.values` to the index of the pass containing it.\n * @returns {array<number>} `to.textureToPass` Inverse map from each index of\n *     `to.textures` to the index of the pass containing it.\n */\nexport function mapGroups(maps = {}, to = maps) {\n    if(!maps) { return to; }\n\n    const {\n            values = valuesDef(),\n            channelsMax = channelsMaxDef, buffersMax = buffersMaxDef,\n            // Pack `values` into blocks of `channelsMax` to minimise resources.\n            packed = packValues(values, channelsMax, cache.packed)\n        } = maps;\n\n    to.values = values;\n    to.buffersMax = buffersMax;\n    to.channelsMax = channelsMax;\n    to.packed = packed;\n\n    const passes = to.passes = [[]];\n    const textures = to.textures = [[]];\n    const valueToTexture = to.valueToTexture = [];\n    const valueToPass = to.valueToPass = [];\n    const textureToPass = to.textureToPass = [];\n    // Counts the number of channels written in a single draw pass.\n    let channels = 0;\n    // Get the value, via `packed` if valid, or directly as given in `values`.\n    const getValue = ((packed)? ((_, i) => values[i]) : ((v) => v));\n    const getIndex = ((packed)? ((i) => packed[i]) : ((i) => i));\n\n    return reduce((to, v, i) => {\n            const index = getIndex(i);\n            const value = getValue(v, index);\n\n            if(!validValue(value, channelsMax)) { return to; }\n\n            let p = passes.length-1;\n            let pass = passes[p];\n            let t = textures.length-1;\n            let texture = textures[t];\n\n            if((channels += value) > channelsMax) {\n                channels = value;\n                t = textures.push(texture = [])-1;\n\n                ((pass.length >= buffersMax) &&\n                    (p = passes.push(pass = [])-1));\n\n                pass.push(t);\n                textureToPass.push(p);\n            }\n            else if(pass.length === 0) {\n                pass.push(t);\n                textureToPass.push(p);\n            }\n\n            texture.push(index);\n            valueToTexture[index] = t;\n            valueToPass[index] = p;\n\n            return to;\n        },\n        values, to);\n}\n\n/**\n * Maps the minimal set of texture reads to derive the next state of values from\n * a past state of values they depend upon.\n *\n * @example\n *     const maps = mapGroups({\n *         // See `mapGroups` examples for resulting maps.\n *         values: [2, 4, 1], channelsMax: 4, buffersMax: 1, packed: false,\n *         // Derived step/value indexes, per-value; sample entries include:\n *         derives: [\n *             // Single...\n *             2,\n *             // Empty...\n *             ,\n *             // Multiple...\n *             [\n *                 // Defined step...\n *                 [1, 0],\n *                 // All values at any given level/step...\n *                 true\n *             ]\n *         ]\n *     });\n *\n *     mapSamples(maps); // =>\n *     {\n *         ...maps,\n *         // Minimum texture samples for values; nested per-pass, per-value.\n *         // Deepest arrays are step/texture index pairs into `maps.textures`.\n *         samples: [\n *             [[0, 2]],\n *             null,\n *             [[1, 0], [0, 0], [0, 1], [0, 2]]\n *         ],\n *         // Value indexes into `to.samples`; nested per-pass, per-value.\n *         // Map from a value index to data it needs in the minimal samples.\n *         reads: [\n *             [[0]],\n *             null,\n *             [null, null, [0, 1, 2, 3]]\n *         ]\n *     };\n *\n * @see {@link module:maps.mapGroups}\n *\n * @param {object} maps How values are grouped per-texture, per-pass, per-step.\n *     See `mapGroups`.\n * @param {true|array} [maps.derives] How `values` map to any past `values` they\n *     derive from. If given falsey, creates no maps to derive values; .\n * @param {true|number|array} [maps.derives.[]] L1\n * @param {true|number|array} [maps.derives.[].[]] L2\n * @param {true|number} [maps.derives.[].[].[]] L3\n * @param {true|array<true,number,array<true,number,array<true,number>>>} [maps.derives]\n *     How values derive from past values.\n *     If given as a sparse array, each entry relates the corresponding value to\n *     any past value steps/indexes it derives from - a value not derived from\n *     past values may have an empty/null entry; a value derives from past\n *     values where its entry has:\n *     - Numbers; deriving from the most recent state at the given value index.\n *     - Lists of numbers; deriving from the given past state index (1st number\n *         denotes how many steps ago), at the given value index (2nd number).\n *     The nested hierarchy thus has any `pass,[values,[value,[step, value]]]`.\n *     If any level is given as `true`, maps to sample all values, at the given\n *     step (or most recent step, if none given).\n *     If no `derives` given, no samples are mapped, `to` is returned unchanged.\n * @param {array<array<number>>} maps.passes Textures grouped into passes. See\n *     `mapGroups`.\n * @param {array<array<number>>} maps.textures Values grouped into textures. See\n *     `mapGroups`.\n * @param {array<number>} maps.valueToTexture Inverse map from each value index\n *     to the data texture index containing it.\n * @param {object} [to=maps] The object to store the result in; `maps` if not\n *     given.\n *\n * @returns {object} `to` The given `to` object, with resulting maps added for\n *     any given `maps.derives`.\n * @returns {array<array<array<number>>>} `[to.samples]` Map of the minimum\n *     set of indexes into `maps.textures` that need to be sampled per-pass,\n *     to get all `derives` needed for each value of `maps.values` of each\n *     pass of `maps.passes`.\n * @returns {array<array<array<number>>>} `[to.reads]` Sparse map from\n *     each value of `derives` to its step and texture indexes in `to.samples`.\n * @returns {true|array<true,number,array<true,number,array<true,number>>>}\n *     `[to.derives]` How values derive from past values, as given.\n */\nexport function mapSamples(maps, to = maps) {\n    const derives = maps?.derives;\n\n    if(!derives) { return to; }\n\n    const { passes, textures, valueToTexture } = maps;\n    const reads = to.reads = [];\n    const cache = {};\n\n    to.derives = derives;\n\n    const all = (step = 0) =>\n        cache[step] ??= map((t, v) => [step, v], valueToTexture);\n\n    const getAddSample = (pass, value) => function add(set, derive, d) {\n        let step = 0;\n        let texture;\n\n        if(derive === true) { return reduce(add, all(step), set); }\n        else if(isInteger(derive)) { texture = valueToTexture[derive]; }\n        else if(derive[1] === true) { return reduce(add, all(derive[0]), set); }\n        else {\n            step = derive[0];\n            texture = valueToTexture[derive[1]];\n        }\n\n        if(!(isInteger(step) && isInteger(texture))) {\n            return console.error('`mapSamples`: invalid map for sample',\n                derives, maps, pass, value, derive, d, step, texture);\n        }\n\n        // Create the set if not already created.\n        const to = (set || []);\n        // Check for any existing matching step/texture read in the set.\n        const i = to.findIndex(([s, t]) => (s === step) && (t === texture));\n\n        // Add the read for this value in this pass; creating any needed maps.\n        ((reads[pass] ??= [])[value] ??= [])\n            // A new read as needed, or any existing matching read.\n            .push((i < 0)? to.push([step, texture])-1 : i);\n\n        return to;\n    };\n\n    const getAddSamples = (pass) => (set, value) => {\n        const valueDerives = ((derives === true)? derives : derives[value]);\n\n        return ((!valueDerives && (valueDerives !== 0))? set\n            : (((valueDerives === true) || isInteger(valueDerives))?\n                    getAddSample(pass, value)(set, valueDerives)\n                :   reduce(getAddSample(pass, value), valueDerives, set)));\n    }\n\n    to.samples = map((pass, p) => reduce((set, texture) =>\n                reduce(getAddSamples(p), textures[texture], set),\n            pass, null),\n        passes, []);\n\n    return to;\n}\n\n/**\n * Main function, creates maps for a given set of values and settings, as well\n * as maps for minimal samples and reads if new values derive from past ones.\n *\n * @see {@link module:maps.mapGroups}\n * @see {@link module:maps.mapSamples}\n *\n * @function\n *\n * @param {object} [maps] Maps and initial settings.\n * @param {object} [to=maps] An object to contain the results; modifies `maps`\n *     if not given.\n *\n * @returns {object} `to` The given `to` object; how `values` are grouped\n *     per-texture per-pass per-step, meta information, and given parameters;\n *     and minimal samples and reads for any given `maps.derives`.\n */\nexport const mapFlow = (maps, to = maps) =>\n    mapSamples(maps, mapGroups(maps, to));\n\n/**\n * @alias module:maps.default\n * @function\n * @see {@link module:maps.mapFlow}\n */\nexport default mapFlow;\n","/**\n * Default properties for GPGPU and GL capabilities and resources.\n *\n * @module const\n */\n\nimport { positions } from '@epok.tech/gl-screen-triangle';\n\n/** Default vertex shader. */\nexport { default as vertDef } from './index.vert.glsl';\n\n// The required and optional GL extensions for a GPGPU state.\n\n/** Default required extensions; none. */\nexport const extensions = () => [];\n\n/** Default required extensions to draw to `float` buffers. */\nexport const extensionsFloat = () =>\n    ['oes_texture_float', 'webgl_color_buffer_float'];\n\n/** Default required extensions to draw to `half float` buffers. */\nexport const extensionsHalfFloat = () =>\n    ['oes_texture_half_float', 'ext_color_buffer_half_float'];\n\n/** Default optional extensions; update more data in one render pass. */\nexport const optionalExtensions = () => ['webgl_draw_buffers'];\n\n/** Prefix namespace to avoid naming clashes; highly recommended. */\nexport const preDef = 'gpgpu_';\n\n/**\n * Default minimum allowable channels for framebuffer attachments.\n * This avoids `RGB32F` framebuffer attachments, which errors on Firefox.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1448632\n */\nexport const channelsMinDef = 4;\n/**\n * Default minimum allowable channels for framebuffer attachments.\n * This avoids `RGB32F` framebuffer attachments, which errors on Firefox.\n *\n * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1448632\n */\nexport const channelsMaxDef = 4;\n\n/** Default maximum textures bound per pass. */\nexport const buffersMaxDef = 1;\n\n/**\n * Default how many steps are bound as outputs, unavailable as input; for\n * platforms forbidding read/write of same buffer.\n */\nexport const boundDef = 1;\n\n/**\n * Default length of the data textures sides to allocate; gives a square\n * power-of-two texture raising 2 to this power.\n */\nexport const scaleDef = 9;\n\n/**\n * Default width of the data textures sides to allocate; gives a square\n * power-of-two texture raising 2 to the default scale.\n */\nexport const widthDef = 2**scaleDef;\n\n/**\n * Default height of the data textures sides to allocate; gives a square\n * power-of-two texture raising 2 to the default scale.\n */\nexport const heightDef = 2**scaleDef;\n\n/** Default number steps of state to track. */\nexport const stepsDef = 2;\n\n/** Default values to track. */\nexport const valuesDef = () => [channelsMaxDef];\n/** Default vertex positions attribute; 3 points of a large flat triangle. */\nexport const positionsDef = () => [...positions];\n\n// Resource format defaults.\n\n/** Default texture data type. */\nexport const typeDef = 'float';\n/** Default texture minification filter. */\nexport const minDef = 'nearest';\n/** Default texture magnification filter. */\nexport const magDef = 'nearest';\n/** Default texture wrap mode, avoids WebGL1 need for power-of-2 texture. */\nexport const wrapDef = 'clamp';\n/** Default framebuffer depth attachment. */\nexport const depthDef = false;\n/** Default framebuffer stencil attachment. */\nexport const stencilDef = false;\n\n/**\n * Whether to merge states into one texture; un-merged arrays of textures by\n * default.\n */\nexport const mergeDef = false;\n","/**\n * The 3 vertices of a 2D triangle covering the viewport in NDC coordinates ([-1, 1]).\n *\n * @export\n * @type {array.<array.<number>>}\n */\nexport const vertices = [[-1, -1], [-1, 4], [4, -1]];\n\nexport const count = vertices.length;\nexport const dim = 2;\n\n/**\n * The flat array of the above triangle, to be bound as a WebGL attribute buffer for\n * rendering the triangle in the vertex shader.\n * These positions will result in clipped NDC coordinates ([-1, 1]) over the\n * viewport's width and height.\n *\n * @export\n * @type {array.<number>}\n */\nexport const positions = vertices.flat();\n\nexport default positions;\n","/**\n * Default GPGPU vertex shader.\n *\n * @see @epok.tech/gl-screen-triangle/uv-texture.vert.glsl\n */\n\nprecision highp float;\n\nattribute vec2 position;\n\nvarying vec2 uv;\n\nvoid main() {\n    // Texture coordinates, range `[0, 1]`, y-axis points upwards.\n    uv = (position*0.5)+0.5;\n    gl_Position = vec4(position, 0, 1);\n}\n","/**\n * GPGPU state and GL resources: framebuffers, textures; and meta information.\n *\n * @module state\n *\n * @todo Allow passes into or across textures; separate data and texture shapes.\n * @todo In-place updates of complex resources and meta info.\n * @todo Use transform feedback instead of data textures, if supported (WebGL2)?\n */\n\nimport range from '@epok.tech/fn-lists/range';\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\n\nimport { getWidth, getHeight, getScaled } from './size';\n\nimport {\n        widthDef, heightDef, scaleDef, stepsDef, valuesDef, channelsMinDef,\n        typeDef, minDef, magDef, wrapDef, depthDef, stencilDef, mergeDef\n    } from './const';\n\nconst { isInteger } = Number;\n\n/**\n * Set up the GPGPU resources and meta information for a state of a number data.\n *\n * @example\n *     const api = {\n *         framebuffer: ({ depth, stencil, width, height, color }) => null,\n *         texture: ({ type, min, mag, wrap, width, height, channels }) => null\n *     };\n *\n *     // Example with `webgl_draw_buffers` extension support, for 4 buffers.\n *     let maps = mapGroups({ values: [1, 2, 3], buffersMax: 4, packed: 0 });\n *     let state = { steps: 2, side: 10, maps };\n *\n *     const s0 = getState(api, state, {}); // =>\n *     {\n *         ...state, passNow: undefined, stepNow: undefined,\n *         size: {\n *             steps: 2, passes: 2, textures: 4,\n *             width: 10, height: 10, shape: [10, 10], count: 100\n *         },\n *         steps: [\n *             [s0.passes[0][0].framebuffer], [s0.passes[1][0].framebuffer]\n *         ],\n *         // This setup results in fewer passes, as more buffers can be bound.\n *         passes: [\n *             [\n *                 {\n *                     framebuffer: api.framebuffer(s0.passes[0][0]),\n *                     color: [\n *                         s0.textures[0][0].texture, s0.textures[0][1].texture\n *                     ],\n *                     map: [0, 1], // maps.passes[0]\n *                     entry: 0, index: 0, step: 0,\n *                     depth: false, stencil: false, width: 10, height: 10\n *                 }\n *             ],\n *             [\n *                 {\n *                     framebuffer: api.framebuffer(s0.passes[1][0]),\n *                     color: [\n *                         s0.textures[1][0].texture, s0.textures[1][1].texture\n *                     ],\n *                     map: [0, 1], // maps.passes[0]\n *                     entry: 1, index: 0, step: 1,\n *                     depth: false, stencil: false, width: 10, height: 10\n *                 }\n *             ]\n *         ],\n *         textures: [\n *             [\n *                 {\n *                     texture: api.texture(s0.textures[0][0]),\n *                     map: [0, 1], // maps.textures[0]\n *                     entry: 0, index: 0, step: 0, pass: 0,\n *                     type: 'float', width: 10, height: 10, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 },\n *                 {\n *                     texture: api.texture(s0.textures[0][1]),\n *                     map: [2], // maps.textures[1]\n *                     entry: 1, index: 1, step: 0, pass: 0,\n *                     type: 'float', width: 10, height: 10, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 }\n *             ],\n *             [\n *                 {\n *                     texture: api.texture(s0.textures[1][0]),\n *                     map: [0, 1], // maps.textures[0]\n *                     entry: 2, index: 0, step: 1, pass: 0,\n *                     type: 'float', width: 10, height: 10, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 },\n *                 {\n *                     texture: api.texture(s0.textures[1][1]),\n *                     map: [2], // maps.textures[1]\n *                     entry: 3, index: 1, step: 1, pass: 0,\n *                     type: 'float', width: 10, height: 10, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 }\n *             ]\n *         ]\n *     };\n *\n *     // Example with no `webgl_draw_buffers` extension support, only 1 buffer.\n *     maps = mapGroups({ values: [1, 2, 3], buffersMax: 1, packed: 0 });\n *     state = { type: 'uint8', steps: 2, scale: 5, maps, stepNow: 1 };\n *\n *     const s1 = getState(api, state, {}); // =>\n *     {\n *         ...state, passNow: undefined, stepNow: 1,\n *         size: {\n *             steps: 2, passes: 4, textures: 4,\n *             width: 32, height: 32, shape: [32, 32], count: 1024\n *         },\n *         steps: [\n *             [s1.passes[0][0].framebuffer, s1.passes[0][1].framebuffer],\n *             [s1.passes[1][0].framebuffer, s1.passes[1][1].framebuffer]\n *         ],\n *         // This setup results in more passes, as fewer buffers can be bound.\n *         passes: [\n *             [\n *                 {\n *                     framebuffer: api.framebuffer(s1.passes[0][0]),\n *                     color: [s1.textures[0][0].texture],\n *                     map: [0], // maps.passes[0]\n *                     entry: 0, index: 0, step: 0,\n *                     depth: false, stencil: false, width: 32, height: 32\n *                 },\n *                 {\n *                     framebuffer: api.framebuffer(s1.passes[0][1]),\n *                     color: [s1.textures[0][1].texture],\n *                     map: [1], // maps.passes[1]\n *                     entry: 1, index: 1, step: 0,\n *                     depth: false, stencil: false, width: 32, height: 32\n *                 }\n *             ],\n *             [\n *                 {\n *                     framebuffer: api.framebuffer(s1.passes[1][0]),\n *                     color: [s1.textures[1][0].texture],\n *                     map: [0], // maps.passes[0]\n *                     entry: 2, index: 0, step: 1,\n *                     depth: false, stencil: false, width: 32, height: 32\n *                 },\n *                 {\n *                     framebuffer: api.framebuffer(s1.passes[1][1]),\n *                     color: [s1.textures[1][1].texture],\n *                     map: [1], // maps.passes[1]\n *                     entry: 3, index: 1, step: 1,\n *                     depth: false, stencil: false, width: 32, height: 32\n *                 }\n *             ]\n *         ],\n *         textures: [\n *             [\n *                 {\n *                     texture: api.texture(s1.textures[0][0]),\n *                     map: [0, 1], // maps.textures[0]\n *                     entry: 0, index: 0, step: 0, pass: 0,\n *                     type: 'uint8', width: 32, height: 32, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 },\n *                 {\n *                     texture: api.texture(s1.textures[0][1]),\n *                     map: [2], // maps.textures[1]\n *                     entry: 1, index: 1, step: 0, pass: 1,\n *                     type: 'uint8', width: 32, height: 32, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 }\n *             ],\n *             [\n *                 {\n *                     texture: api.texture(s1.textures[1][0]),\n *                     map: [0, 1], // maps.textures[0]\n *                     entry: 2, index: 0, step: 1, pass: 0,\n *                     type: 'uint8', width: 32, height: 32, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 },\n *                 {\n *                     texture: api.texture(s1.textures[1][1]),\n *                     map: [2], // maps.textures[1]\n *                     entry: 3, index: 1, step: 1, pass: 1,\n *                     type: 'uint8', width: 32, height: 32, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 }\n *             ]\n *         ]\n *     };\n *\n * @see {@link texture}\n * @see {@link framebuffer}\n * @see {@link module:maps.mapGroups}\n * @see {@link module:maps.mapSamples}\n * @see {@link module:step.getStep}\n * @see {@link module:macros.macroSamples}\n * @see {@link module:macros.macroTaps}\n * @see {@link module:macros.macroPass}\n * @see {@link module:size.getWidth}\n * @see {@link module:size.getHeight}\n * @see {@link module:size.getScaled}\n *\n * @see {@link https://stackoverflow.com/a/60110986/716898}\n * @see {@link https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_2d_array.html}\n * @see {@link https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_3d.html}\n *\n * @param {object} api The API for GL resources.\n * @param {texture} [api.texture] Function to create a GL texture.\n * @param {framebuffer} [api.framebuffer] Function to create a GL framebuffer.\n * @param {object} [state={}] The state parameters.\n *\n * @param {number} [state.width=widthDef] Data width, aliases follow in order\n *     of precedence. See `getWidth`.\n * @param {number} [state.w] Alias of `state.width`. See `getWidth`.\n * @param {number} [state.x] Alias of `state.width`. See `getWidth`.\n * @param {number} [state.height=heightDef] Data height, aliases follow in order\n *     of precedence. See `getHeight`.\n * @param {number} [state.h] Alias of `state.height`. See `getHeight`.\n * @param {number} [state.y] Alias of `state.height`. See `getHeight`.\n * @param {number} [state.shape] Data size. See `getWidth` and `getHeight`.\n * @param {number} [state.size] Data size. See `getWidth` and `getHeight`.\n * @param {number} [state.side] Data size of width/height.\n *     See `getWidth` and `getHeight`.\n * @param {number} [state.0] Alias of `state.width` (index 0). See `getWidth`.\n * @param {number} [state.1] Alias of `state.height` (index 1). See `getHeight`.\n * @param {number} [state.scale=scaleDef] Data size of width/height as a square\n *     power-of-two size, 2 raised to this power. See `getScaled`.\n *\n * @param {number|array} [state.steps=stepsDef] How many steps of state to\n *     track, or the list of states if already set up.\n * @param {object} [state.maps] How `state.maps.values` are grouped per-texture\n *     per-pass per-step. See `mapGroups`.\n * @param {array<number>} [state.maps.values=valuesDef()] How values of each\n *     data item may be grouped into textures across passes; set up here if not\n *     given. See `mapGroups`.\n * @param {number} [state.maps.channelsMin=channelsMinDef] The minimum allowed\n *     channels for framebuffer attachments; allocates unused channels as needed\n *     to reach this limit.\n * @param {number} [state.maps.textures] How values are grouped into textures.\n *     See `mapGroups`.\n * @param {number} [state.stepNow] The currently active state step, if any.\n * @param {number} [state.passNow] The currently active draw pass, if any.\n * @param {string} [state.type=typeDef] Texture data type.\n * @param {string} [state.min=minDef] Texture minification filter.\n * @param {string} [state.mag=magDef] Texture magnification filter.\n * @param {string} [state.wrap=wrapDef] Texture wrap mode.\n * @param {boolean|*} [state.depth=depthDef] Framebuffer depth attachment.\n * @param {boolean|*} [state.stencil=stencilDef] Framebuffer stencil attachment.\n *\n * @param {boolean|*} [state.merge=mergeDef] Whether to merge states into one\n *     texture; `true` handles merging here; any other truthy is used as-is (the\n *     merged texture already set up); falsey uses un-merged arrays of textures.\n *     Merging allows shaders to access past steps by non-constant lookups; e.g:\n *     attributes cause \"sampler array index must be a literal expression\" on\n *     GLSL3 spec and some platforms (e.g: D3D); but takes more work to copy the\n *     last pass's bound texture/s to merge into the past texture, so should be\n *     used to variably access past steps or avoid arrays of textures limits.\n *     Only this merged past texture and those bound in an active pass are\n *     created, as upon each pass the output will be copied to the past texture,\n *     and bound textures reused in the next pass.\n *     If not merging, all state is as output by its pass in its own one of the\n *     arrays of textures.\n *     The default merged texture is laid out as `[texture, step]` on the\n *     `[x, y]` axes, respectively; if other layouts are needed, the merge\n *     texture can be given here to be used as-is, and the merging/copying and\n *     lookup logic in their respective hooks. See `getStep` and `macroTaps`.\n *     If a merge texture is given, size information is interpreted in a similar\n *     way and precedence as it is from `state`. See `getWidth` and `getHeight`.\n * @param {number} [state.merge.width] Merged data width, aliases follow in\n *     order of precedence. See `state`.\n * @param {number} [state.merge.w] Alias of `state.merge.width`. See `state`.\n * @param {number} [state.merge.x] Alias of `state.merge.width`. See `state`.\n * @param {number} [state.merge.height] Merged data height, aliases follow in\n *     order of precedence. See `state`.\n * @param {number} [state.merge.h] Alias of `state.merge.height`. See `state`.\n * @param {number} [state.merge.y] Alias of `state.merge.height`. See `state`.\n * @param {number} [state.merge.shape] Merged data size. See `state`.\n * @param {number} [state.merge.size] Merged data size. See `state`.\n * @param {number} [state.merge.side] Merged data size of width/height.\n *     See `state`.\n * @param {number} [state.merge.0] Alias of `state.merge.width` (index 0).\n *     See `state`.\n * @param {number} [state.merge.1] Alias of `state.merge.height` (index 1).\n *     See `state`.\n * @param {number} [state.merge.scale] Merged data size of width/height as a\n *     square power-of-two size, 2 raised to this power. See `state`.\n *\n * @param {object} [to=state] The state object to set up. Modifies the given\n *     `state` object by default.\n *\n * @returns {object} `to` The state object, set up with the data resources and\n *     meta information, for use with `getStep` and drawing:\n * @returns {object<number,array<number,array<number>>>} `to.maps` Any given\n *     `state.maps`. See `mapGroups`.\n * @returns {array<array<object<texture,string,number,array<number>>>>}\n *     `to.textures` Textures per step, as arrays of objects of `texture`s and\n *     meta info. See `to.maps.textures`.\n * @returns {array<array<object<framebuffer,number,array<number>>>>}\n *     `to.passes` Passes per step, as arrays of objects of `framebuffer`s,\n *     referencing `to.textures`, and meta info. See `to.maps.passes`.\n * @returns {array<framebuffer<array<texture>>>} `to.steps`\n *     Hierarchy of steps of state, as an array of `framebuffer`s from\n *     `to.passes`, with arrays of `texture`s from `to.textures`, and meta\n *     information; set up here, or the given `state.steps` if it's an array.\n *     State data may be drawn into the framebuffers accordingly.\n *     See `mapGroups` and `getStep`.\n * @returns {undefined|*|object<texture,string,number,array<number>>} `to.merge`\n *     Any created object of a merged `texture` and meta info, or the given\n *     `state.merge` as-is if not handled here. See `getStep` and `macroTaps`.\n * @returns {object} `to.size` Size/type information of the created resources.\n * @returns {string} `to.size.type` Data type of `framebuffer`s and `texture`s.\n * @returns {boolean} `to.size.depth` Whether `framebuffer`s attach depth.\n * @returns {boolean} `to.size.stencil` Whether `framebuffer`s attach stencil.\n * @returns {number} `to.size.channelsMin` Minimum channels in any `texture`.\n * @returns {number} `to.size.steps` Number of `to.steps` in the main flow.\n * @returns {number} `to.size.passes` Number of `to.passes` in `to.steps`.\n * @returns {number} `to.size.framebuffers` Number of `framebuffer`s created.\n * @returns {number} `to.size.textures` Number of `to.textures` in `to.passes`.\n * @returns {number} `to.size.colors` Number of `texture`s created.\n * @returns {number} `to.size.width` Width of `framebuffer`s and `texture`s.\n * @returns {number} `to.size.height` Height of `framebuffer`s and `texture`s.\n * @returns {array<number>} `to.size.shape` Shape of `framebuffer`s and\n *     `texture`s, as `[to.size.width, to.size.height]`.\n * @returns {number} `to.size.count` Number of entries in each `texture`.\n * @returns {undefined|object<number,string,array<number>>} `to.size.merge`\n *     Size/type information about any created or given merge texture.\n * @returns {number} `to.stepNow` The currently active state step, as given.\n * @returns {number} `to.passNow` The currently active draw pass, as given.\n */\nexport function getState({ texture, framebuffer }, state = {}, to = state) {\n    const {\n            steps = stepsDef, stepNow, passNow, maps, merge = mergeDef, scale,\n            // Resource format settings.\n            type = typeDef, min = minDef, mag = magDef, wrap = wrapDef,\n            depth = depthDef, stencil = stencilDef\n        } = state;\n\n    const scaled = getScaled(scale);\n    const width = Math.floor(getWidth(state) ?? scaled ?? widthDef);\n    const height = Math.floor(getHeight(state) ?? scaled ?? heightDef);\n\n    to.maps = maps;\n    to.stepNow = stepNow;\n    to.passNow = passNow;\n\n    const {\n            values = valuesDef(),\n            channelsMin = channelsMinDef, textures: texturesMap\n        } = maps;\n\n    maps.channelsMin = channelsMin;\n    maps.values = values;\n\n    // All framebuffer attachments need the same number of channels; enough to\n    // hold all values a pass holds, or all passes hold if merging and reusing.\n    const passChannels = (pass, min) => reduce((min, t) =>\n            Math.max(min, reduce((sum, v) => sum+values[v], texturesMap[t], 0)),\n        pass, min);\n\n    // If merging past textures and reusing texture attachments in each pass's\n    // framebuffer, pre-compute the minimum channels for a reusable pool of\n    // texture attachments that can hold any pass's values; since all a\n    // framebuffer's attachments also need the same number of channels, this is\n    // also the same number of channels across all passes.\n    const mergeChannels = ((!merge)? null\n        :   reduce((min, p) => passChannels(p, min), maps.passes, channelsMin));\n\n    // Size of the created resources.\n    const size = to.size = {\n        type, depth, stencil, channelsMin: (mergeChannels ?? channelsMin),\n        steps: (steps.length ?? steps),\n        passes: 0, framebuffers: 0, textures: 0, colors: 0,\n        width, height, shape: [width, height], count: width*height\n    };\n\n    /** The textures created for the `step`/`pass` render flow. */\n    const textures = to.textures = [];\n    /** The passes created for the `step`/`pass` render flow. */\n    const passes = to.passes = [];\n    // The textures bound to the next pass; reused if merging.\n    let colorPool;\n\n    /**\n     * Add a texture attachment and meta info to `textures` if applicable; to\n     * return its new `texture` or a reused one to bind to a pass in `passes`.\n     */\n    const addTexture = (channels, w, h, step, pass) => (index, c, _, color) => {\n        // Properties passed for texture creation, then meta info.\n        const to = { channels, width: w, height: h, type, min, mag, wrap };\n\n        // Resources.\n\n        // Add/reuse texture color attachments as needed; add minimal textures.\n        // If merging, passes may reuse any pass's existing texture attachments;\n        // otherwise, each pass has its own dedicated texture attachments.\n        let entry = c;\n        let t = color?.[entry];\n\n        // Only create new textures if existing ones can't be reused.\n        if(!t) {\n            t = texture?.(to);\n            entry = size.textures++;\n        }\n\n        // Add meta info.\n\n        // Check if this is bound to a pass.\n        const bind = (isInteger(pass) || null);\n\n        /** Denotes attached texture; if merging, textures are reused. */\n        to.texture = t;\n        /** Denotes attached texture entry; if merging, textures are reused. */\n        to.entry = entry;\n        /** Denotes framebuffer attachments; may reuse underlying textures. */\n        to.color = (bind && size.colors++);\n        to.step = step;\n        to.pass = pass;\n        to.index = index;\n        to.map = texturesMap[index];\n\n        // Check whether this texture is part of the `step`/`pass` render flow.\n        // If not, return the entire object.\n        return ((!(bind && isInteger(step) && isInteger(index)))? to\n            // If so, add to `textures`, return its `texture` to bind to a pass.\n            :   ((textures[step] ??= [])[index] = to).texture);\n    };\n\n    /**\n     * Add a pass to `passes`, with its `textures` bound; to return its\n     * `framebuffer` to one of `steps`.\n     */\n    const addPass = (step, color) => (pass, index) => {\n        /**\n         * All a framebuffer's attachments need the same number of channels;\n         * ignored if a `color`'s given as it'll be defined there instead.\n         */\n        const channels = (color ?? mergeChannels ??\n            ((pass)? passChannels(pass, channelsMin) : channelsMin));\n\n        // Resources.\n\n        /** Properties passed for framebuffer creation, then meta info. */\n        const to = {\n            depth, stencil, width, height,\n            /** Map the pass's texture color attachments and their meta info. */\n            color: (color ??\n                map(addTexture(channels, width, height, step, index), pass,\n                    // Reuse any existing color attachments if merging;\n                    // otherwise make dedicated color attachments for each pass.\n                    ((merge)? (colorPool ??= []) : [])))\n        };\n\n        /** The framebuffer for this pass. */\n        to.framebuffer = framebuffer?.(to);\n\n        // Add meta info.\n\n        /** Denotes attached texture entry; if merging, textures are reused. */\n        to.entry = size.framebuffers++;\n        /** Denotes framebuffer attachments; . */\n        to.pass = (pass && size.passes++);\n        to.step = step;\n        to.index = index;\n        to.map = pass;\n\n        // Check whether this pass is part of the `step`/`pass` render flow.\n        // If not, return the entire object.\n        return ((!(pass && isInteger(step) && isInteger(index)))? to\n            // If so, add to `passes`, return its `framebuffer` for its step.\n            :   ((passes[step] ??= [])[index] = to).framebuffer);\n    };\n\n    // Set up resources we'll need to store data per-texture per-pass per-step.\n    to.steps = map((passes, step) =>\n            // Use any given passes or create a new list.\n            (passes || map(addPass(step), maps.passes)),\n        // Use any given steps or create a new list.\n        ((isInteger(steps))? range(steps) : steps), 0);\n\n    // Finish here if merge is disabled.\n    if(!merge) { return to; }\n\n    // Set up the texture for states to be merged into.\n\n    // Use any size info available in `merge`, as with `state` above.\n    const mScaled = getScaled(merge.scale);\n    // Use any given size info, or arrange merges along `[texture, step]` axes.\n    const mw = getWidth(merge) ?? mScaled ?? maps.textures.length*width;\n    const mh = getHeight(merge) ?? mScaled ?? size.steps*height;\n\n    // New merge texture and info, or use any given merge texture.\n    (to.merge = ((merge === true)? addTexture(mergeChannels, mw, mh)() : merge))\n        // Empty framebuffer, to copy data from each texture of each pass.\n        .copier ??= addPass(null, false)();\n\n    size.merge = { width: mw, height: mh, shape: [mw, mh], count: mw*mh };\n\n    return to;\n}\n\n/**\n * Function to create a GL texture; from a GL API.\n *\n * @callback texture\n *\n * @param {string} type\n * @param {string} min\n * @param {string} mag\n * @param {string} wrap\n * @param {number} width\n * @param {number} height\n * @param {number} channels\n *\n * @returns {*} A GL texture, or an object serving that purpose.\n */\n\n/**\n * Function to create a GL framebuffer; from a GL API.\n *\n * @callback framebuffer\n *\n * @param {boolean} depth\n * @param {boolean} stencil\n * @param {number} width\n * @param {number} height\n * @param {array<texture>} color\n *\n * @returns {*} A GL framebuffer, or an object serving that purpose.\n */\n\n/**\n * @alias module:state.default\n * @function\n * @see {@link module:state.getState}\n */\nexport default getState;\n","/** @module size */\n\nimport map from '@epok.tech/fn-lists/map';\nimport range from '@epok.tech/fn-lists/range';\n\n/**\n * Returns the given width, for various parameters in order of precedence.\n *\n * @see [getState]{@link ./state.js#getState}\n *\n * @param {number|object<number>|array<number>} size Numeric size (width), or\n *     an object or array containing it.\n * @param {number} [size.width] Width; supersedes following arguments.\n * @param {number} [size.w] Alias of width; supersedes following arguments.\n * @param {number} [size.x] Alias of width; supersedes following arguments.\n * @param {object<number>|array<number>|number} [size.shape] The shape, of size\n *     (width) information; supersedes following arguments.\n * @param {object<number>|array<number>|number} [size.size] The size, of size\n *     (width) information; supersedes following arguments.\n * @param {number} [size.side] Width and height; supersedes following arguments.\n * @param {number} [size.0] Alias of width (index 0); supersedes giving `size`.\n *\n * @returns {number} The width as given in one of the expected ways.\n */\nexport const getWidth = ({ width, w, x, shape, size, side, 0: a }) =>\n    (width ?? w ?? x ??\n    (shape && getWidth(shape)) ?? (size && getWidth(size)) ??\n    side ?? a ?? size);\n\n/**\n * Returns the given height, for various parameters in order of precedence.\n *\n * @see [getState]{@link ./state.js#getState}\n *\n * @param {number|object<number>|array<number>} size Numeric size (height), or\n *     an object or array containing it.\n * @param {number} [size.height] Height; supersedes following arguments.\n * @param {number} [size.h] Height; supersedes following arguments.\n * @param {number} [size.y] Height; supersedes following arguments.\n * @param {object<number>|array<number>|number} [size.shape] The shape, of size\n *     (height) information; supersedes following arguments.\n * @param {object<number>|array<number>|number} [size.size] The size, of size\n *     (height) information; supersedes following arguments.\n * @param {number} [size.side] Width and height; supersedes following arguments.\n * @param {number} [size.1] Alias of height (index 1); supersedes giving `size`.\n *\n * @returns {number} The height as given in one of the expected ways.\n */\nexport const getHeight = ({ height, h, y, shape, size, side, 1: a }) =>\n    (height ?? h ?? y ??\n    (shape && getHeight(shape)) ?? (size && getHeight(size)) ??\n    side ?? a ?? size);\n\n/**\n * Gives the number of indexes to draw a full state, for various parameters.\n * Effectively equivalent to `gl_VertexID` in WebGL2.\n *\n * @see getWidth\n * @see getHeight\n * @see [getState]{@link ./state.js#getState}\n *\n * @param {number|object<number>|array<number>} size Numeric size information of\n *     data resources, or an object or array containing it; or width if\n *     height is given as a second parameter. See `getWidth` and `getHeight`.\n * @param {number} [size.count] The number of entries of each data-texture.\n *\n * @param {number} [height=1] The height of each data-texture.\n *\n * @returns {number} The number of indexes needed to draw a full state; each\n *     entry of a data-texture (its area, equivalent to `state.size.count`).\n */\nexport const countDrawIndexes = (size, height) =>\n    (size.count ?? getWidth(size)*getHeight(height ?? 1));\n\n/**\n * Gives the array of indexes needed to draw a full state.\n *\n * @param {number|object<number>} size The number of entries in each\n *     data-texture; or an object of size/type information on data resources.\n *\n * @returns {array<number>} An array of indexes for drawing all data-texture\n *     entries, numbered `0` to `size-1`.\n */\nexport const getDrawIndexes = (size) => map((_, i) => i,\n    range(Number.isInteger(size)? size : countDrawIndexes(size)), 0);\n\n/**\n * 2 raised to the given numeric power, or `null` if not given.\n *\n * @param {number} [scale] The power to raise 2 to.\n *\n * @returns 2 raised to the given numeric power, or `null` if not given.\n */\nexport const getScaled = (scale) => ((Number.isFinite(scale))? 2**scale : null);\n","/**\n * GPGPU update step.\n *\n * @module step\n */\n\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap';\n\nimport { macroPass } from './macros';\nimport { getUniforms } from './inputs';\nimport { vertDef, positionsDef, preDef } from './const';\n\nconst scale = { vec2: 0.5 };\n\nexport const cache = {\n    clearPass: { color: [0, 0, 0, 0], depth: 1, stencil: 0 },\n    copyFrame: { color: null },\n    copyImage: { copy: true }\n};\n\n/**\n * Convenience to get the currently active framebuffer.\n *\n * @see [getState]{@link ./state.js#getState}\n *\n * @param {object} state The GPGPU state.\n * @param {array<object>} state.passes Passes per step. See `getState`.\n * @param {number} [state.stepNow] The currently active state step, if any.\n * @param {number} [state.passNow] The currently active draw pass, if any.\n *\n * @returns {object} The active step's active pass object, if any.\n */\nexport const getPass = ({ passes: ps, stepNow: s, passNow: p }) =>\n    wrap(s, ps)?.[p];\n\n/**\n * Merged texture update, called upon each pass. Copies the active pass's output\n * into the merged texture, from each of its attachments one by one (to support\n * multiple draw buffers). Matches the lookup logic defined in `macroTaps`.\n *\n * @todo Update docs.\n *\n * @see https://stackoverflow.com/a/34160982/716898\n * @see getPass\n * @see [texture]{@link ./state.js#texture}\n * @see [getState]{@link ./state.js#getState}\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [macroTaps]{@link ./macros.js#macroTaps}\n *\n * @param {object} state A GPGPU state of the active pass.\n * @param {array<object<array<texture>,array<number>>>} state.passes Passes per\n *     step; the active one is found via `getPass`, with a `color` array of\n *     `texture`s, and a `map` array of numbers showing how the textures are\n *     grouped into the pass. See `getState` and `mapGroups`.\n * @param {merge} state.merge The merged texture to update.\n * @param {number} [state.stepNow] The currently active state step, if any.\n *\n * @returns {texture} The merged `texture`, updated by the active pass's output;\n *     matches the lookup logic defined in `macroTaps`.\n */\n export function updateMerge(state) {\n    const { color, map: pass } = getPass(state);\n    const { merge: { texture: to, copier }, stepNow: s, size } = state;\n    const f = copier?.framebuffer;\n\n    // Silent exit if there's not enough info ready now to perform the update.\n    if(!(to && f && color && pass && (s || (s === 0)))) { return to; }\n\n    const { steps: sl, shape: [w, h] } = size;\n    // Start at the top of the texture, move down row-per-step and wrap.\n    const y = (s%sl)*h;\n    const { copyFrame: cf, copyImage: ci } = cache;\n\n    each((c, i) =>\n            // Reusable framebuffer copies pass's pixels to the merged texture.\n            ((cf.color = c) && f(cf).use(() => to.subimage(ci, pass[i]*w, y))),\n        color);\n\n    return to;\n}\n\n/**\n * Creates a GPGPU update step function, for use with a GPGPU state object.\n *\n * @todo Optional transform feedback instead of GPGPU textures, where available\n *     (needs vertex draw, instead of texture draw).\n * @todo Make this fully extensible in state.\n * @todo @example\n *\n * @see buffer\n * @see command\n * @see subimage\n * @see onCommand\n * @see onStep\n * @see onPass\n * @see getPass\n * @see [getState]{@link ./state.js#getState}\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [macroPass]{@link ./macros.js#macroPass}\n * @see [getUniforms]{@link ./inputs.js#getUniforms}\n *\n * @param {object} api An API for GL resources.\n * @param {buffer} [api.buffer] Function to set up a GL buffer.\n * @param {clear} [api.clear] Function to clear GL output view or `framebuffer`.\n * @param {command} [api.command=api] Function to create a GL render pass, given\n *     options, to be called later with options.\n * @param {object} state The GPGPU state to use. See `getState` and `mapGroups`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<number>>} state.passes How textures are grouped into\n *     passes. See `mapGroups`.\n * @param {object} [state.merge] Any merged state texture; uses separate state\n *     textures if not given.\n * @param {object} [state.merge.texture] The GL texture object in `state.merge`.\n * @param {subimage} [state.merge.texture.subimage] A function to update part of\n *     the merge GL texture object data. See `subimage`.\n * @param {function} [state.merge.update] Hook to update, if any; if not given,\n *     `state.merge.texture` is updated here with active states upon each pass.\n *     The default merged texture is laid out as `[texture, step]` on the\n *     `[x, y]` axes, respectively; if other layouts are needed, this merge\n *     update hook can be given here to be used as-is, and the setup and\n *     lookup logic in their respective hooks. See `getState` and `macroTaps`.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n * @param {object} [state.step=to] The properties for the step GL command.\n * @param {string} [state.step.vert=vertDef] The step vertex shader GLSL; a\n *     simple flat screen shader if not given.\n * @param {string} state.step.frag The step fragment shader GLSL.\n * @param {object} [state.step.uniforms=getUniforms(state)] The step uniforms;\n *     modifies any given. See `getUniforms`.\n * @param {array<number>|buffer} [state.step.positions=positionsDef()] The step\n *     position attributes; 3 points of a large flat triangle if not given.\n * @param {number} [state.step.count=state.step.positions.length*scale.vec2] The\n *     number of elements/attributes to draw.\n * @param {object} [state.step.passCommand] Any GL command properties to mix in\n *     over the default ones here, and passed to `api.command`.\n * @param {string} [state.step.vert=vertDef] Vertex shader GLSL to add code to.\n * @param {array} [state.step.verts] Preprocesses and caches vertex GLSL code\n *     per-pass if given, otherwise processes it just-in-time before each pass.\n * @param {string} [state.step.frag] Fragment shader GLSL to add code to.\n * @param {array} [state.step.frags] Preprocesses and caches fragment GLSL code\n *     per-pass, otherwise processes it just-in-time before each pass.\n * @param {onStep} [onStep] Callback upon each step.\n * @param {onPass} [onPass] Callback upon each pass.\n * @param {object} [to=(state.step ?? {})] The results object; `state.step` or\n *     a new object if not given.\n *\n * @returns {object} `to` The given `to` object; containing a GPGPU update\n *     step function and related properties, to be passed a GPGPU state.\n * @returns {string} `to.vert` The given/new `state.vert` vertex shader GLSL.\n * @returns {string} `to.frag` The given `state.frag` fragment shader GLSL.\n * @returns {array.string} `[to.verts]` Any cached pre-processed vertex shaders\n *     GLSL, if `state.step.verts` was given.\n * @returns {array.string} `[to.frags]` Any cached pre-processed fragment\n *     shaders GLSL, if `state.step.verts` was enabled.\n * @returns {object} `to.uniforms` The given `state.uniforms`.\n * @returns {number} `to.count` The given/new `state.count`.\n * @returns {buffer} `to.positions` The given/new `state.positions`; via\n *     `api.buffer`.\n * @returns {command} `to.pass` A GL command function to draw a given pass; via\n *     `api.command`.\n * @returns {function} `to.run` The main step function, which performs all the\n *     draw pass GL commands for a given state step.\n */\nexport function getStep(api, state, to = (state.step ?? {})) {\n    const { buffer, clear, command = api } = api;\n    const { maps: { passes }, merge, pre: n = preDef, step = to } = state;\n    let { positions = positionsDef() } = step;\n\n    const {\n            passCommand, vert = vertDef, verts, frag, frags, uniforms,\n            count = positions.count ?? positions.length*scale.vec2\n        } = step;\n\n    to.vert = vert;\n    to.frag = frag;\n    to.uniforms = getUniforms(state, uniforms);\n    to.count = count;\n    positions = to.positions = buffer(positions);\n\n    // Whether to pre-process and keep the shaders for all passes in advance.\n    if(verts || frags) {\n        // Keep the current pass.\n        const { passNow } = state;\n\n        (verts && (to.verts = verts));\n        (frags && (to.frags = frags));\n\n        each((pass, p) => {\n                // Create macros for this pass in advance.\n                state.passNow = p;\n                // Specify the shader type, for per-shader macro hooks.\n                (verts && (verts[p] ??= macroPass(state, 'vert')+vert));\n                (frags && (frags[p] ??= macroPass(state, 'frag')+frag));\n            },\n            passes);\n\n        // Set the pass back to what it was.\n        state.passNow = passNow;\n    }\n\n    /** The render command describing a full GL state for a step. */\n    to.pass = command(to.passCommand = {\n        // Uses the full-screen vertex shader state by default.\n        vert(_, props) {\n            const { passNow: p, step } = props;\n            const { vert: v = vert, verts: vs = verts } = step;\n\n            // Specify the shader type, for per-shader macro hooks.\n            return vs?.[p] ?? macroPass(props, 'vert')+v;\n        },\n        frag(_, props) {\n            const { passNow: p, step } = props;\n            const { frag: f = frag, frags: fs = frags } = step;\n\n            // Specify the shader type, for per-shader macro hooks.\n            return fs?.[p] ?? macroPass(props, 'frag')+f;\n        },\n        attributes: {\n            [n+'position']: (_, { step: { positions: p = positions } }) => p\n        },\n        uniforms, count,\n        depth: { enable: false },\n        /** Note that this may draw to the screen if there's no active pass. */\n        framebuffer: (_, props = state) => getPass(props)?.framebuffer,\n        ...passCommand\n    });\n\n    /** Any merged texture's update, set up if not already given. */\n    (merge && (merge.update ??= updateMerge));\n\n    /** Executes the next step and all its passes. */\n    to.run = (props = state) => {\n        const { steps, step, merge } = props;\n        const stepNow = props.stepNow = (props.stepNow+1 || 0);\n        const mergeUpdate = merge?.update;\n        const { pass, onPass, onStep } = step;\n        const stepProps = (onStep?.(props, wrap(stepNow, steps)) ?? props);\n        const { clearPass } = cache;\n\n        each((p, i) => {\n                stepProps.passNow = i;\n\n                const passProps = onPass?.(stepProps, p) ?? stepProps;\n\n                // @todo Remove unnecessary `clear` call?\n                ((clearPass.framebuffer = getPass(passProps)?.framebuffer) &&\n                    clear(clearPass));\n\n                pass(passProps);\n                // Update any merged texture upon each pass.\n                mergeUpdate?.(passProps);\n            },\n            stepProps.maps.passes);\n\n        return props;\n    };\n\n    return to;\n}\n\n/**\n * Function to set up a GL buffer; from a GL API.\n *\n * @see getStep\n *\n * @callback buffer\n *\n * @param {array<number>|buffer} data The buffer data, as `array` or `buffer`.\n *\n * @returns {*} `buffer` A GL buffer to use for vertex attributes, or an object\n *     serving that purpose.\n * @returns {number} `[buffer.count]` The buffer element/vertex count.\n * @returns {number} `[buffer.length]` The length of the buffer data array.\n */\n\n/**\n * Function to clear GL output view or `framebuffer`; from a GL API.\n *\n * @see getStep\n * @see [framebuffer]{@link ./state.js#framebuffer}\n *\n * @callback clear\n *\n * @param {object} props The values to clear with.\n * @param {array<number>} [color] The values to clear any color buffers with.\n * @param {number} [depth] The value to clear any depth buffer with.\n * @param {number} [stencil] The value to clear any stencil buffer with.\n * @param {framebuffer} [framebuffer] Any `framebuffer` to clear; if not given,\n *     clears any active `framebuffer` or the view.\n */\n\n/**\n * Function to create a GL render pass, given options, to be called later with\n * options; from a GL API.\n *\n * @see getStep\n * @see [getUniforms]{@link ./step.js#getUniforms}\n * @see [framebuffer]{@link ./state.js#framebuffer}\n *\n * @callback command\n *\n * @param {object} passCommand The properties from which to create the GL render\n *     function for a given pass.\n * @param {function} [passCommand.vert] Function hook returning the vertex\n *     shader GLSL string for the next render pass.\n * @param {function} [passCommand.frag] Function hook returning the fragment\n *     shader GLSL string for the next render pass.\n * @param {object<buffer>} [passCommand.attributes] The vertex attributes for\n *     the next render pass.\n * @param {object<function>} [passCommand.uniforms] The uniform hooks for the\n *     given `props`. See `getUniforms`.\n * @param {number} [passCommand.count] The number of elements to draw.\n * @param {object<boolean,*>} [passCommand.depth] An object describing the depth\n *     settings for the next render pass; e.g: `passCommand.depth.enable` flag.\n * @param {function} [passCommand.framebuffer] Function hook returning the\n *     `framebuffer` to draw to in the next render pass. See `framebuffer`.\n *\n * @returns {function} Function to execute a GL render pass, with options, for\n *     a given render pass.\n */\n\n/**\n * Function of a GL `texture` to update part of it with new data; from a GL API.\n *\n * @see getStep\n * @see [texture]{@link ./state.js#texture}\n *\n * @callback subimage\n *\n * @param {texture} data The data to update into part of the calling `texture`.\n * @param {number} [x=0] Offset on the x-axis within the calling `texture`.\n * @param {number} [y=0] Offset on the y-axis within the calling `texture`.\n *\n * @returns {texture} The calling `texture`, with part updated part to `data`.\n */\n\n/**\n * Function hook to update on each pass.\n *\n * @see getStep\n *\n * @callback onCommand\n *\n * @param {object} context General or global properties.\n * @param {object} props Local properties (e.g: the GPGPU `state`).\n *\n * @returns {number|array<number>|*} A GL object to be bound via a GL API.\n */\n\n/**\n * Callback upon each step.\n *\n * @see getStep\n * @see [getState]{@link ./state.js#getState}\n * @see [framebuffer]{@link ./state.js#framebuffer}\n *\n * @callback onStep\n *\n * @param {object} [props] The `props` passed to `run`.\n * @param {array<framebuffer>} step The `framebuffer`s for `props.stepNow` from\n *     `props.steps`, where the next state step will be drawn. See `getState`.\n *\n * @returns {object} A `stepProps` to use for each of the step's next passes; or\n *     nullish to use the given `props`.\n */\n\n/**\n * Callback upon each pass.\n *\n * @see getStep\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n *\n * @callback onPass\n *\n * @param {object} [stepProps] The `props` passed to `run` via any `onStep`.\n * @param {array<number>} pass The maps for the next pass. See `mapGroups`.\n *\n * @returns {object} A `passProps` to use for the render `command` call; or\n *     nullish to use the given `stepProps`.\n */\n\n/** A wrapper around `updateMerge` that's handy for testing. */\nexport function updateMergeTest(state, update = updateMerge, after = 2) {\n    const { color, map: pass } = getPass(state);\n    const { merge, stepNow: s, passNow: p, size, maps } = state;\n    const { channels, copier } = merge;\n    const { steps: sl, shape: [w, h], merge: { shape: [wl, hl] } } = size;\n    const tl = maps.textures.length;\n    const y = (s%sl)*h;\n    const lc = y*tl*w;\n    const f = copier?.framebuffer;\n    const to = update(state);\n\n    console.warn(s, p, pass, ':');\n    console.warn('- l', 0, 'r', tl*w, 'w', w, 'wl', wl);\n    console.warn('- t', y, 'b', y+h, 'h', h, 'hl', hl);\n    console.warn('- c', channels, 'lc', lc*channels,\n        'rc', (lc+(w*h))*channels,\n        'sc', w*h*channels, 'slc', wl*hl*channels);\n\n    f({ color: to }).use(() =>\n        console.warn(Array.prototype.reduce.call(regl.read(),\n            (o, v, i) =>\n                o+((i)? ',\\t' : '')+\n                ((!i)? ''\n                : ((i%(tl*w*h*channels) === 0)?\n                    '\\n'+'='.repeat(100)+'step'+'='.repeat(100)+'\\n'\n                : ((i%(tl*w*channels) === 0)? '\\n'\n                : ((i%(w*channels) === 0)? ' || \\t'\n                : ((i%channels === 0)? ' / \\t' : '')))))+\n                (i*1e-3).toFixed(3).slice(2)+': '+((v)? v.toFixed(2) : '___'),\n            '\\n')));\n\n    if(s && after && (s%(sl*after) === 0)) { debugger; }\n\n    return to;\n}\n\n/**\n * @alias module:step.default\n * @function\n * @see {@link module:step.getStep}\n */\nexport default getStep;\n","/**\n * GPGPU GLSL preprocessor macros for each part of the state.\n *\n * Careful defining these, as each set of different macros will result in new\n * shaders and compilations, missing the cache here and in the rendering system.\n * So, as few unique macros as possible should be created for a given set of\n * inputs, for efficiency.\n *\n * @module macros\n *\n * @todo Redo examples, especially `macroTaps` and `macroPass`.\n * @todo Allow passes into or across textures; separate data and texture shapes.\n * @todo Make everything function-like macro taking variable names? Makes\n *     variable names explicit (e.g: `useSamples(samples)`, `useReads_0(reads)`,\n *     `tapStateBy(data, st, stepPast, 0)`, `tapState(data, st)`), but makes\n *     interconnections harder (e.g: `macroValues`, `macroOutput`, `macroTaps`);\n *     probably impossible without concatenation macro anyway, namespace is OK.\n */\n\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\nimport { type } from '@epok.tech/is-type/type';\n\nimport { preDef, boundDef } from './const';\n\n/** Escaped carriage return for easier reading. */\nexport const cr = ' \\\\\\n';\n/** The channels denoted for texture input/output. */\nexport const rgba = 'rgba';\n/** Simple cache for temporary or reusable objects. */\nexport const cache = {};\n/** Get cache keys without having to create new objects for `stringify`. */\nexport const id = (v) => JSON.stringify(v);\n\n// Keys for each part of the macro handling process available to hooks.\nexport const hooks = {\n    // The full set of macros.\n    macroPass: '',\n    // Each part of the set of macros.\n    macroValues: 'values', macroOutput: 'output',\n    macroSamples: 'samples', macroTaps: 'taps'\n};\n\n/**\n * Whether macros should be handled here; or the result of handling them by a\n * given named hook.\n * Allows macros of the given key to be handled by external named hooks, to\n * replace any part of the functionality here.\n *\n * @example\n *     // Macros to be handled here, the default.\n *     [hasMacros(), hasMacros({}), hasMacros({ macros: true })]]\n *         .every((m) => m === null);\n *\n *     // Macros to be handled here, with prefix `'pre_'` instead of `'preDef'`.\n *     hasMacros({ pre: 'pre_' }) === null;\n *\n *     // Macros not created.\n *     [hasMacros({ macros: false }), hasMacros({ macros: 0 })]\n *         .every((m) => m === '');\n *\n *     // Macros for 'a' handled by external static hook, not here.\n *     hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'a') === '//A\\n';\n *     // Macros for 'b' handled by external function hook, not here.\n *     hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'b') === '//B\\n';\n *     // Macros specified `on` a 'frag' not created.\n *     hasMacros({ macros: { frag: 0 } }, '', 'frag') === '';\n *     // Macros specified `on` a 'vert' handled here.\n *     hasMacros({ macros: { frag: 0, a_vert: 0 } }, '', 'vert') === null;\n *     // Macros for hook `'a'` specified `on` a 'vert' not created.\n *     hasMacros({ macros: { frag: 0, a_vert: 0 } }, 'a', 'vert') === '';\n *\n * @param {object} [props] The properties handling macros.\n * @param {string} [key] The name for which macros should be handled.\n * @param {string} [on=''] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [macros=props.macros] Whether and how\n *     GLSL preprocessor macros should be handled:\n *     - If it's false-y and non-nullish, no macros are handled here.\n *     - If it's a string, no macros are handled here as it's used instead.\n *     - If it's a function, it's passed the given `props`, `key`, `macros`, and\n *         the returned result is used.\n *     - If it's an object, any value at the given `key` is entered recursively,\n *         with the given `props`, `key`, and `macros[key]`.\n *     - Otherwise, returns `null` to indicate macros should be handled here.\n *\n * @returns {string|null|*} Either the result of the macros handled elsewhere,\n *     or `null` if macros should be handled here.\n */\nexport function hasMacros(props, key, on = '', macros = props?.macros) {\n    if((macros ?? true) === true) { return null; }\n    else if(!macros) { return ''; }\n\n    const t = type(macros);\n\n    return ((t === 'Function')? macros(props, key, on, macros)\n        : ((t === 'String')? macros\n        : (((macros instanceof Object) && (key in macros))?\n            hasMacros(props, key, on, macros[key])\n        : ((on)? hasMacros(props, ((key)? key+'_' : '')+on, '', macros)\n        :   null))));\n}\n\n/**\n * Generates an array-like declaration, as a GLSL syntax string compatible with\n * all versions.\n * Workaround for lack of `const` arrays in GLSL < 3.\n * Used as the base for the other GLSL version list types, ensuring a standard\n * basis while offering further language features where available.\n *\n * @example\n *     getGLSLListBase('float', 'list', [0, 1, 2], 'const'); // =>\n *     'const int list_l = 3;'+cr+\n *     'const int list_0 = float(0);'+cr+\n *     'const int list_1 = float(1);'+cr+\n *     'const int list_2 = float(2);';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array-like declaration string.\n */\nexport const getGLSLListBase = (type, name, a, qualify = '', init = type) =>\n    `const int ${name}_l = ${a.length};`+\n    reduce((s, v, i) =>\n            s+cr+(qualify && qualify+' ')+type+` ${name}_${i} = ${\n                init}(${v.join?.(', ') ?? v});`,\n        a, '');\n\n/**\n * Generates an array-like declaration, as a GLSL 1 syntax string.\n * Workaround for lack of `const` arrays in GLSL < 3.\n * Adds a lookup macro function; slow here, but standard.\n *\n * @example\n *     getGLSL1ListLike('float', 'list', [0, 1, 2], 'const'); // =>\n *     'const int list_l = 3;'+cr+\n *     'const int list_0 = float(0);'+cr+\n *     'const int list_1 = float(1);'+cr+\n *     'const int list_2 = float(2);\\n'+\n *     '// Index macro `list_i` (e.g: `list_i(0)`) may be slow, `+\n *         'use name (e.g: `list_0`) if possible.\\n'+\n *     '#define list_i(i) ((i == 2)? list_2 : ((i == 1)? list_1 : list_0))\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array-like declaration string.\n */\nexport const getGLSL1ListLike = (type, name, a, qualify = '', init = type) =>\n    getGLSLListBase(type, name, a, qualify, init)+'\\n'+\n    // @todo Would ideally use the concatenation macro, but can't in GLSL 1.\n    // `#define ${name}_i(i) ${name}_##i`;\n    `// Index macro \\`${name}_i\\` (e.g: \\`${name}_i(0)\\`) may be slow, `+\n        `use name (e.g: \\`${name}_0\\`) if possible.\\n`+\n    `#define ${name}_i(i) ${reduce((s, v, i) =>\n            ((i)? `((i == ${i})? ${name}_${i} : ${s})` : `${name}_${i}`),\n        a, '')}\\n`;\n\n/**\n * Generates an array declaration, as a GLSL 1 syntax string.\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @example\n *     getGLSL1ListArray('vec3', 'list', [[1, 0, 0], [0, 2, 0], [0, 0, 3]]);\n *     // =>\n *     'const int list_l = 3;'+cr+\n *     'vec3 list_0 = vec3(1, 0, 0);'+cr+\n *     'vec3 list_1 = vec3(0, 2, 0);'+cr+\n *     'vec3 list_2 = vec3(0, 0, 3);'+cr+\n *     'vec3 list[list_l];'+cr+\n *     'list[0] = list_0;'+cr+\n *     'list[1] = list_1;'+cr+\n *     'list[2] = list_2;\\n'+\n *     '#define list_i(i) list[i]\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array declaration string.\n */\nexport const getGLSL1ListArray = (type, name, a, qualify = '', init = type) =>\n    getGLSLListBase(type, name, a, qualify, init)+cr+\n    (qualify && qualify+' ')+type+` ${name}[${name}_l];`+\n    reduce((s, _, i) => s+cr+name+`[${i}] = ${name}_${i};`, a, '')+'\\n'+\n    `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Generates an array declaration, as a GLSL 3 syntax string.\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @example\n *     getGLSL3List('int', 'list', [0, 1, 2], 'const'); // =>\n *     'const int list_l = 3;'+cr+\n *     'const int list_0 = int(0);'+cr+\n *     'const int list_1 = int(1);'+cr+\n *     'const int list_2 = int(2);'+cr+\n *     'const int list[list_l] = int[list_l](list_0, list_1, list_2);\\n'+\n *     '#define list_i(i) list[i]\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 3 array declaration string.\n */\nexport const getGLSL3List = (type, name, a, qualify = '', init = type) =>\n    getGLSLListBase(type, name, a, qualify, init)+cr+\n    (qualify && qualify+' ')+type+` ${name}[${name}_l] = ${init}[${name}_l](${\n        reduce((s, _, i) => (s && s+', ')+name+'_'+i, a, '')});\\n`+\n    `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Creates a GLSL definition of an array, and initialises it with the given\n * values, type, and variable name.\n * The initialisation is valid GLSL 1.0 or greater syntax; but is written with\n * escaped new-lines so it may be used in a single-line - e.g: for preprocessor\n * macros.\n * For a `qualify` of `const` on any `glsl` less than `3`, falls back to using\n * non-array variables with the index appended to `name`, since `const` arrays\n * aren't supported before GLSL 3.0.\n *\n * @example\n *     getGLSLList('int', 'test', [0, 1]); // =>\n *     'const int test_l = 2;'+cr+\n *     'int test_0 = int(0);'+cr+\n *     'int test_1 = int(1);'+cr+\n *     'int test[test_l];'+cr+\n *     'test[0] = test_0;'+cr+\n *     'test[1] = test_1;\\n'+\n *     '#define test_i(i) test[i]\\n';\n *\n *     getGLSLList('ivec2', 'vecs', [[1, 0], [0, 1]], 'const', 3); // =>\n *     'const int vecs_l = 2;'+cr+\n *     'ivec2 vecs_0 = ivec2(1, 0);'+cr+\n *     'ivec2 vecs_1 = ivec2(0, 1);'+cr+\n *     'const ivec2 vecs[vecs_l] = ivec2[vecs_l](vecs_0, vecs_1);\\n'+\n *     '#define vecs_i(i) vecs[i]\\n';\n *\n *     getGLSLList('int', 'listLike', [0, 1], 'const', 1); // =>\n *     'const int listLike_l = 2;'+cr+\n *     'const int listLike_0 = int(0);'+cr+\n *     'const int listLike_1 = int(1);\\n'+\n *     '// Index macro `listLike_i` (e.g: `listLike_i(0)`) may be slow, `+\n *         'use name (e.g: `listLike_0`) if possible.\\n'+\n *     '#define listLike_i(i) ((i == 1)? listLike_1 : listLike_0)\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed (e.g: `const`).\n * @param {number} [glsl=1] The GLSL version to target, if specified.\n * @param {string} [init] A data-type initialiser.\n *\n * @returns {string} The GLSL (1 or 3) array or array-like declaration string.\n */\nexport const getGLSLList = (type, name, a, qualify = '', glsl = 1, init) =>\n    ((glsl >= 3)? getGLSL3List\n    : ((qualify.trim() === 'const')?\n        getGLSL1ListLike : getGLSL1ListArray))(type, name, a, qualify, init);\n\n/**\n * Defines the values within textures per-step, as GLSL preprocessor macros.\n * These macros define mappings from values to their textures and channels.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const maps = { values: [2, 4, 1], channelsMax: 4 };\n *\n *     // No optimisations - values not packed, single texture output per pass.\n *     const state = {\n *          pre: '', steps: 2,\n *          maps: mapGroups({ ...maps, buffersMax: 1, packed: 0 })\n *     };\n *\n *     macroValues(state); // =>\n *     '#define texture_0 0\\n'+\n *     '#define channels_0 rg\\n'+\n *     '\\n'+\n *     '#define texture_1 1\\n'+\n *     '#define channels_1 rgba\\n'+\n *     '\\n'+\n *     '#define texture_2 2\\n'+\n *     '#define channels_2 r\\n'+\n *     '\\n'+\n *     '#define textures 3\\n'+\n *     '#define passes 3\\n'+\n *     '#define stepsPast 1\\n'+\n *     '#define steps 2\\n'+\n *     '\\n';\n *\n *     // Automatically packed values - values across fewer textures/passes.\n *     state.maps = mapGroups({ ...maps, buffersMax: 1 });\n *     state.size = { count: 2**5 };\n *     macroValues(state); // =>\n *     '#define texture_1 0\\n'+\n *     '#define channels_1 rgba\\n'+\n *     '\\n'+\n *     '#define texture_0 1\\n'+\n *     '#define channels_0 rg\\n'+\n *     '\\n'+\n *     '#define texture_2 1\\n'+\n *     '#define channels_2 b\\n'+\n *     '\\n'+\n *     '#define count 32\\n'+\n *     '#define textures 2\\n'+\n *     '#define passes 2\\n'+\n *     '#define stepsPast 1\\n'+\n *     '#define steps 2\\n'+\n *     '\\n';\n *\n *     // Can bind more texture outputs per pass - values across fewer passes.\n *     state.maps = mapGroups({ ...maps, buffersMax: 4 });\n *     macroValues(state); // =>\n *     '#define texture_1 0\\n'+\n *     '#define channels_1 rgba\\n'+\n *     '\\n'+\n *     '#define texture_0 1\\n'+\n *     '#define channels_0 rg\\n'+\n *     '\\n'+\n *     '#define texture_2 1\\n'+\n *     '#define channels_2 b\\n'+\n *     '\\n'+\n *     '#define count 32\\n'+\n *     '#define textures 2\\n'+\n *     '#define passes 1\\n'+\n *     '#define stepsPast 1\\n'+\n *     '#define steps 2\\n'+\n *     '\\n';\n *\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled\n *     or prefixed. See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step.\n * @param {array<number>} state.maps.values How values of each data item are\n *     grouped into textures. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures The groupings of values\n *     into textures. See `mapGroups`.\n * @param {array} state.maps.passes Passes drawn per-step. See `mapGroups`.\n * @param {array|number} state.steps States drawn across frames. See `getState`.\n * @param {number} [state.bound=boundDef] How many steps are bound as outputs,\n *     unavailable as inputs.\n * @param {object} [state.size] Any size information about the GL resources.\n * @param {number} [state.size.count] The number of data entries per texture\n *     (the texture's area), if given. See `getState`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings from\n *     values to textures/channels.\n */\nexport function macroValues(state, on) {\n    const key = hooks.macroValues;\n    const hook = hasMacros(state, key, on);\n\n    if(hook !== null) { return hook; }\n\n    const { maps, steps, bound = boundDef, size, pre: n = preDef } = state;\n    const { values, textures, passes: { length: passesL } } = maps;\n    const stepsL = (steps.length ?? steps);\n    const count = size?.count;\n\n    const c = `${key}:${n},${bound},${id(values)},${id(textures)},${stepsL},${\n            passesL},${count}`;\n\n    return (cache[c] ??=\n        reduce((s, texture, t, _, i = 0) => reduce((s, v) => s+\n                    `#define ${n}texture_${v} ${t}\\n`+\n                    `#define ${n}channels_${v} ${\n                        rgba.slice(i, (i += values[v]))}\\n\\n`,\n                texture, s),\n            textures, '')+\n        ((count)? `#define count ${count}\\n` : '')+\n        `#define ${n}textures ${textures.length}\\n`+\n        `#define ${n}passes ${passesL}\\n`+\n        `#define ${n}stepsPast ${stepsL-bound}\\n`+\n        `#define ${n}steps ${stepsL}\\n`+\n        `#define ${n}bound ${bound}\\n\\n`);\n}\n\n/**\n * Defines the outputs being drawn to per-pass, as GLSL preprocessor macros.\n * These macros define mappings from values to their outputs, if bound.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const maps = { values: [2, 4, 1], channelsMax: 4 };\n *\n *     // No optimisations - values not packed, single texture output per pass.\n *     const state = {\n *          pre: '', passNow: 0,\n *          maps: mapGroups({ ...maps, buffersMax: 1, packed: 0 })\n *     };\n *\n *     macroOutput(state); // =>\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_0 0\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rg\\n'+\n *     '\\n';\n *\n *     // Automatically packed values - values across fewer textures/passes.\n *     state.maps = mapGroups({ ...maps, buffersMax: 1 });\n *     macroOutput(state); // =>\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_1 0\\n'+\n *     '#define attach_1 0\\n'+\n *     '#define output_1 gl_FragData[attach_1].rgba\\n'+\n *     '\\n';\n *\n *     // Next pass in this step.\n *     ++state.passNow;\n *     macroOutput(state); // =>\n *     '#define passNow 1\\n'+\n *     '\\n'+\n *     '#define bound_0 1\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rg\\n'+\n *     '\\n'+\n *     '#define bound_2 1\\n'+\n *     '#define attach_2 0\\n'+\n *     '#define output_2 gl_FragData[attach_2].b\\n'+\n *     '\\n';\n *\n *     // Can bind more texture outputs per pass - values across fewer passes.\n *     state.maps = mapGroups({ ...maps, buffersMax: 4 });\n *     state.passNow = 0;\n *     macroOutput(state); // =>\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_1 0\\n'+\n *     '#define attach_1 0\\n'+\n *     '#define output_1 gl_FragData[attach_1].rgba\\n'+\n *     '\\n'+\n *     '#define bound_0 1\\n'+\n *     '#define attach_0 1\\n'+\n *     '#define output_0 gl_FragData[attach_0].rg\\n'+\n *     '\\n'+\n *     '#define bound_2 1\\n'+\n *     '#define attach_2 1\\n'+\n *     '#define output_2 gl_FragData[attach_2].b\\n'+\n *     '\\n';\n *\n * @param {object} state Properties for generating the macros. See `getState`:\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *     See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `pre` if not given.\n * @param {number} state.passNow The index of the currently active pass.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<number>} state.maps.values How values of each data item may be\n *     grouped into textures across passes. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures The groupings of values\n *     into textures. See `mapGroups`.\n * @param {array<array<number>>} state.maps.passes The groupings of textures\n *     into passes. See `mapGroups`.\n *\n * @returns {string} The GLSL preprocessor macros for the pass's bound outputs.\n */\nexport function macroOutput(state, on) {\n    const key = hooks.macroOutput;\n    const hook = hasMacros(state, key, on);\n\n    if(hook !== null) { return hook; }\n\n    const { passNow: p, maps, pre: n = preDef } = state;\n    const { values, textures, passes } = maps;\n    const pass = passes[p];\n    const c = `${key}:${n},${p},${id(values)},${id(textures)},${id(passes)}`;\n\n    return (cache[c] ??=\n        `#define ${n}passNow ${p}\\n`+\n        reduce((s, texture, bound, _, i = 0) => reduce((s, v) => `${s}\\n`+\n                    `#define ${n}bound_${v} ${texture}\\n`+\n                    `#define ${n}attach_${v} ${bound}\\n`+\n                    `#define ${n}output_${v} gl_FragData[${n}attach_${v}].${\n                        rgba.slice(i, (i += values[v]))}\\n`,\n                textures[texture], s),\n            pass, '')+'\\n');\n}\n\n/**\n * Defines the texture samples/reads per-pass, as GLSL preprocessor macros.\n * The macros define the mapping between the values and those they derive from,\n * as step/texture locations in a `samples` list, and indexes to read values\n * from sampled data in a `reads` list (once sampled into a `data` list, as in\n * `macroTaps` or similar).\n * They're set up as function-like macros that may be called from the shader to\n * initialise the mappings arrays with a given name.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see macroTaps\n * @see hasMacros\n * @see getGLSLList\n * @see [mapFlow]{@link ./maps.js#mapFlow}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const values = [2, 4, 1];\n *     const derives = [2, , [[1, 0], true]];\n *     const maps = { values, derives, channelsMax: 4 };\n *\n *     // No optimisations - values not packed, single texture output per pass.\n *     const state =\n *         { pre: '', maps: mapFlow({ ...maps, buffersMax: 1, packed: 0 }) };\n *\n *     // USes the first pass by default.\n *     macroSamples(state); // =>\n *     '#define useSamples'+cr+\n *         'const int samples_l = 1;'+cr+\n *         'const ivec2 samples_0 = ivec2(0, 2);\\n'+\n *     '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *         'use name (e.g: `samples_0`) if possible.\\n'+\n *     '#define samples_i(i) samples_0\\n'+\n *     '\\n'+\n *     '#define useReads_0'+cr+\n *         'const int reads_0_l = 1;'+cr+\n *         'const int reads_0_0 = int(0);\\n'+\n *     '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+\n *         'use name (e.g: `reads_0_0`) if possible.\\n'+\n *     '#define reads_0_i(i) reads_0_0\\n'+\n *     '\\n';\n *\n *     // Next pass in this step - no derives, no samples nor reads.\n *     state.passNow = 1;\n *     macroSamples(state); // =>\n *     '';\n *\n *     // Next pass in this step.\n *     ++state.passNow;\n *     macroSamples(state); // =>\n *     '#define useSamples'+cr+\n *         'const int samples_l = 4;'+cr+\n *         'const ivec2 samples_0 = ivec2(1, 0);'+cr+\n *         'const ivec2 samples_1 = ivec2(0, 0);'+cr+\n *         'const ivec2 samples_2 = ivec2(0, 1);'+cr+\n *         'const ivec2 samples_3 = ivec2(0, 2);\\n'+\n *     '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *         'use name (e.g: `samples_0`) if possible.\\n'+\n *     '#define samples_i(i) ((i == 3)? samples_3 : ((i == 2)? samples_2 '+\n *         ': ((i == 1)? samples_1 : samples_0)))\\n'+\n *     '\\n'+\n *     '#define useReads_2'+cr+\n *         'const int reads_2_l = 4;'+cr+\n *         'const int reads_2_0 = int(0);'+cr+\n *         'const int reads_2_1 = int(1);'+cr+\n *         'const int reads_2_2 = int(2);'+cr+\n *         'const int reads_2_3 = int(3);\\n'+\n *     '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+\n *         'use name (e.g: `reads_2_0`) if possible.\\n'+\n *     '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *         ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n *     '\\n';\n *\n *     // Automatically packed values - values across fewer textures/passes.\n *     // Can bind more texture outputs per pass - values across fewer passes.\n *     // Also fewer samples where values share derives or textures.\n *     state.maps = mapGroups({ ...maps, buffersMax: 4 });\n *     state.passNow = 0;\n *     macroSamples(state); // =>\n *     '#define useSamples'+cr+\n *         'const int samples_l = 3;'+cr+\n *         'const ivec2 samples_0 = ivec2(0, 1);'+cr+\n *         'const ivec2 samples_1 = ivec2(1, 1);'+cr+\n *         'const ivec2 samples_2 = ivec2(0, 0);\\n'+\n *     '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *         'use name (e.g: `samples_0`) if possible.\\n'+\n *     '#define samples_i(i) '+\n *         '((i == 2)? samples_2 : ((i == 1)? samples_1 : samples_0))\\n'+\n *     '\\n'+\n *     '#define useReads_0'+cr+\n *         'const int reads_0_l = 1;'+cr+\n *         'const int reads_0_0 = int(0);\\n'+\n *     '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+\n *         'use name (e.g: `reads_0_0`) if possible.\\n'+\n *     '#define reads_0_i(i) reads_0_0\\n'+\n *     '\\n'+\n *     '#define useReads_2'+cr+\n *         'const int reads_2_l = 4;'+cr+\n *         'const int reads_2_0 = int(1);'+cr+\n *         'const int reads_2_1 = int(0);'+cr+\n *         'const int reads_2_2 = int(2);'+cr+\n *         'const int reads_2_3 = int(0);\\n'+\n *     '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+\n *         'use name (e.g: `reads_2_0`) if possible.\\n'+\n *     '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *         ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n *     '\\n';\n *\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *     See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {number} [state.passNow=0] The index of the currently active pass;\n *     uses the first pass if not given.\n * @param {object} state.maps  How `values` are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<array<number>>>} [state.maps.samples] The minimal set of\n *     texture samples to use. See `mapSamples`.\n * @param {array<array<array<number>>>} [state.maps.reads] The mappings from\n *     values to the corresponding `state.samples`. See `mapSamples`.\n * @param {number} [state.glsl=1] The GLSL language version. See `getGLSLList`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings for\n *     samples and reads, for each value.\n */\nexport function macroSamples(state, on) {\n    const key = hooks.macroSamples;\n    const hook = hasMacros(state, key, on);\n\n    if(hook !== null) { return hook; }\n\n    const { passNow: p = 0, maps, glsl, pre: n = preDef } = state;\n    const { samples, reads } = maps;\n    const passSamples = samples?.[p];\n    const passReads = reads?.[p];\n    const c = `${key}:${n},${p},${id(passSamples)},${id(passReads)},${glsl}`;\n\n    return (cache[c] ??=\n        ((!passSamples)? ''\n        :   `#define ${n}useSamples${cr+\n                getGLSLList('ivec2', n+'samples', passSamples, 'const', glsl)\n            }\\n`)+\n        ((!passReads)? ''\n        :   reduce((s, reads, v) =>\n                    `${s}#define ${n}useReads_${v}${cr+\n                        getGLSLList('int', n+'reads_'+v, reads, 'const', glsl)\n                    }\\n`,\n                passReads, '')));\n}\n\n/**\n * Defines the samples of textures per-pass, as GLSL preprocessor macros.\n * The macros define the minimal sampling of textures for the data the active\n * pass's values derive from; creates a `data` list containing the samples; the\n * `samples` list names are required, as created by `macroSamples` or similar.\n * Handles sampling states in a flat array of textures, or merged in one texture\n * (in both `sampler2D`, and `sampler3D`/`sampler2DArray` where supported).\n * Merging allows shaders to access past steps by non-constant lookups; e.g:\n * attributes cause \"sampler array index must be a literal expression\" on GLSL3\n * spec and some platforms (e.g: D3D); note these need texture repeat wrapping.\n * They're set up as function-like macros that may be called from the shader to\n * initialise the mappings arrays with a given name.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @todo Combine texture steps into one map would work around it, avoiding\n *     sampler arrays entirely; maybe usage-specific/heavy; could have 1\n *     framebuffer, copy pixels into its offset in 1 big past states texture\n *     (merge the current sampler array); analogous to GLSL3\n *     `sampler3D`/`sampler2DArray`.\n *\n * @see https://stackoverflow.com/a/60110986/716898\n * @see https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_2d_array.html\n * @see https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_3d.html\n *\n * @see macroSamples\n * @see hasMacros\n * @see getGLSLList\n * @see [mapFlow]{@link ./maps.js#mapFlow}\n * @see [getState]{@link ./state.js#getState}\n * @see [getUniforms]{@link ./inputs.js#getUniforms}\n *\n * @example\n *     const values = [2, 4, 1];\n *     const derives = [2, , [[1, 0], true]];\n *     const maps = { values, derives, channelsMax: 4 };\n *\n *     // No optimisations - values not packed, single texture output per pass.\n *     const state =\n *         { pre: '', maps: mapFlow({ ...maps, buffersMax: 1, packed: 0 }) };\n *\n *     // Uses the first pass by default.\n *     macroTaps(state); // =>\n *     '@todo';\n *\n *     // Next pass in this step - no derives, no samples nor reads.\n *     state.passNow = 1;\n *     macroTaps(state); // =>\n *     '';\n *\n *     // Next pass in this step.\n *     ++state.passNow;\n *     macroTaps(state); // =>\n *     '@todo';\n *\n *     // Automatically packed values - values across fewer textures/passes.\n *     // Can bind more texture outputs per pass - values across fewer passes.\n *     // Also fewer samples where values share derives or textures.\n *     state.maps = mapGroups({ ...maps, buffersMax: 4 });\n *     state.passNow = 0;\n *     macroTaps(state); // =>\n *     '@todo';\n *\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *     See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {number} [state.passNow=0] The index of the currently active pass;\n *     uses the first pass if not given.\n * @param {object} state.maps  How `values` are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<array<number>>>} [state.maps.samples] The minimal set of\n *     texture samples to use. See `mapSamples`.\n * @param {object} [state.merge] Any merged state texture; uses separate state\n *     textures if not given. See `getState`.\n * @param {number} [state.glsl=1] The GLSL language version. See `getGLSLList`.\n *\n * @returns {string} The GLSL preprocessor macros defining the minimal sampling\n *     of textures, to suit how states are stored (flat array of textures, or\n *     all merged into one texture) and supported GLSL language features.\n */\nexport function macroTaps(state, on) {\n    const key = hooks.macroTaps;\n    const hook = hasMacros(state, key, on);\n\n    if(hook !== null) { return hook; }\n\n    const { passNow: p = 0, maps, merge, glsl, pre: n = preDef } = state;\n    const passSamples = maps.samples?.[p];\n    const index = !merge;\n    const c = `${key}:${n},${p},${id(passSamples)},${index},${glsl}`;\n\n    if(c in cache) { return cache[c]; }\n\n    // Which texture sampling function is available.\n    const glsl3 = (glsl >= 3);\n    const texture = 'texture'+((glsl3)? '' : '2D');\n    // Short and common names for functions and parameters.\n    const f = n+'tapState';\n    const tap = '#define '+f;\n    // The full ordered parameters can be up to:\n    // (uv, states, stepNow, steps, textures, stepBy, textureBy)\n    const by = `stepBy, textureBy`;\n    // Aliases use default names for brevity, main functions offer more control.\n    const aka = `#define ${f}(uv)${cr+f}`;\n    const akaBy = `#define ${f}By(uv, ${by})${cr+f}`;\n    // The current `sample`, as `[step, texture]`.\n    const st = n+'samples_';\n    // Prefix for private temporary variables.\n    const t = '_'+n;\n    // A temporary array to pass to `getGLSLList`.\n    const tapsSamples = cache[key+'Samples'] ??= [];\n    const tapsL = tapsSamples.length = passSamples?.length ?? 0;\n\n    // The texture-sampling logic.\n    return (cache[c] = ((index)? '' : `#define ${n}mergedStates\\n\\n`)+\n        ((!tapsL)? ''\n        : ((index)?\n            /** Separate un-merged textures accessed by constant index. */\n            '// States in a `sampler2D[]`; looks up 1D index and 2D `uv`; '+cr+\n                'past steps go later in the list.\\n'+\n            `// Pass constant array index values; \\`textures\\`.\\n`+\n            `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n            tap+`s(uv, states, textures)`+cr+\n                // Compute before the loop for lighter work.\n                `const int ${t}tlI = int(textures);`+cr+\n                `vec2 ${t}uvI = vec2(uv);`+cr+\n                // Sample into the `data` output list.\n                getGLSLList('vec4', n+'data',\n                    map((_, i) => texture+'(states['+\n                                // Offset step, texture.\n                                `(int(${st+i}.s)*${t}tlI)+int(${st+i}.t)`+\n                            `], ${t}uvI)`,\n                        passSamples, tapsSamples),\n                    '', glsl)+'\\n'+\n            '// States may also be sampled by shifted step/texture.\\n'+\n            `// Pass constant array index values; \\`textures, ${by}\\`.\\n`+\n            `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n            tap+`sBy(uv, states, textures, ${by})`+cr+\n                // Compute before the loop for lighter work.\n                `const int ${t}tlIB = int(textures);`+cr+\n                `ivec2 ${t}byIB = ivec2(${by});`+cr+\n                `vec2 ${t}uvIB = vec2(uv);`+cr+\n                // Sample into the `data` output list.\n                getGLSLList('vec4', n+'data',\n                    map((_, i) => texture+'(states['+\n                                // Offset step.\n                                `((int(${st+i}.s)+${t}byIB.s)*${t}tlIB)+`+\n                                // Offset texture.\n                                `int(${st+i}.t)+${t}byIB.t`+\n                            `], ${t}uvIB)`,\n                        passSamples, tapsSamples),\n                    '', glsl)+'\\n'+\n            '// Preferred aliases: index suits states array constant access.\\n'+\n            aka+`s(uv, ${n}states, ${n}textures)\\n`+\n            akaBy+`sBy(uv, ${n}states, ${n}textures, ${by})\\n`\n        :   /** Merged 2D texture. */\n            '// States merged to a `sampler2D`, scales 2D `uv` over '+\n                '`[textures, steps]`.\\n'+\n            '// Step from now into the past going upwards in the texture.\\n'+\n            `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n            tap+`2(uv, states, stepNow, steps, textures)`+cr+\n                // Compute before the loop for lighter work.\n                `vec2 ${t}l2 = vec2(textures, steps);`+cr+\n                `vec2 ${t}uv2 = vec2(uv)/${t}l2;`+cr+\n                // Steps advance in reverse, top-to-bottom.\n                `vec2 ${t}s2 = vec2(1, -1)/${t}l2;`+cr+\n                // Offset texture, step.\n                // Each step stored in texture top downward at `-stepNow`.\n                // Most recent step to look up is at `-stepNow+1`.\n                `vec2 ${t}i2 = vec2(0, 1)-vec2(0, stepNow);`+cr+\n                // Sample into the `data` output list.\n                getGLSLList('vec4', n+'data',\n                    // Would repeat wrap; but WebGL1 needs power-of-2.\n                    map((_, i) => texture+`(states, fract(${t}uv2+fract(`+\n                                // Offset texture, step.\n                                `(vec2(${st+i}).ts+${t}i2)*${t}s2)))`,\n                            passSamples, tapsSamples),\n                        '', glsl)+'\\n'+\n            '// States may also be sampled by shifted step/texture.\\n'+\n            `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n            tap+`2By(uv, states, stepNow, steps, textures, ${by})`+cr+\n                // Compute before the loop for lighter work.\n                `vec2 ${t}l2B = vec2(textures, steps);`+cr+\n                `vec2 ${t}uv2B = vec2(uv)/${t}l2B;`+cr+\n                // Steps advance in reverse, top-to-bottom.\n                `vec2 ${t}s2B = vec2(1, -1)/${t}l2B;`+cr+\n                // Offset texture, step.\n                // Each step stored in texture top downward at `-stepNow`.\n                // Most recent step to look up is at `-stepNow+1`.\n                `vec2 ${t}i2B = vec2(${by}).ts+vec2(0, 1)-vec2(0, stepNow);`+cr+\n                // Sample into the `data` output list.\n                getGLSLList('vec4', n+'data',\n                    // Would repeat wrap; but WebGL1 needs power-of-2.\n                    map((_, i) => texture+`(states, fract(${t}uv2B+fract(`+\n                                // Offset texture, step.\n                                `(vec2(${st+i}).ts+${t}i2B)*${t}s2B)))`,\n                            passSamples, tapsSamples),\n                        '', glsl)+'\\n'+\n            ((!glsl3)?\n                '// Preferred aliases: 2D suits merged texture in GLSL < 1.\\n'+\n                aka+`2(uv, ${n}states, ${n}stepNow, ${n}steps, ${n}textures)\\n`+\n                akaBy+`2By(uv, ${\n                    n}states, ${n}stepNow, ${n}steps, ${n}textures, ${by})\\n`\n            :   /**\n                 * Merged 3D texture types, supported from GLSL3.\n                 * @todo Check and finish this.\n                 */\n                '// States merged to `sampler3D` or `sampler2DArray`; 2D `uv` '+\n                    'to 3D; scales `x` over `textures`, `z` over `steps` as:\\n'+\n                '// - `sampler3D`: the number of steps; depth, `[0, 1]`.\\n'+\n                '// - `sampler2DArray`: `1` or less; layer, `[0, steps-1]`.\\n'+\n                `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n                tap+`3(uv, states, stepNow, steps, textures)`+cr+\n                    // @see `...2()` above.\n                    // Compute before the loop for lighter work.\n                    `vec2 ${t}l3 = vec2(textures, steps);`+cr+\n                    `vec2 ${t}uv3 = vec2(uv)/${t}l3;`+cr+\n                    // Offset texture.\n                    `float ${t}sx3 = 1.0/${t}l3.x;`+cr+\n                    // Offset step.\n                    `float ${t}s3 = -float(stepNow);`+cr+\n                    `float ${t}sz3 = -1.0/${t}l3;`+cr+\n                    // Sample into the `data` output list.\n                    getGLSLList('vec4', n+'data',\n                        // Would repeat wrap; but `sampler2DArray` layer can't.\n                        map((_, i) => texture+'(states, fract(vec3('+\n                                // Offset texture.\n                                `${t}uv3.x+(float(${st+i}.t)*${t}sx3), `+\n                                `${t}uv3.y, `+\n                                // Offset step: `sampler3D` depth, `[0, 1]`;\n                                // `sampler2DArray` layer, `[0, steps-1]`.\n                                `(float(${st+i}.s)+${t}s3)*${t}sz3)))`,\n                            passSamples, tapsSamples),\n                        '', glsl)+'\\n'+\n                '// States may also be sampled by shifted step/texture.\\n'+\n                `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n                tap+`3By(uv, states, stepNow, steps, textures, ${by})`+cr+\n                    // @see `...2By()` above.\n                    // Compute before the loop for lighter work.\n                    `vec2 ${t}l3B = vec2(textures, steps);`+cr+\n                    `vec2 ${t}uv3B = (vec2(uv)+vec2(textureBy, 0))/${t}l3B;`+cr+\n                    // Offset texture.\n                    `float ${t}sx3B = 1.0/${t}l3B.x;`+cr+\n                    // Offset step.\n                    `float ${t}s3B = float(stepBy)-float(stepNow);`+cr+\n                    `float ${t}sz3B = -1.0/${t}l3B;`+cr+\n                    // Sample into the `data` output list.\n                    getGLSLList('vec4', n+'data',\n                        // Would repeat wrap; but `sampler2DArray` layer can't.\n                        map((_, i) => texture+'(states, fract(vec3('+\n                                // Offset texture.\n                                `${t}uv3B.x+(float(${st+i}.t)*${t}sx3B), `+\n                                `${t}uv3B.y, `+\n                                // Offset step: `sampler3D` depth, `[0, 1]`;\n                                // `sampler2DArray` layer, `[0, steps-1]`.\n                                `(float(${st+i}.s)+${t}s3B)*${t}sz3B)))`,\n                            passSamples, tapsSamples),\n                        '', glsl)+'\\n'+\n                '// Preferred aliases: 3D suits merged texture in GLSL 3+.\\n'+\n                aka+`3(uv, ${n}states, ${n}stepNow, ${n}steps, ${n}textures)\\n`+\n                akaBy+`3By(uv, ${\n                    n}states, ${n}stepNow, ${n}steps, ${n}textures, ${by})\\n`))+\n        '\\n'));\n}\n\n/**\n * Defines all GLSL preprocessor macro values, texture samples, and outputs for\n * the active pass.\n * The macros define the mapping between the active values, their textures and\n * channels, bound outputs, and other macros useful for a draw pass.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see macroValues\n * @see macroOutput\n * @see macroTaps\n * @see macroSamples\n * @see [mapFlow]{@link ./maps.js#mapFlow}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const values = [2, 4, 1];\n *     const derives = [2, , [[1, 0], true]];\n *\n *     // Automatically packed values - values across fewer textures/passes.\n *     // Only a single texture output per pass - values across more passes.\n *     const state = {\n *         passNow: 0, steps: 2, size: { count: 2**5 },\n *         maps: mapFlow({ values, derives, channelsMax: 4, buffersMax: 1 })\n *     };\n *\n *     macroPass(state); // =>\n *     '#define gpgpu_texture_1 0\\n'+\n *     '#define gpgpu_channels_1 rgba\\n'+\n *     '\\n'+\n *     '#define gpgpu_texture_0 1\\n'+\n *     '#define gpgpu_channels_0 rg\\n'+\n *     '\\n'+\n *     '#define gpgpu_texture_2 1\\n'+\n *     '#define gpgpu_channels_2 b\\n'+\n *     '\\n'+\n *     '#define count 32\\n'+\n *     '#define gpgpu_textures 2\\n'+\n *     '#define gpgpu_passes 2\\n'+\n *     '#define gpgpu_stepsPast 1\\n'+\n *     '#define gpgpu_steps 2\\n'+\n *     '\\n'+\n *     '#define gpgpu_passNow 0\\n'+\n *     '\\n'+\n *     '#define gpgpu_bound_1 0\\n'+\n *     '#define gpgpu_attach_1 0\\n'+\n *     '#define gpgpu_output_1 gl_FragData[gpgpu_attach_1].rgba\\n'+\n *     '\\n';\n *\n *     // Next pass and extra step.\n *     ++state.steps;\n *     ++state.passNow;\n *     state.pre = '';\n *     macroPass(state); // =>\n *     '#define texture_1 0\\n'+\n *     '#define channels_1 rgba\\n'+\n *     '\\n'+\n *     '#define texture_0 1\\n'+\n *     '#define channels_0 rg\\n'+\n *     '\\n'+\n *     '#define texture_2 1\\n'+\n *     '#define channels_2 b\\n'+\n *     '\\n'+\n *     '#define count 32\\n'+\n *     '#define textures 2\\n'+\n *     '#define passes 2\\n'+\n *     '#define stepsPast 2\\n'+\n *     '#define steps 3\\n'+\n *     '\\n'+\n *     '#define passNow 1\\n'+\n *     '\\n'+\n *     '#define bound_0 1\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rg\\n'+\n *     '\\n'+\n *     '#define bound_2 1\\n'+\n *     '#define attach_2 0\\n'+\n *     '#define output_2 gl_FragData[attach_2].b\\n'+\n *     '\\n'+\n *     '#define useSamples'+cr+\n *         'const int samples_l = 3;'+cr+\n *         'const ivec2 samples_0 = ivec2(0, 1);'+cr+\n *         'const ivec2 samples_1 = ivec2(1, 1);'+cr+\n *         'const ivec2 samples_2 = ivec2(0, 0);\\n'+\n *     '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *         'use name (e.g: `samples_0`) if possible.\\n'+\n *     '#define samples_i(i)'+cr+\n *         '((i == 2)? samples_2 : ((i == 1)? samples_1 : samples_0))\\n'+\n *     '\\n'+\n *     '#define useReads_0'+cr+\n *         'const int reads_0_l = 1;'+cr+\n *         'const int reads_0_0 = int(0);\\n'+\n *     '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+\n *         'use name (e.g: `reads_0_0`) if possible.\\n'+\n *     '#define reads_0_i(i) reads_0_0\\n'+\n *     '\\n'+\n *     '#define useReads_2'+cr+\n *         'const int reads_2_l = 4;'+cr+\n *         'const int reads_2_0 = int(1);'+cr+\n *         'const int reads_2_1 = int(0);'+cr+\n *         'const int reads_2_2 = int(2);'+cr+\n *         'const int reads_2_3 = int(0);\\n'+\n *     '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+\n *         'use name (e.g: `reads_2_0`) if possible.\\n'+\n *     '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *         ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n *     '\\n'+\n *     '// States in a `sampler2D[]`; looks up 1D index and 2D `uv`.\\n'+\n *     '@todo';\n *\n * @param {object} state Properties for generating the macros. See `getState`\n *     and `mapGroups`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings for\n *     values, textures, channels, bound outputs of the active pass, etc. See\n *     `macroValues`, `macroOutput`, and `macroSamples`.\n */\nexport const macroPass = (state, on) =>\n    (hasMacros(state, hooks.macroPass, on) ??\n        macroValues(state)+macroOutput(state)+\n        macroSamples(state)+macroTaps(state));\n\n/**\n * @alias module:macros.default\n * @function\n * @see {@link module:macros.macroPass}\n */\nexport default macroPass;\n","const [{ length: start}, { length: end }] = '[object {type}]'.split('{type}');\n\n/**\n * Gives the type of a given input.\n *\n * @see https://stackoverflow.com/a/17772086/716898\n *\n * @param {*} x Any input to test.\n *\n * @returns {string} The type of `x`.\n */\nexport const type = (x) => toString.call(x).slice(start, -end);\n\nexport default type;\n","/**\n * GPGPU inputs (uniforms, attributes, indexes, etc).\n *\n * @module inputs\n */\n\nimport { setC2, setC4 } from '@thi.ng/vectors/setc';\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap';\n\nimport { boundDef, preDef } from './const';\n\n/**\n * Uniform inputs for GPGPU calls, such as in `getStep`.\n * Uniforms are defined as callback hooks called at each pass, using properties\n * from given global context and local state objects, allowing different APIs or\n * author-defined hooks.\n * Handles inputs of states as arrays of textures, or merged in one texture;\n * for arrays of textures, textures are arranged here on each step so GLSL can\n * dynamically access the flattened array of textures at by constant step index;\n * otherwise the single merged texture is bound once, and GLSL can use dynamic\n * current step to access states by texture sampling.\n *\n * @example\n *     const state =\n *         { pre: '', steps: 2, maps: mapFlow({ values: [1, 2, 3] }) };\n *\n *     getUniforms(getState({}, state)); // =>\n *     {\n *         stepNow: (context, state) => {},\n *         dataShape: (context, state) => {},\n *         viewShape: (context, state) => {},\n *         // Data textures kept separate in a `sampler2D[]`.\n *         // Data textures for the 1st step ago not bound as an output.\n *         'states[0]': (context, state) => {},\n *         'states[1]': (context, state) => {}\n *     };\n *\n *     getUniforms(getState({}, { ...state, steps: 3 })); // =>\n *     {\n *         stepNow: (context, state) => {},\n *         dataShape: (context, state) => {},\n *         viewShape: (context, state) => {},\n *         // Data textures kept separate in a `sampler2D[]`.\n *         // Data textures for the 1st step ago not bound as an output.\n *         'states[0]': (context, state) => {},\n *         'states[1]': (context, state) => {}\n *         // Data textures for the 2nd step ago not bound as an output.\n *         'states[2]': (context, state) => {},\n *         'states[3]': (context, state) => {}\n *     };\n *\n *     getUniforms(getState({}, { ...state, merge: true })); // =>\n *     {\n *         stepNow: (context, state) => {},\n *         dataShape: (context, state) => {},\n *         viewShape: (context, state) => {},\n *         // All states merged into one data texture upon every pass; for\n *         // `sampler2D`, or `sampler3D` or `sampler2DArray` where supported.\n *         states: (context, state) => {}\n *     };\n *\n * @see getUniform\n * @see [getStep]{@link ./step.js#getStep}\n * @see [getState]{@link ./state.js#getState}\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [macroSamples]{@link ./macros.js#macroSamples}\n * @see [macroTaps]{@link ./macros.js#macroTaps}\n *\n * @param {object} state The GPGPU state to use. See `getState` and `mapGroups`.\n * @param {string} [state.pre=preDef] Namespace prefix; `preDef` if not given.\n * @param {object} [state.size] Size information of the `state`. See `getState`.\n * @param {array<number>} [state.size.shape] The data's shape. See `getState`.\n * @param {array|number} state.steps The array of steps, or number of steps.\n *     See `getState`.\n * @param {object} [state.merge] Any merged state texture; uses separate state\n *     textures if not given. See `getState`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures How values are grouped into\n *     textures. See `mapGroups`.\n * @param {number} [state.bound=boundDef] Number of steps bound to output,\n *     cannot be input; for platforms forbidding read/write of same buffer.\n * @param {object} [to=(state.uniforms ?? {})] The object to contain the\n *     uniforms; `state.uniforms` or a new object if not given.\n *\n * @returns {object<number,array<number>,*,getUniform>} `to` The uniform hooks\n *     for the given `state`. Each is a static number or array of numbers; or a\n *     GL object such as a texture; or a `getUniform` function returning one, to\n *     be called on each pass.\n */\nexport function getUniforms(state, to = (state.uniforms ?? {})) {\n    const { pre: n = preDef, steps, maps, bound = boundDef } = state;\n    const stepsL = steps.length ?? steps;\n    const { textures } = maps;\n    const texturesL = textures.length;\n    const dataShape = [];\n    const viewShape = [];\n\n    to[n+'stepNow'] = (_, { stepNow: s }) => s;\n\n    to[n+'dataShape'] = (_, { size: s }) => ((!(s?.shape))? set4(dataShape)\n        :   setC4(dataShape, ...s.shape, ...(s.merge?.shape ?? s.shape)));\n\n    to[n+'viewShape'] = ({ drawingBufferWidth: w, drawingBufferHeight: h }) =>\n        setC2(viewShape, w, h);\n\n    /** Past steps, all merged into one texture. */\n    to[n+'states'] = (_, { merge: m }) => m?.texture;\n\n    /**\n     * Past steps, each some steps `ago`, from the current active step at `0`\n     * `[0,... stepsL-1-bound]`.\n     */\n    const addTextures = (ago) =>\n        // Hooks to pull a given texture from the active pass `props`.\n        // GLSL dynamically accesses array of textures by a constant index.\n        each((_, t) => to[n+`states[${(ago*texturesL)+t}]`] =\n                (_, { stepNow: s, bound: b = bound, merge: m, textures: ts }) =>\n                    (m || wrap(s-b-ago, ts)?.[t]?.texture),\n            textures);\n\n    // Flatten all input textures, as uniforms are stored in flat arrays.\n    for(let ago = 0, pl = stepsL-bound; ago < pl; ++ago) { addTextures(ago); }\n\n    return to;\n}\n\n/**\n * Function hook to update a uniform on each pass.\n *\n * @see getUniforms\n * @see [getState]{@link ./state.js#getState}\n *\n * @callback getUniform\n *\n * @param {object} context General or global properties.\n * @param {number} context.drawingBufferWidth Current view width in pixels.\n * @param {number} context.drawingBufferHeight Current view height in pixels.\n * @param {object} props Local properties (e.g: the GPGPU `state`).\n * @param {number} props.stepNow The current step of the GPGPU `state`.\n * @param {number} props.bound Number of steps bound to output, cannot be input.\n * @param {object} props.merge Object containing merged texture.\n * @param {*} props.merge.texture Merged texture.\n * @param {array<array<object<*>>>} props.textures Textures per step, as arrays\n *     of objects with a `texture` property. See `getState`.\n *\n * @returns {number|array<number>|*} A GL uniform to be bound via a GL API.\n */\n\n/**\n * @alias module:inputs.default\n * @function\n * @see {@link module:inputs.getUniforms}\n */\nexport default getUniforms;","export const setC2 = (out, x, y) => (!out && (out = []), (out[0] = x), (out[1] = y), out);\nexport const setC3 = (out, x, y, z) => (!out && (out = []), (out[0] = x), (out[1] = y), (out[2] = z), out);\nexport const setC4 = (out, x, y, z, w) => (!out && (out = []),\n    (out[0] = x),\n    (out[1] = y),\n    (out[2] = z),\n    (out[3] = w),\n    out);\nexport const setC6 = (out, a, b, c, d, e, f) => (!out && (out = []),\n    (out[0] = a),\n    (out[1] = b),\n    (out[2] = c),\n    (out[3] = d),\n    (out[4] = e),\n    (out[5] = f),\n    out);\nexport const setC = (out, ...xs) => {\n    !out && (out = []);\n    for (let i = 0, n = xs.length; i < n; i++) {\n        out[i] = xs[i];\n    }\n    return out;\n};\n","/**\n * How many vertexes for a given form to cover each entry's steps of state.\n * If 2 states or form are given, gives a setup of pairs for a line segment\n * between each entry's steps of state using `gl.LINES`.\n * If fewer than 2 states or form are given, gives a setup for a point at each\n * entry's steps of state using `gl.POINTS`.\n * Possibly useful for other forms too.\n * Corresponds to the indexing logic in the `indexForms` GLSL function.\n *\n * @module index-forms\n *\n * @see [readme]{@link ./readme.md}\n * @see [indexForms]{@link ./index-states.glsl#indexForms}\n * @see [indexForms]{@link ./index-entries.glsl#indexForms}\n * @see `gl.LINES` at https://webglfundamentals.org/webgl/lessons/webgl-points-lines-triangles.html\n *\n * @param {number} [states=1] How many steps of state each entry has.\n * @param {number} [form=2] How many steps of state each form covers.\n * @param {number} [entries=1] How many entries, if any; result to be multiplied\n *     externally if not given.\n *\n * @returns {number} The number of vertexes needed for the given `form` to cover\n *     all steps of `states`; over all `entries` if given, to be multiplied\n *     externally if not given.\n */\nexport const indexForms = (states = 1, form = 2, entries = 1) =>\n    Math.max(1, states-form+1)*form*entries;\n\n/**\n * @alias module:index-forms.default\n * @function\n * @see {@link module:index-forms.indexForms}\n */\nexport default indexForms;\n","/**\n * The update step for a GPGPU particle simulation.\n * Requires setup with preprocessor macros - see `macroPass`.\n * Executed in one or more passes; each chunk depending on a `gpgpu` macro may\n * be combined with others into one pass or separated into its own pass; `gpgpu`\n * preprocessor macros control the combination according to which `values` are\n * currently bound for `output` to the next `state`.\n *\n * @see [getStep]{@link ../../step.js#getStep}\n * @see [macroPass]{@link ../../macros.js#macroPass}\n */\n\n#ifdef GL_EXT_draw_buffers\n    #extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\n\n// Setting up the macros and aliases `gl-gpgpu` provides.\n\n// Note that these `texture_i`/`channels_i`/`reads_i_j` indexes correspond to a\n// value at that index in the `values`/`derives` arrays provided to `gl-gpgpu`;\n// they are defined here to match that arrangement.\n\n// The texture channels each of the `values` is stored in.\n#define positionChannels channels_0\n#define motionChannels channels_1\n#define lifeChannels channels_2\n\n// Set up sampling logic via `gl-gpgpu` macro.\nuseSamples\n\n// Set up minimal texture reads logic; only read what a value with a currently\n// bound output `derives` from other `values` for its next state.\n// See `derives` for indexing `reads_${bound value index}_${derives index}`.\n#ifdef output_0\n    #define positionOutput output_0\n    useReads_0\n    #define positionReadPosition0 reads_0_0\n    #define positionReadPosition1 reads_0_1\n    #define positionReadMotion reads_0_2\n    #define positionReadLife reads_0_3\n#endif\n#ifdef output_1\n    #define motionOutput output_1\n    useReads_1\n    #define motionReadMotion reads_1_0\n    #define motionReadLife reads_1_1\n    #define motionReadPosition reads_1_2\n#endif\n#ifdef output_2\n    #define lifeOutput output_2\n    useReads_2\n    #define lifeReadLifeLast reads_2_0\n    #define lifeReadLife1 reads_2_1\n#endif\n\n// The main shader.\n\n// States from `gl-gpgpu`; in separate textures or merged.\n#ifdef mergedStates\n    uniform sampler2D states;\n#else\n    uniform sampler2D states[stepsPast*textures];\n#endif\n\n// The current step from `gl-gpgpu`.\nuniform float stepNow;\n\n// Custom inputs for this demo.\n\nuniform float dt0;\nuniform float dt1;\nuniform float loop;\n// // A particle's lifetime range, and whether it's allowed to respawn.\nuniform vec3 lifetime;\nuniform float useVerlet;\nuniform float epsilon;\nuniform float moveCap;\nuniform vec2 scale;\nuniform vec2 spout;\nuniform vec3 source;\n// Sink position, and universal gravitational constant.\nuniform vec4 sink;\n// Constant acceleration due to gravity; and whether to use it, uses\n// sink if not.\nuniform vec4 g;\n// uniform vec3 drag;\n\nvarying vec2 uv;\n\n#pragma glslify: map = require(glsl-map)\n#pragma glslify: le = require(glsl-conditionals/when_le)\n#pragma glslify: random = require(glsl-random)\n\n#ifdef positionOutput\n    // @todo Try Velocity Verlet integration.\n    #pragma glslify: verlet = require(@epok.tech/glsl-verlet/p-p-a)\n#endif\n\n#if defined(positionOutput) || defined(motionOutput)\n    #pragma glslify: tau = require(glsl-constants/TWO_PI)\n\n    // @see https://observablehq.com/@rreusser/equally-distributing-points-on-a-sphere\n    vec3 randomOnSphere(float randomAngle, float randomDepth) {\n        float a = randomAngle*tau;\n        float u = (randomDepth*2.0)-1.0;\n\n        return vec3(sqrt(1.0-(u*u))*vec2(cos(a), sin(a)), u);\n    }\n#endif\n\n// Drag acceleration, constrained within the given velocity.\n// @see https://en.wikipedia.org/wiki/Verlet_integration#Algorithmic_representation\n// vec3 dragAcc(vec3 velocity, vec3 drag) {\n//     vec3 l = abs(velocity);\n\n//     return clamp(-0.5*sign(velocity)*dot(velocity, velocity)*drag, -l, l);\n// }\n\nvoid main() {\n    // Sample the desired state values - creates the `data` array.\n    tapState(uv)\n\n    // Read values.\n\n    #ifdef positionOutput\n        vec3 position0 = data[positionReadPosition0].positionChannels;\n    #endif\n\n    // If reads all map to the same value sample, any of them will do.\n    #if defined(positionOutput) || defined(motionOutput)\n        #if defined(positionOutput)\n            #define readMotion positionReadMotion\n            #define readPosition positionReadPosition1\n        #elif defined(motionOutput)\n            #define readMotion motionReadMotion\n            #define readPosition motionReadPosition\n        #endif\n\n        vec3 position1 = data[readPosition].positionChannels;\n        vec3 motion = data[readMotion].motionChannels;\n    #endif\n\n    // If reads all map to the same value sample, any of them will do.\n    #if defined(positionOutput)\n        #define readLife positionReadLife\n    #elif defined(lifeOutput)\n        #define readLife lifeReadLife\n    #elif defined(motionOutput)\n        #define readLife motionReadLife\n    #endif\n\n    float life = data[readLife].lifeChannels;\n\n    #ifdef lifeOutput\n        float lifeLast = data[lifeReadLifeLast].lifeChannels;\n    #endif\n\n    // Update and output values.\n    // Note that the update/output logic components within each `#if` macro\n    // block from `gpgpu` are independent modules, as the `gpgpu` macros\n    // determine whether they're executed across one or more passes - they could\n    // also be coded in separate files called from here, however they're coded\n    // inline here for brevity, relevance, and easy access to shared variables.\n\n    // Whether the particle is ready to respawn.\n    float spawn = le(life, 0.0);\n\n    #if defined(positionOutput) || defined(motionOutput)\n        // Workaround for switching Euler/Verlet; interpret `motion` data as\n        // acceleration/velocity, respectively.\n        vec3 velocity = motion;\n        vec3 acceleration = motion;\n\n        // Spawn randomly on a sphere around the source, move in that direction.\n        vec3 spoutSpawn = random(loop-(uv*dt0))*\n            randomOnSphere(random((uv+loop)/dt1), random((uv-loop)*dt0));\n    #endif\n\n    #ifdef positionOutput\n        // For numeric accuracy, encoded as exponent `[b, p] => b*(10**p)`.\n        float size = scale.s*pow(10.0, scale.t);\n\n        // Constrain Verlet movement; handle here for better numerical accuracy.\n        vec3 back = position1-position0;\n        float backL2 = dot(back, back);\n\n        // Position changes below the movement cap remain the same; any bigger\n        // clamped towards current position, by the ratio over the limit.\n        back = mix(position0, position1, clamp((backL2/moveCap)-1.0, 0.0, 1.0));\n\n        // Use either Euler integration...\n        vec3 positionTo = mix(position1+(velocity*dt1*size),\n            // ... or Verlet integration...\n            verlet(back, position1, acceleration*size, dt0, dt1),\n            // ... according to which is currently active.\n            useVerlet);\n\n        // Spawn around the source.\n        vec3 positionSpawn = source+(spout.x*spoutSpawn);\n\n        // Output the next position value to its channels in the state texture.\n        positionOutput = mix(positionTo, positionSpawn, spawn);\n    #endif\n    #ifdef motionOutput\n        // Gravitate towards the sink point (simplified).\n        // @see https://en.wikipedia.org/wiki/Newton%27s_law_of_universal_gravitation\n        vec3 gravity = sink.xyz-position1;\n\n        gravity *= sink.w/max(dot(gravity, gravity), epsilon);\n\n        // Use sink point, or constant acceleration due to gravity.\n        acceleration = mix(gravity, g.xyz, g.w);\n\n        // Can also combine other forces, e.g: drag.\n        // acceleration +=\n        //     dragAcc(mix(velocity, acceleration*dt1, useVerlet), drag);\n\n        vec3 motionTo = mix(velocity+(acceleration*dt1), acceleration,\n            useVerlet);\n\n        vec3 motionNew = spout.y*spoutSpawn;\n\n        // Output the next motion value to its channels in the state texture.\n        motionOutput = mix(motionTo, motionNew, spawn);\n    #endif\n    #ifdef lifeOutput\n        float lifeTo = max(life-dt1, 0.0);\n        float lifeNew = map(random(uv*loop), 0.0, 1.0, lifetime.s, lifetime.t);\n        // Whether the oldest of this trail has faded.\n        float faded = le(lifeLast, 0.0);\n\n        // Output the next life value to its channels in the state texture.\n        // Only spawn life once the oldest step reaches the end of its lifetime\n        // (past and current life are both 0), and if it's allowed to respawn.\n        lifeOutput = mix(lifeTo, lifeNew, spawn*faded*lifetime.z);\n    #endif\n}\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see [macroPass]{@link ../../macros.js#macroPass}\n * @see [macroValues]{@link ../../macros.js#macroValues}\n */\n\nprecision highp float;\n\n// The texture channels each of the `values` is stored in.\n#define positionChannels channels_0\n#define motionChannels channels_1\n#define lifeChannels channels_2\n// Set up sampling logic.\nuseSamples\n// Only the first value derives from all values, giving these minimal `reads`.\nuseReads_0\n// All `derives` here are in one pass (`0`), and in the same order as `values`.\n// See `values` for indexing `reads_0_${derives index == values index}`.\n#define readPosition1 reads_0_0\n#define readMotion reads_0_1\n#define readLife reads_0_2\n#define readPosition0 reads_0_3\n\nattribute float index;\n\n// States from `gl-gpgpu`; in separate textures or merged.\n#ifdef mergedStates\n    uniform sampler2D states;\n#else\n    uniform sampler2D states[stepsPast*textures];\n#endif\n\n// Must be defined when using the default `tapStates` or `tapStatesBy`.\nuniform float stepNow;\n\nuniform vec4 dataShape;\nuniform vec2 viewShape;\nuniform float pointSize;\nuniform float dt;\nuniform vec3 lifetime;\nuniform vec2 pace;\nuniform float useVerlet;\nuniform float form;\n\nvarying vec4 color;\nvarying vec3 center;\nvarying float radius;\n\n#pragma glslify: aspect = require(@epok.tech/glsl-aspect/contain)\n#pragma glslify: gt = require(glsl-conditionals/when_gt)\n\n#pragma glslify: indexUV = require(../../lookup/index-uv)\n#pragma glslify: offsetUV = require(../../lookup/offset-uv)\n\n#if stepsPast > 1\n    // If multiple steps are given, shift into past steps.\n    // Lookups mostly equivalent; input and result iteration order differ.\n    #define indexFormsStates\n    #ifdef indexFormsStates\n        #pragma glslify: indexStates = require(../../index-forms/index-states)\n    #else\n        #pragma glslify: indexEntries = require(../../index-forms/index-entries)\n    #endif\n#endif\n\nconst vec4 noPosition = vec4(0, 0, -1, 0);\n\nvoid main() {\n    #if stepsPast > 1\n        // If multiple steps are given, find past step and entry.\n        // Lookups mostly equivalent; input and result iteration order differ.\n        #ifdef indexFormsStates\n            vec2 stepEntry = indexStates(index, stepsPast, form);\n        #else\n            vec2 stepEntry = indexEntries(index, count, form);\n        #endif\n\n        float stepPast = stepEntry.s;\n        float entry = stepEntry.t;\n    #else\n        // If only 1 step is given, past step and entry are known.\n        float stepPast = 0.0;\n        float entry = index;\n    #endif\n\n    // Turn 1D index into 2D texture UV; offset to texel center, avoids errors.\n    vec2 st = offsetUV(indexUV(entry, dataShape.xy), dataShape.xy);\n\n    // Can also use the `reads` logic to take the minimum possible samples here.\n    // Sample the desired state values; creates the `data` array.\n    #if stepsPast > 1\n        // Shift into past steps.\n        tapStateBy(st, stepPast, 0)\n    #else\n        // No past steps, no shift.\n        tapState(st)\n    #endif\n\n    // Read values.\n    vec3 position0 = (data[readPosition0].positionChannels);\n    vec3 position1 = (data[readPosition1].positionChannels);\n    vec3 motion = (data[readMotion].motionChannels);\n    float life = (data[readLife].lifeChannels);\n\n    #if stepsPast > 1\n        float ratioNow = 1.0-(stepPast/float(stepsPast-1));\n    #else\n        float ratioNow = 1.0;\n    #endif\n\n    float alive = gt(life, 0.0);\n    vec2 ar = aspect(viewShape);\n    vec4 vertex = mix(noPosition, vec4(position1.xy*ar, position1.z, 1), alive);\n    float depth = clamp(1.0-(vertex.z/vertex.w), 0.1, 1.0);\n    float a = clamp(pow(life/lifetime.t, 0.3)*pow(ratioNow, 0.3), 0.0, 1.0);\n    float size = pointSize*depth*a;\n\n    gl_Position = vertex;\n    gl_PointSize = size;\n\n    radius = size*0.5;\n    // Convert vertex position to `gl_FragCoord` window-space.\n    // @see https://stackoverflow.com/a/7158573\n    // @todo Might need the viewport `x` and `y` offset as well as `w` and `h`?\n    center = vec3(viewShape*((1.0+vertex.xy)/vertex.w)*0.5, vertex.z);\n\n    float speed = length(mix(motion, position1-position0, useVerlet)/dt);\n\n    color = a*vec4(mix(0.2, 1.0, ratioNow), mix(0.2, 1.0, entry/float(count)),\n        clamp(pow(speed*pace.s, pace.t), 0.0, 1.0), a);\n}\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see [macroPass]{@link ../../macros.js#macroPass}\n * @see [macroValues]{@link ../../macros.js#macroValues}\n */\n\n#ifdef GL_EXT_frag_depth\n    #extension GL_EXT_frag_depth : enable\n#endif\n\nprecision highp float;\n\nvarying vec4 color;\nvarying vec3 center;\nvarying float radius;\n\nvoid main() {\n    // Fade out to transparent when the fragment is beyond the radius.\n    vec2 vc = center.xy-gl_FragCoord.xy;\n    float vcl2 = dot(vc, vc);\n    float r2 = radius*radius;\n\n    if(vcl2 > r2) { discard; }\n\n    float d2 = vcl2/r2;\n\n    gl_FragColor = vec4(color.rgb, mix(color.a, 0.0, d2));\n\n    #ifdef GL_EXT_frag_depth\n        gl_FragDepthEXT = center.z+d2;\n    #endif\n}\n"],"names":["_console","_console1","_Math","ref","ref1","self","gpgpu","$e3wLf","macroPass","$1tr74","mapFlow","$4MXss","getUniforms","$gyl7y","getDrawIndexes","$83JB3","indexForms","$1UMgm","default","canvas","document","querySelector","scroll","setTimeout","scrollIntoView","toggleError","e","classList","getQuery","param","search","location","URLSearchParams","setQuery","entries","param1","query","$9yAa9","k","_param","tmp","v","delete","set","query1","fragDepth","get","extend","halfFloat","$hBMe5","extensionsHalfFloat","float","extensionsFloat","other","optionalExtensions","depth","pixelRatio","Math","max","devicePixelRatio","regl","$parcel$interopDefault","$3Cmit","extensions","required","optional","$kxEDL","concat","onDone","console","group","log","$ksHHi","o","hasExtension","groupEnd","valuesMap","Map","values","valuesIndex","forEach","push","_limits","limits","maxTextureUnits","maxTextureSize","lineWidthDims","pointSizeDims","useMerge","merge","scale","log2","niceScale","$lKPpF","apply","parseFloat","steps","floor","s","parseInt","stepsPast","canVerlet","form","wide","hasTimestep","has","timestep","flat","href","min","derives","position","$DlVmp","motion","life","state1","maps","bound","type","every","macros","vert","pre","step","frag","$36Ycn","frags","uniforms","dt","_","props","_props","timer","rate","dt0","dts","dt1","time","loop","t","l","sin","PI","lifetime","prop","useVerlet","epsilon","moveCap","source","sink","g","spout","$8g7pT","$88hlK","now","invert","state","packed","textures","valueToTexture","drawBound","drawSteps","useLines","drawCounts","$9pabq","f","size","count","viewScale","w","drawingBufferWidth","h","drawingBufferHeight","drawState","$9BYky","output","drawProps","counts","primitive","primitives","pace","texturesMax","drawCommand","$e3zEi","$59uQ3","attributes","index","pointSize","c","lineWidth","_drawProps","cs","enable","blend","func","src","dst","p","ps","draw","hold","clearView","color","stopEvent","stopPropagation","preventDefault","resize","width","innerWidth","height","innerHeight","frame","run","stepNow","clear","addEventListener","spawned","held","button","d","x","clientX","y","clientY","pointerType","_isPrimary","isPrimary","i","touch","to","module","hot","accept","call","reload","obj","key","value","Object","defineProperty","enumerable","configurable","writable","target","arguments","length","ownKeys","keys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","$gHSxu","arr","$km6mS","$3rVPa","$iWEHp","Array","isArray","iter","Symbol","iterator","prototype","toString","from","TypeError","$kJ5JC","$f24YN","arr2","exports","$60359228a7d3fb28$export$be3f796aed065412","diff","pause","add","$60359228a7d3fb28$export$7548f4bc1b09ff22","$60359228a7d3fb28$export$85b884786400d38f","$60359228a7d3fb28$export$eb8a9b7a1ebec59a","Date","$60359228a7d3fb28$export$2e2bcd8739ae039","out","t0","n","_step","t1","isNaN","$ee5851911330bf41$var$r","reduce","$ee5851911330bf41$export$533b26079ad0b4b","a","undefined","$ee5851911330bf41$export$2e2bcd8739ae039","$6d8e5906de1cf303$export$2e2bcd8739ae039","to1","$6f535731e26073af$var$e","$6f535731e26073af$export$2e2bcd8739ae039","fill","$5ebc876929a0439f$var$fill","isFinite","$5ebc876929a0439f$var$isFinite","Number","$5ebc876929a0439f$var$floor","$5ebc876929a0439f$export$2e2bcd8739ae039","start","end","$0764a650e9f35d5a$export$2e2bcd8739ae039","$6qjSx","$4ad49746d3e88695$export$2e2bcd8739ae039","_to","_to1","$a3bac22a2cec4520$export$a8489f67fe30ef76","api","maxDrawbuffers","glsl","_maps","buffersMax","match","_maps1","$20H3c","getState","$4NSvD","getStep","_cache","_reads","_ref","$37c9c43fd5907c13$var$isInteger","isInteger","$37c9c43fd5907c13$export$69a3209f1a06c04d","$37c9c43fd5907c13$export$5ca26c99531348ec","channelsMax","channelsMaxDef","error","$37c9c43fd5907c13$export$96707a1f51900f3d","param2","_values","valuesDef","_channelsMax","_buffersMax","buffersMaxDef","_packed","channels","fitIndex","fitSize","Infinity","i1","fit","pack","$37c9c43fd5907c13$export$9d1d9285bd6d8c57","passes","valueToPass","textureToPass","getValue","getIndex","pass","texture","$37c9c43fd5907c13$export$574963e692b662ec","param3","to2","reads","cache","all","getAddSample","derive","findIndex","_pass","_value","samples","valueDerives","getAddSamples","$37c9c43fd5907c13$export$2af223e005819b46","$cd1b4d1540633814$export$ac0cd3cc21f80dfc","$cd1b4d1540633814$export$5d97924d29f48e83","$cd1b4d1540633814$export$4bceda1224fc5ab8","$cd1b4d1540633814$export$b4781c2237bde956","$cd1b4d1540633814$export$26945b8c914b7fc","$cd1b4d1540633814$export$154f256b9eac9103","$cd1b4d1540633814$export$b6267c3f91c57c78","$cd1b4d1540633814$export$b029aceb5666f022","$cd1b4d1540633814$export$c4175b5828221aa7","pow","$cd1b4d1540633814$export$bffb644e7dc52e91","$cd1b4d1540633814$export$617a37502ff8853","$cd1b4d1540633814$export$ff01eb58fe4e69","$cd1b4d1540633814$export$cfdc3a7c4cb854c6","$fAgvn","positions","$cd1b4d1540633814$export$27fb0dad99ae5dd2","$cd1b4d1540633814$export$47b10f415de592b1","$cd1b4d1540633814$export$1fb689c67b965bff","$cd1b4d1540633814$export$8d7f4a48e1f2b2a","$cd1b4d1540633814$export$a211ab2c8ecded9a","$cd1b4d1540633814$export$a1b7c201e9365814","$cd1b4d1540633814$export$d5373eb478d25864","$b587055a99d7210b$export$ba60520149d1328e","$b587055a99d7210b$export$878041e1e4cd4218","_textures","_passes","$176cf9cb32bd006b$var$isInteger","$176cf9cb32bd006b$export$50fdfeece43146fd","ref8","ref2","ref3","framebuffer","_steps","stepsDef","passNow","_merge","mergeDef","_type","typeDef","_min","min1","minDef","_mag","mag","magDef","_wrap","wrap","wrapDef","_depth","depthDef","_stencil","stencil","stencilDef","scaled","getScaled","getWidth","widthDef","getHeight","heightDef","_channelsMin","channelsMin","channelsMinDef","texturesMap","_length","colorPool","passChannels","min2","sum","mergeChannels","framebuffers","colors","shape","passes1","addTexture","entry","bind","map","addPass","ref4","ref5","ref6","ref7","mScaled","mw","mh","copier","_copier","ref9","ref10","ref11","_count","$5de1f9120313e2d2$export$3c49c185de0c2bfc","side","$5de1f9120313e2d2$export$c08559766941f856","$5de1f9120313e2d2$export$87ed20f81f3c66ff","$5de1f9120313e2d2$export$a495db45d4904b10","$5de1f9120313e2d2$export$f99427edb65f5558","_verts","_frags","_merge1","_step2","$37f6056e300b6832$var$scale","$37f6056e300b6832$export$69a3209f1a06c04d","copy","$37f6056e300b6832$export$d86e3abd7686c23f","$37f6056e300b6832$export$12661000d11a17d2","sl","_shape","$84KjE","cf","ci","use","subimage","$37f6056e300b6832$export$89e7bec3b8bce705","buffer","_command","command","merge1","tmp2","preDef","_step1","step1","_positions","positionsDef","passCommand","_vert","$2Be0R","verts","_count1","_p","_p1","_obj","tmp1","vs","tmp3","fs","_update","update","mergeUpdate","onPass","onStep","stepProps","clearPass","passProps","_cache1","_cache2","_cache3","$112d87fa33ebb5f5$export$cbfbec548517f2b6","$112d87fa33ebb5f5$export$4e46ac54fc82cf3b","$112d87fa33ebb5f5$export$69a3209f1a06c04d","$112d87fa33ebb5f5$export$d560c7e4a29451c2","JSON","stringify","$112d87fa33ebb5f5$export$11949c6f5fba7dcd","$112d87fa33ebb5f5$export$feaf5ffc92c2af94","on","$ayMqI","$112d87fa33ebb5f5$export$83d01c7b88bc16d5","name","qualify","init","join","$112d87fa33ebb5f5$export$45db4de6da38aa8d","$112d87fa33ebb5f5$export$3df19e70a88cb8cd","param4","$112d87fa33ebb5f5$export$1c7039c93eddfba","param5","$112d87fa33ebb5f5$export$c346962e7dd3191","param6","trim","$112d87fa33ebb5f5$export$d38b14fb9031108e","hook","_bound","boundDef","passesL","stepsL","_c","s1","slice","$112d87fa33ebb5f5$export$84186522bf5a7d4d","s2","$112d87fa33ebb5f5$export$49873e279ff642c0","reads1","passSamples","passReads","$112d87fa33ebb5f5$export$9cb6037fa2a40c2e","glsl3","tap","by","aka","akaBy","st","tapsSamples","tapsL","$112d87fa33ebb5f5$export$562ddd36066ad650","$7b02a589e8d7c18a$var$start","$7b02a589e8d7c18a$var$end","split","$7b02a589e8d7c18a$export$bf9fb029d174d554","_uniforms","$c0d0347db9b941ce$export$4e06fab977536f8e","texturesL","dataShape","viewShape","$fnH3v","setC4","set4","setC2","m","addTextures","ago","b","ts","ago1","pl","$b32a66f4c5b7b75f$export$dcfbb7940cfb3a48","$b32a66f4c5b7b75f$export$abee0037e1db715","z","$1650756f91a9613e$export$2e2bcd8739ae039","states"],"version":3,"file":"index.757ca5fe.js.map"}