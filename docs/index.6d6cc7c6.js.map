{"mappings":"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","sources":["node_modules/clamp/index.js","node_modules/@thi.ng/math/api.js","node_modules/@thi.ng/matrices/node_modules/@thi.ng/vectors/setc.js","node_modules/@thi.ng/matrices/frustum.js","node_modules/@thi.ng/matrices/perspective.js","node_modules/@thi.ng/matrices/node_modules/@thi.ng/vectors/cross.js","node_modules/@thi.ng/errors/deferror.js","node_modules/@thi.ng/errors/illegal-arity.js","node_modules/@thi.ng/compose/comp.js","node_modules/@thi.ng/checks/implements-function.js","node_modules/@thi.ng/transducers/ensure.js","node_modules/@thi.ng/transducers/comp.js","node_modules/@thi.ng/checks/is-iterable.js","node_modules/@thi.ng/transducers/compr.js","node_modules/@thi.ng/api/api.js","node_modules/@thi.ng/transducers/reduced.js","node_modules/@thi.ng/transducers/reduce.js","node_modules/@thi.ng/checks/is-arraylike.js","node_modules/@thi.ng/transducers/push.js","node_modules/@thi.ng/transducers/iterator.js","node_modules/@thi.ng/transducers/map.js","node_modules/@thi.ng/transducers/map-indexed.js","node_modules/@thi.ng/transducers/range.js","node_modules/@thi.ng/transducers/str.js","node_modules/@thi.ng/transducers/take.js","node_modules/@thi.ng/transducers/transduce.js","node_modules/@thi.ng/transducers/zip.js","node_modules/@thi.ng/errors/unsupported.js","node_modules/@thi.ng/matrices/node_modules/@thi.ng/vectors/vop.js","node_modules/@thi.ng/matrices/node_modules/@thi.ng/vectors/compile/templates.js","node_modules/@thi.ng/matrices/node_modules/@thi.ng/vectors/compile/emit.js","node_modules/@thi.ng/matrices/node_modules/@thi.ng/vectors/dot.js","node_modules/@thi.ng/matrices/node_modules/@thi.ng/vectors/magsq.js","node_modules/@thi.ng/matrices/node_modules/@thi.ng/vectors/muln.js","node_modules/@thi.ng/matrices/node_modules/@thi.ng/vectors/set.js","node_modules/@thi.ng/matrices/node_modules/@thi.ng/vectors/normalize.js","node_modules/@thi.ng/matrices/node_modules/@thi.ng/vectors/sub.js","node_modules/@epok.tech/fn-time/dist/es/index.js","node_modules/@epok.tech/fn-lists/reduce.js","node_modules/@epok.tech/fn-lists/map.js","node_modules/@epok.tech/fn-lists/each.js","node_modules/@epok.tech/fn-lists/range.js","node_modules/@epok.tech/fn-lists/wrap-index.js","node_modules/@epok.tech/fn-lists/wrap.js","node_modules/@epok.tech/gl-screen-triangle/dist/esm/index.js","src/const.js","src/index.vert.glsl","src/maps.js","src/size.js","src/data.js","node_modules/@thi.ng/vectors/setc.js","src/uniforms.js","node_modules/@epok.tech/is-type/type.js","src/macros.js","src/step.js","src/index.js","src/index-forms/index.js","demo/particles-regl/index.js","demo/particles-regl/step.frag.glsl","node_modules/@thi.ng/matrices/lookat.js","demo/particles-regl/draw.vert.glsl","demo/particles-regl/draw.frag.glsl"],"sourcesContent":["module.exports = clamp\n\nfunction clamp(value, min, max) {\n  return min < max\n    ? (value < min ? min : value > max ? max : value)\n    : (value < max ? max : value > min ? min : value)\n}\n","export const PI = Math.PI;\nexport const TAU = PI * 2;\nexport const HALF_PI = PI / 2;\nexport const THIRD_PI = PI / 3;\nexport const QUARTER_PI = PI / 4;\nexport const SIXTH_PI = PI / 6;\nexport const INV_PI = 1 / PI;\nexport const INV_TAU = 1 / TAU;\nexport const INV_HALF_PI = 1 / HALF_PI;\nexport const DEG2RAD = PI / 180;\nexport const RAD2DEG = 180 / PI;\nexport const PHI = (1 + Math.sqrt(5)) / 2;\nexport const SQRT2 = Math.SQRT2;\nexport const SQRT3 = Math.sqrt(3);\nexport const SQRT2_2 = SQRT2 / 2;\nexport const SQRT3_2 = SQRT3 / 2;\nexport const THIRD = 1 / 3;\nexport const TWO_THIRD = 2 / 3;\nexport const SIXTH = 1 / 6;\nexport let EPS = 1e-6;\n","export const setC2 = (out, x, y) => (!out && (out = []), (out[0] = x), (out[1] = y), out);\nexport const setC3 = (out, x, y, z) => (!out && (out = []), (out[0] = x), (out[1] = y), (out[2] = z), out);\nexport const setC4 = (out, x, y, z, w) => (!out && (out = []),\n    (out[0] = x),\n    (out[1] = y),\n    (out[2] = z),\n    (out[3] = w),\n    out);\nexport const setC6 = (out, a, b, c, d, e, f) => (!out && (out = []),\n    (out[0] = a),\n    (out[1] = b),\n    (out[2] = c),\n    (out[3] = d),\n    (out[4] = e),\n    (out[5] = f),\n    out);\nexport const setC = (out, ...xs) => {\n    !out && (out = []);\n    for (let i = 0, n = xs.length; i < n; i++) {\n        out[i] = xs[i];\n    }\n    return out;\n};\n","import { DEG2RAD } from \"@thi.ng/math/api\";\nimport { setC } from \"@thi.ng/vectors/setc\";\n/**\n * Constructs a 4x4 matrix representing the given view frustum. Creates\n * new matrix if `out` is `null`.\n *\n * @param out -\n * @param left -\n * @param right -\n * @param bottom -\n * @param top -\n * @param near -\n * @param far -\n */\nexport const frustum = (out, left, right, bottom, top, near, far) => {\n    const dx = 1 / (right - left);\n    const dy = 1 / (top - bottom);\n    const dz = 1 / (far - near);\n    return setC(out || [], near * 2 * dx, 0, 0, 0, 0, near * 2 * dy, 0, 0, (right + left) * dx, (top + bottom) * dy, -(far + near) * dz, -1, 0, 0, -(far * near * 2) * dz, 0);\n};\nexport const frustumBounds = (fovy, aspect, near, far) => {\n    const top = near * Math.tan((fovy * DEG2RAD) / 2);\n    const right = top * aspect;\n    return {\n        left: -right,\n        right,\n        bottom: -top,\n        top,\n        near,\n        far,\n    };\n};\n","import { frustum, frustumBounds } from \"./frustum.js\";\n/**\n * Creates a 4x4 matrix perspective projection matrix and writes result\n * to `out`.\n *\n * @param out -\n * @param fov -\n * @param aspect -\n * @param near -\n * @param far -\n */\nexport const perspective = (out, fov, aspect, near, far) => {\n    const f = frustumBounds(fov, aspect, near, far);\n    return frustum(out, f.left, f.right, f.bottom, f.top, f.near, f.far);\n};\n","import { setC3 } from \"./setc.js\";\nexport const cross2 = (a, b) => a[0] * b[1] - a[1] * b[0];\nexport const cross3 = (out, a, b) => setC3(out || a, a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]);\n","export const defError = (prefix, suffix = (msg) => (msg !== undefined ? \": \" + msg : \"\")) => class extends Error {\n    constructor(msg) {\n        super(prefix(msg) + suffix(msg));\n    }\n};\n","import { defError } from \"./deferror.js\";\nexport const IllegalArityError = defError(() => \"illegal arity\");\nexport const illegalArity = (n) => {\n    throw new IllegalArityError(n);\n};\n","import { illegalArity } from \"@thi.ng/errors/illegal-arity\";\nexport function comp(...fns) {\n    let [a, b, c, d, e, f, g, h, i, j] = fns;\n    switch (fns.length) {\n        case 0:\n            illegalArity(0);\n        case 1:\n            return a;\n        case 2:\n            return (...xs) => a(b(...xs));\n        case 3:\n            return (...xs) => a(b(c(...xs)));\n        case 4:\n            return (...xs) => a(b(c(d(...xs))));\n        case 5:\n            return (...xs) => a(b(c(d(e(...xs)))));\n        case 6:\n            return (...xs) => a(b(c(d(e(f(...xs))))));\n        case 7:\n            return (...xs) => a(b(c(d(e(f(g(...xs)))))));\n        case 8:\n            return (...xs) => a(b(c(d(e(f(g(h(...xs))))))));\n        case 9:\n            return (...xs) => a(b(c(d(e(f(g(h(i(...xs)))))))));\n        case 10:\n        default:\n            const fn = (...xs) => a(b(c(d(e(f(g(h(i(j(...xs))))))))));\n            return fns.length === 10 ? fn : comp(fn, ...fns.slice(10));\n    }\n}\nexport function compL(...fns) {\n    return comp.apply(null, fns.reverse());\n}\n/**\n * @deprecated renamed to {@link compL}\n */\nexport const compI = compL;\n","export const implementsFunction = (x, fn) => x != null && typeof x[fn] === \"function\";\n","import { implementsFunction } from \"@thi.ng/checks/implements-function\";\nexport const ensureTransducer = (x) => implementsFunction(x, \"xform\") ? x.xform() : x;\n","import { comp as _comp } from \"@thi.ng/compose/comp\";\nimport { ensureTransducer } from \"./ensure.js\";\nexport function comp(...fns) {\n    fns = fns.map(ensureTransducer);\n    return _comp.apply(null, fns);\n}\n","export const isIterable = (x) => x != null && typeof x[Symbol.iterator] === \"function\";\n","/**\n * Reducer composition helper, internally used by various transducers\n * during initialization. Takes existing reducer `rfn` (a 3-tuple) and a\n * reducing function `fn`. Returns a new reducer tuple.\n *\n * @remarks\n * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.\n * `fn` accepts values of type `C` and produces interim results of type\n * `B`, which are then (possibly) passed to the \"inner\" `rfn[2]`\n * function. Therefore the resulting reducer takes inputs of `C` and an\n * accumulator of type `A`.\n *\n * It is assumed that `fn` internally calls `rfn[2]` to pass its own\n * results for further processing by the nested reducer `rfn`.\n *\n * @example\n * ```ts\n * compR(rfn, fn)\n * // [rfn[0], rfn[1], fn]\n * ```\n *\n * @param rfn -\n * @param fn -\n */\nexport const compR = (rfn, fn) => [rfn[0], rfn[1], fn];\n","export const DEFAULT_EPS = 1e-6;\n/**\n * Internal use only. **Do NOT use in user land code!**\n *\n * @internal\n */\nexport const SEMAPHORE = Symbol();\n/**\n * No-effect placeholder function.\n */\nexport const NO_OP = () => { };\n/**\n * Catch-all event ID\n */\nexport const EVENT_ALL = \"*\";\nexport const EVENT_ENABLE = \"enable\";\nexport const EVENT_DISABLE = \"disable\";\n","export class Reduced {\n    constructor(val) {\n        this.value = val;\n    }\n    deref() {\n        return this.value;\n    }\n}\nexport const reduced = (x) => new Reduced(x);\nexport const isReduced = (x) => x instanceof Reduced;\nexport const ensureReduced = (x) => x instanceof Reduced ? x : new Reduced(x);\nexport const unreduced = (x) => (x instanceof Reduced ? x.deref() : x);\n","import { implementsFunction } from \"@thi.ng/checks/implements-function\";\nimport { isArrayLike } from \"@thi.ng/checks/is-arraylike\";\nimport { isIterable } from \"@thi.ng/checks/is-iterable\";\nimport { illegalArity } from \"@thi.ng/errors/illegal-arity\";\nimport { isReduced, unreduced } from \"./reduced.js\";\nconst parseArgs = (args) => args.length === 2\n    ? [undefined, args[1]]\n    : args.length === 3\n        ? [args[1], args[2]]\n        : illegalArity(args.length);\nexport function reduce(...args) {\n    const rfn = args[0];\n    const init = rfn[0];\n    const complete = rfn[1];\n    const reduce = rfn[2];\n    args = parseArgs(args);\n    const acc = args[0] == null ? init() : args[0];\n    const xs = args[1];\n    return unreduced(complete(implementsFunction(xs, \"$reduce\")\n        ? xs.$reduce(reduce, acc)\n        : isArrayLike(xs)\n            ? reduceArray(reduce, acc, xs)\n            : reduceIterable(reduce, acc, xs)));\n}\nexport function reduceRight(...args) {\n    const rfn = args[0];\n    const init = rfn[0];\n    const complete = rfn[1];\n    const reduce = rfn[2];\n    args = parseArgs(args);\n    let acc = args[0] == null ? init() : args[0];\n    const xs = args[1];\n    for (let i = xs.length; i-- > 0;) {\n        acc = reduce(acc, xs[i]);\n        if (isReduced(acc)) {\n            acc = acc.deref();\n            break;\n        }\n    }\n    return unreduced(complete(acc));\n}\nconst reduceArray = (rfn, acc, xs) => {\n    for (let i = 0, n = xs.length; i < n; i++) {\n        acc = rfn(acc, xs[i]);\n        if (isReduced(acc)) {\n            acc = acc.deref();\n            break;\n        }\n    }\n    return acc;\n};\nconst reduceIterable = (rfn, acc, xs) => {\n    for (let x of xs) {\n        acc = rfn(acc, x);\n        if (isReduced(acc)) {\n            acc = acc.deref();\n            break;\n        }\n    }\n    return acc;\n};\n/**\n * Convenience helper for building a full {@link Reducer} using the identity\n * function (i.e. `(x) => x`) as completion step (true for 90% of all\n * bundled transducers).\n *\n * @param init - init step of reducer\n * @param rfn - reduction step of reducer\n */\nexport const reducer = (init, rfn) => [init, (acc) => acc, rfn];\nexport const $$reduce = (rfn, args) => {\n    const n = args.length - 1;\n    return isIterable(args[n])\n        ? args.length > 1\n            ? reduce(rfn.apply(null, args.slice(0, n)), args[n])\n            : reduce(rfn(), args[0])\n        : undefined;\n};\n","export const isArrayLike = (x) => x != null && typeof x !== \"function\" && x.length !== undefined;\n","import { reducer } from \"./reduce.js\";\nexport function push(xs) {\n    return xs\n        ? [...xs]\n        : reducer(() => [], (acc, x) => (acc.push(x), acc));\n}\n","import { NO_OP, SEMAPHORE } from \"@thi.ng/api/api\";\nimport { isIterable } from \"@thi.ng/checks/is-iterable\";\nimport { ensureTransducer } from \"./ensure.js\";\nimport { push } from \"./push.js\";\nimport { isReduced, unreduced } from \"./reduced.js\";\n/**\n * Takes a transducer and input iterable. Returns iterator of\n * transformed results.\n *\n * @param xform -\n * @param xs -\n */\nexport function* iterator(xform, xs) {\n    const rfn = ensureTransducer(xform)(push());\n    const complete = rfn[1];\n    const reduce = rfn[2];\n    for (let x of xs) {\n        const y = reduce([], x);\n        if (isReduced(y)) {\n            yield* unreduced(complete(y.deref()));\n            return;\n        }\n        if (y.length) {\n            yield* y;\n        }\n    }\n    yield* unreduced(complete([]));\n}\n/**\n * Optimized version of {@link iterator} for transducers which are\n * guaranteed to:\n *\n * 1) Only produce none or a single result per input\n * 2) Do not require a `completion` reduction step\n *\n * @param xform -\n * @param xs -\n */\nexport function* iterator1(xform, xs) {\n    const reduce = (ensureTransducer(xform)([NO_OP, NO_OP, (_, x) => x]))[2];\n    for (let x of xs) {\n        let y = reduce(SEMAPHORE, x);\n        if (isReduced(y)) {\n            y = unreduced(y.deref());\n            if (y !== SEMAPHORE) {\n                yield y;\n            }\n            return;\n        }\n        if (y !== SEMAPHORE) {\n            yield y;\n        }\n    }\n}\n/**\n * Helper function used by various transducers to wrap themselves as\n * transforming iterators. Delegates to {@link iterator1} by default.\n *\n * @param xform -\n * @param args -\n * @param impl -\n *\n * @internal\n */\nexport const __iter = (xform, args, impl = iterator1) => {\n    const n = args.length - 1;\n    return isIterable(args[n])\n        ? args.length > 1\n            ? impl(xform.apply(null, args.slice(0, n)), args[n])\n            : impl(xform(), args[0])\n        : undefined;\n};\n","import { isIterable } from \"@thi.ng/checks/is-iterable\";\nimport { compR } from \"./compr.js\";\nimport { iterator1 } from \"./iterator.js\";\nexport function map(fn, src) {\n    return isIterable(src)\n        ? iterator1(map(fn), src)\n        : (rfn) => {\n            const r = rfn[2];\n            return compR(rfn, (acc, x) => r(acc, fn(x)));\n        };\n}\n/**\n * Convenience wrapper for {@link map} to transform an iterable with given `fn`\n * and immediatedly collect results into an array.\n */\nexport const mapA = (fn, src) => [\n    ...map(fn, src),\n];\n","import { compR } from \"./compr.js\";\nimport { __iter } from \"./iterator.js\";\nexport function mapIndexed(...args) {\n    return (__iter(mapIndexed, args) ||\n        ((rfn) => {\n            const r = rfn[2];\n            const fn = args[0];\n            let i = args[1] || 0;\n            return compR(rfn, (acc, x) => r(acc, fn(i++, x)));\n        }));\n}\n","import { isReduced } from \"./reduced.js\";\nexport function range(from, to, step) {\n    return new Range(from, to, step);\n}\n/**\n * Simple class wrapper around given range interval and implementing `Iterable`\n * and {@link IReducible} interfaces, the latter is used to accelerate use with\n * {@link reduce}.\n */\nexport class Range {\n    constructor(from, to, step) {\n        if (from === undefined) {\n            from = 0;\n            to = Infinity;\n        }\n        else if (to === undefined) {\n            to = from;\n            from = 0;\n        }\n        step = step === undefined ? (from < to ? 1 : -1) : step;\n        this.from = from;\n        this.to = to;\n        this.step = step;\n    }\n    *[Symbol.iterator]() {\n        let { from, to, step } = this;\n        if (step > 0) {\n            while (from < to) {\n                yield from;\n                from += step;\n            }\n        }\n        else if (step < 0) {\n            while (from > to) {\n                yield from;\n                from += step;\n            }\n        }\n    }\n    $reduce(rfn, acc) {\n        const step = this.step;\n        if (step > 0) {\n            for (let i = this.from, n = this.to; i < n && !isReduced(acc); i += step) {\n                acc = rfn(acc, i);\n            }\n        }\n        else {\n            for (let i = this.from, n = this.to; i > n && !isReduced(acc); i += step) {\n                acc = rfn(acc, i);\n            }\n        }\n        return acc;\n    }\n}\n","import { reducer } from \"./reduce.js\";\nexport function str(sep, xs) {\n    sep = sep || \"\";\n    let first = true;\n    return xs\n        ? [...xs].join(sep)\n        : reducer(() => \"\", (acc, x) => ((acc = first ? acc + x : acc + sep + x),\n            (first = false),\n            acc));\n}\n","import { isIterable } from \"@thi.ng/checks/is-iterable\";\nimport { compR } from \"./compr.js\";\nimport { iterator } from \"./iterator.js\";\nimport { ensureReduced, reduced } from \"./reduced.js\";\nexport function take(n, src) {\n    return isIterable(src)\n        ? iterator(take(n), src)\n        : (rfn) => {\n            const r = rfn[2];\n            let m = n;\n            return compR(rfn, (acc, x) => --m > 0\n                ? r(acc, x)\n                : m === 0\n                    ? ensureReduced(r(acc, x))\n                    : reduced(acc));\n        };\n}\n","import { illegalArity } from \"@thi.ng/errors/illegal-arity\";\nimport { ensureTransducer } from \"./ensure.js\";\nimport { map } from \"./map.js\";\nimport { reduce, reduceRight } from \"./reduce.js\";\nexport function transduce(...args) {\n    return $transduce(transduce, reduce, args);\n}\nexport function transduceRight(...args) {\n    return $transduce(transduceRight, reduceRight, args);\n}\nconst $transduce = (tfn, rfn, args) => {\n    let acc, xs;\n    switch (args.length) {\n        case 4:\n            xs = args[3];\n            acc = args[2];\n            break;\n        case 3:\n            xs = args[2];\n            break;\n        case 2:\n            return map((x) => tfn(args[0], args[1], x));\n        default:\n            illegalArity(args.length);\n    }\n    return rfn(ensureTransducer(args[0])(args[1]), acc, xs);\n};\n","export function* zip(...src) {\n    const iters = src.map((s) => s[Symbol.iterator]());\n    while (true) {\n        const tuple = [];\n        for (let i of iters) {\n            let v = i.next();\n            if (v.done) {\n                return;\n            }\n            tuple.push(v.value);\n        }\n        yield tuple;\n    }\n}\n","import { defError } from \"./deferror.js\";\nexport const UnsupportedOperationError = defError(() => \"unsupported operation\");\nexport const unsupported = (msg) => {\n    throw new UnsupportedOperationError(msg);\n};\n","import { unsupported } from \"@thi.ng/errors/unsupported\";\n/**\n * Specialized / optimized version of\n * [`thi.ng/defmulti`](https://thi.ng/defmulti) for vector operations. Uses\n * simplified logic to dispatch on length (vector size) of `dispatch` argument.\n *\n * @param dispatch - arg index\n */\nexport const vop = (dispatch = 0) => {\n    const impls = new Array(5);\n    let fallback;\n    const fn = (...args) => {\n        const g = impls[args[dispatch].length] || fallback;\n        return g\n            ? g(...args)\n            : unsupported(`no impl for vec size ${args[dispatch].length}`);\n    };\n    fn.add = (dim, fn) => (impls[dim] = fn);\n    fn.default = (fn) => (fallback = fn);\n    fn.impl = (dim) => impls[dim] || fallback;\n    // fn.impls = impls;\n    return fn;\n};\n","/** @internal */\nexport const ARGS_V = \"o,a\";\n/** @internal */\nexport const ARGS_VV = \"o,a,b\";\n/** @internal */\nexport const ARGS_VVV = \"o,a,b,c\";\n/** @internal */\nexport const ARGS_VN = \"o,a,n\";\n/** @internal */\nexport const ARGS_VNV = \"o,a,n,b\";\n/** @internal */\nexport const ARGS_VVN = \"o,a,b,n\";\n/** @internal */\nexport const SARGS_V = \"io=0,ia=0,so=1,sa=1\";\n/** @internal */\nexport const SARGS_VV = \"io=0,ia=0,ib=0,so=1,sa=1,sb=1\";\n/** @internal */\nexport const SARGS_VVV = \"io=0,ia=0,ib=0,ic=0,so=1,sa=1,sb=1,sc=1\";\n/** @internal */\nexport const DEFAULT_OUT = \"!o&&(o=a);\";\n/** @internal */\nexport const NEW_OUT = \"!o&&(o=[]);\";\n/** @internal */\nexport const NEW_OUT_A = \"!a&&(a=[]);\";\n/** @internal */\n// prettier-ignore\nexport const MATH = (op) => ([o, a, b]) => `${o}=${a}${op}${b};`;\n/** @internal */\n// prettier-ignore\nexport const MATH_N = (op) => ([o, a]) => `${o}=${a}${op}n;`;\n/** @internal */\n// prettier-ignore\nexport const MATH2 = (op1, op2) => ([o, a, b, c]) => `${o}=(${a}${op1}${b})${op2}${c};`;\n/** @internal */\n// prettier-ignore\nexport const MATH2_N = (op1, op2) => ([o, a, b]) => `${o}=(${a}${op1}${b})${op2}n;`;\n/** @internal */\n// prettier-ignore\nexport const MATH2A_N = (op1, op2) => ([o, a, b]) => `${o}=(${a}${op1}n)${op2}${b};`;\n/** @internal */\n// prettier-ignore\nexport const SIGNED = (op) => ([o, a, b]) => `${o}=(${a}${op}${b})|0;`;\n/** @internal */\n// prettier-ignore\nexport const UNSIGNED = (op) => ([o, a, b]) => `${o}=(${a}${op}${b})>>>0;`;\n/** @internal */\n// prettier-ignore\nexport const SIGNED_N = (op) => ([o, a]) => `${o}=(${a}${op}n)|0;`;\n/** @internal */\n// prettier-ignore\nexport const UNSIGNED_N = (op) => ([o, a]) => `${o}=(${a}${op}n)>>>0;`;\n/** @internal */\n// prettier-ignore\nexport const FN = (op = \"op\") => ([o, a]) => `${o}=${op}(${a});`;\n/** @internal */\n// prettier-ignore\nexport const FN2 = (op = \"op\") => ([o, a, b]) => `${o}=${op}(${a},${b});`;\n/** @internal */\n// prettier-ignore\nexport const FN3 = (op = \"op\") => ([o, a, b, c]) => `${o}=${op}(${a},${b},${c});`;\n/** @internal */\n// prettier-ignore\nexport const FN5 = (op = \"op\") => ([o, a, b, c, d, e]) => `${o}=${op}(${a},${b},${c},${d},${e});`;\n/** @internal */\n// prettier-ignore\nexport const FN_N = (op = \"op\") => ([o, a]) => `${o}=${op}(${a},n);`;\n/** @internal */\nexport const DOT = ([a, b]) => `${a}*${b}`;\n/** @internal */\nexport const DOT_G = ([a, b]) => `s+=${a}*${b};`;\n/** @internal */\nexport const SET = ([o, a]) => `${o}=${a};`;\n/** @internal */\nexport const SET_N = ([a]) => `${a}=n;`;\n/** @internal */\nexport const MIX = ([o, a, b, c]) => `${o}=${a}+(${b}-${a})*${c};`;\n/** @internal */\nexport const MIX_N = ([o, a, b]) => `${o}=${a}+(${b}-${a})*n;`;\n","import { comp } from \"@thi.ng/transducers/comp\";\nimport { map } from \"@thi.ng/transducers/map\";\nimport { mapIndexed } from \"@thi.ng/transducers/map-indexed\";\nimport { range } from \"@thi.ng/transducers/range\";\nimport { str } from \"@thi.ng/transducers/str\";\nimport { take } from \"@thi.ng/transducers/take\";\nimport { transduce } from \"@thi.ng/transducers/transduce\";\nimport { zip } from \"@thi.ng/transducers/zip\";\nimport { vop } from \"../vop.js\";\nimport { ARGS_V, ARGS_VN, ARGS_VV, DEFAULT_OUT, FN, MATH, MATH_N, SARGS_VV, SIGNED, SIGNED_N, UNSIGNED, UNSIGNED_N, } from \"./templates.js\";\n/**\n * HOF array index lookup gen to provide optimized versions of:\n *\n * @example\n * ```ts\n * lookup(\"a\")(0) // a[ia]\n * lookup(\"a\")(1) // a[ia * sa]\n * lookup(\"a\")(2) // a[ia + 2 * sa]\n * ```\n *\n * @param sym -\n */\nconst lookup = (sym) => (i) => i > 1\n    ? `${sym}[i${sym}+${i}*s${sym}]`\n    : i == 1\n        ? `${sym}[i${sym}+s${sym}]`\n        : `${sym}[i${sym}]`;\n/**\n * Infinite iterator of strided index lookups for `sym`.\n *\n * @param sym -\n */\nconst indicesStrided = (sym) => map(lookup(sym), range());\n/**\n * Infinite iterator of simple (non-strided) index lookups for `sym`.\n *\n * @param sym -\n */\nconst indices = (sym) => map((i) => `${sym}[${i}]`, range());\n/**\n * Code generator for loop-unrolled vector operations. Takes a vector\n * size `dim`, a code template function `tpl` and an array of symbol\n * names participating in the template. For each symbol, creates\n * iterator of index lookups (e.g. `a[0]` or `a[ia+k*sa]`), forms them\n * into tuples and passes them to template to generate code and joins\n * generated result with `opJoin` separator (default:\n * `\"\"`).\n *\n * If the optional `ret` arg is not `null` (default `\"a\"`), appends a\n * `return` statement to the result array, using `ret` as return value.\n * Returns array of source code lines.\n *\n * The optional `pre` and `post` strings can be used to wrap the\n * generated code. `post` will be injected **before** the generated\n * return statement (if not suppressed).\n *\n * @param dim -\n * @param tpl -\n * @param syms -\n * @param ret -\n * @param opJoin -\n * @param pre -\n * @param post -\n * @param strided -\n */\nconst assemble = (dim, tpl, syms, ret = \"a\", opJoin = \"\", pre = \"\", post = \"\", strided = false) => [\n    pre,\n    transduce(comp(take(dim), mapIndexed((i, x) => tpl(x, i))), str(opJoin), (zip.apply(null, syms.split(\",\").map(strided ? indicesStrided : indices)))),\n    post,\n    ret !== \"\" ? `return ${ret};` : \"\",\n];\nconst assembleG = (tpl, syms, ret = \"a\", pre, post, strided = false) => [\n    pre,\n    \"for(let i=a.length;--i>=0;) {\",\n    tpl(syms\n        .split(\",\")\n        .map(strided ? (x) => `${x}[i${x}+i*s${x}]` : (x) => `${x}[i]`)),\n    \"}\",\n    post,\n    ret !== null ? `return ${ret};` : \"\",\n];\nconst assembleS = (tpl, syms = ARGS_VV, ret = \"o\", pre = DEFAULT_OUT, post) => [\n    pre,\n    \"while(k-->0) {\",\n    tpl(syms.split(\",\").map((x) => `${x}[i${x}+k*s${x}]`)),\n    \"}\",\n    post,\n    ret !== null ? `return ${ret};` : \"\",\n];\n/** @internal */\nexport const defaultOut = (o, args) => `!${o} && (${o}=${args.split(\",\")[1]});`;\n/** @internal */\nexport const compile = (dim, tpl, args, syms = args, ret = \"a\", opJoin, pre, post, strided = false) => (new Function(args, assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join(\"\")));\n/** @internal */\nexport const compileHOF = (dim, fns, tpl, hofArgs, args, syms = args, ret = \"a\", opJoin = \"\", pre, post, strided = false) => {\n    return new Function(hofArgs, `return (${args})=>{${assemble(dim, tpl, syms, ret, opJoin, pre, post, strided).join(\"\")}}`)(...fns);\n};\n/** @internal */\nexport const compileG = (tpl, args, syms = args, ret = \"a\", pre, post, strided = false) => (new Function(args, assembleG(tpl, syms, ret, pre, post, strided).join(\"\")));\n/** @internal */\nexport const compileS = (tpl, args, syms = args, ret, pre, post) => new Function(args, assembleS(tpl, syms, ret, pre, post).join(\"\"));\n/** @internal */\nexport const compileGHOF = (fns, tpl, hofArgs, args, syms = args, ret = \"a\", pre, post, strided = false) => (new Function(hofArgs, `return (${args})=>{${assembleG(tpl, syms, ret, pre, post, strided).join(\"\")}}`)(...fns));\nexport const defOp = (tpl, args = ARGS_VV, syms, ret = \"o\", dispatch = 1, pre) => {\n    syms = syms || args;\n    pre = pre != null ? pre : defaultOut(ret, args);\n    const fn = vop(dispatch);\n    const $ = (dim) => fn.add(dim, compile(dim, tpl, args, syms, ret, \"\", pre));\n    fn.default(compileG(tpl, args, syms, ret, pre));\n    return [fn, $(2), $(3), $(4)];\n};\nexport const defFnOp = (op) => defOp(FN(op), ARGS_V);\nexport const defHofOp = (op, tpl, args = ARGS_V, syms, ret = \"o\", dispatch = 1, pre) => {\n    const _tpl = tpl || FN(\"op\");\n    syms = syms || args;\n    pre = pre != null ? pre : defaultOut(ret, args);\n    const fn = vop(dispatch);\n    const $ = (dim) => fn.add(dim, compileHOF(dim, [op], _tpl, \"op\", args, syms, ret, \"\", pre));\n    fn.default(compileGHOF([op], _tpl, \"op\", args, syms, ret, pre));\n    return [fn, $(2), $(3), $(4)];\n};\nexport const defOpS = (tpl, args = ARGS_VV, idxArgs = SARGS_VV, syms = ARGS_VV, ret = \"o\", pre, sizes = [2, 3, 4]) => [\n    compileS(tpl, `${args},k,${idxArgs}`, syms, ret, pre),\n    ...sizes.map((dim) => compile(dim, tpl, `${args},${idxArgs}`, syms, ret, \"\", pre != null ? pre : defaultOut(ret, args), \"\", true)),\n];\nexport const defHofOpS = (op, tpl, args = ARGS_VV, idxArgs = SARGS_VV, syms = ARGS_VV, ret = \"o\", pre, sizes = [2, 3, 4]) => [\n    new Function(\"op\", `return (${args},k,${idxArgs})=>{${assembleS(tpl, syms, ret, pre).join(\"\")}}`)(op),\n    ...sizes.map((dim) => compileHOF(dim, [op], tpl, \"op\", `${args},${idxArgs}`, syms, ret, \"\", pre != null ? pre : defaultOut(ret, args), \"\", true)),\n];\nexport const defMathOp = (op) => defOp(MATH(op));\nexport const defMathOpN = (op) => defOp(MATH_N(op), ARGS_VN);\nexport const defBitOp = (op, signed = false) => defOp((signed ? SIGNED : UNSIGNED)(op));\nexport const defBitOpN = (op, signed = false) => defOp((signed ? SIGNED_N : UNSIGNED_N)(op), ARGS_VN);\n","import { compile, compileG } from \"./compile/emit.js\";\nimport { DOT, DOT_G } from \"./compile/templates.js\";\nimport { vop } from \"./vop.js\";\nconst $ = (dim) => dot.add(dim, compile(dim, DOT, \"a,b\", undefined, \"\", \"+\", \"return \", \";\"));\nexport const dot = vop();\ndot.default(compileG(DOT_G, \"a,b\", undefined, \"s\", \"let s=0;\"));\nexport const dot2 = $(2);\nexport const dot3 = $(3);\nexport const dot4 = $(4);\n","import { compile, compileG } from \"./compile/emit.js\";\nimport { vop } from \"./vop.js\";\nconst $ = (dim) => magSq.add(dim, compile(dim, ([a]) => `${a}*${a}`, \"a\", \"a\", \"\", \"+\", \"return \", \";\"));\nexport const magSq = vop();\nmagSq.default(compileG(([a]) => `sum+=${a}*${a};`, \"a\", undefined, \"sum\", \"let sum=0;\"));\nexport const magSq2 = $(2);\nexport const magSq3 = $(3);\nexport const magSq4 = $(4);\n","import { defMathOpN } from \"./compile/emit.js\";\nexport const [mulN, mulN2, mulN3, mulN4] = defMathOpN(\"*\");\n","import { defOp } from \"./compile/emit.js\";\nimport { NEW_OUT, SET } from \"./compile/templates.js\";\nexport const [set, set2, set3, set4] = defOp(SET, \"o,a\", undefined, \"o\", 1, NEW_OUT);\n","import { EPS } from \"@thi.ng/math/api\";\nimport { mag } from \"./mag.js\";\nimport { magSq2, magSq3, magSq4 } from \"./magsq.js\";\nimport { mulN, mulN2, mulN3, mulN4 } from \"./muln.js\";\nimport { set, set2, set3, set4 } from \"./set.js\";\n/**\n * Normalizes vector to given (optional) length (default: 1). If `out`\n * is null, modifies `v` in place.\n *\n * @param out -\n * @param v -\n * @param n -\n */\nexport const normalize = (out, v, n = 1) => {\n    !out && (out = v);\n    const m = mag(v);\n    return m >= EPS ? mulN(out, v, n / m) : out !== v ? set(out, v) : out;\n};\n/**\n * Optimized 2d version of generic {@link normalize}.\n * @param out\n * @param v\n * @param n\n */\nexport const normalize2 = (out, v, n = 1) => {\n    !out && (out = v);\n    const m = Math.sqrt(magSq2(v));\n    return m >= EPS ? mulN2(out, v, n / m) : out !== v ? set2(out, v) : out;\n};\n/**\n * Optimized 3d version of generic {@link normalize}.\n * @param out\n * @param v\n * @param n\n */\nexport const normalize3 = (out, v, n = 1) => {\n    !out && (out = v);\n    const m = Math.sqrt(magSq3(v));\n    return m >= EPS ? mulN3(out, v, n / m) : out !== v ? set3(out, v) : out;\n};\n/**\n * Optimized 4d version of generic {@link normalize}.\n * @param out\n * @param v\n * @param n\n */\nexport const normalize4 = (out, v, n = 1) => {\n    !out && (out = v);\n    const m = Math.sqrt(magSq4(v));\n    return m >= EPS ? mulN4(out, v, n / m) : out !== v ? set4(out, v) : out;\n};\n","import { defMathOp } from \"./compile/emit.js\";\nexport const [sub, sub2, sub3, sub4] = defMathOp(\"-\");\n","/**\n * Simple time-stepping - frame, real-time, constant-step - via any API.\n */\n\nexport const steps = {\n    diff: '-', dt: '-', '': '-',\n    pause: 0, '': 0,\n    add: '+', '': '+'\n};\n\nexport const stepDef = steps.diff;\nexport const startDef = 0;\nexport const nowDef = { [steps.diff]: Date.now, [steps.add]: 1e3/60 };\n\n/**\n * Sets up properties needed to track time, starts/steps time in various ways:\n * - Time-difference or time-advance stepping.\n * - Step forwards or backwards in time or pause it.\n * - Current time can be a number or function; or the object's fixed time-step.\n * - Override property, pass the result to new objects.\n *\n * @example\n *     // Initial call sets up properties.\n *     const diff0 = timer({ step: '-' }, 200);\n *     // => { step: '-', time: 200, dt: 200 };\n *     const add0 = timer({ step: 200 });\n *     // => { step: 200, time: 200, dt: 200 };\n *\n *     // Subsequent calls advance time and track difference.\n *\n *     // No time difference here.\n *     timer(diff0, 200); // => { step: '-', time: 200, dt: 0 };\n *     timer(add0, 0); // => { step: 200, time: 200, dt: 0 };\n *\n *     // Time-difference here with a change or step, into a new result target.\n *     const diff1 = timer(diff0, 300, {});\n *     // => { step: '-', time: 300, dt: 100 };\n *     const add1 = timer(add0, null, {});\n *     // => { step: 200, time: 400, dt: 200 };\n *\n *     diff1.time-diff0.time === diff1.dt; // => true;\n *     add1.time-add0.time === add1.dt; // => true;\n *\n * @param {object} state The state being tracked.\n * @param {number} [state.time=startDef] The initial time.\n * @param {string|number} [state.step=stepDef] How time advances:\n *     - Difference since last `time`: `'diff'`/`'dt'`/`'-'`/`''`.\n *     - Pause: `'pause'`/`''`, or number zero (`0`).\n *     - Add `time` step: `'add'`/`'+'`/`''`, or non-zero number (step size).\n * @param {number|function} [now] The time now (clock/frame/step/etc), or a\n *     function giving it; if not given, uses `state.step` if numeric or\n *     `nowDef[state.step]` otherwise.\n * @param {object|false} [out=state] The state to set up; modifies `state` if\n *     not given.\n *\n * @returns {object|number} The given `out` set up with its initial `time`; or\n *     if `out` is falsey, returns the relevant calculated unknown value:\n *     - The difference since last `time` for `diff` step.\n *     - The updated `time` for `add` or `pause` step.\n */\nexport function timer(state, now, out = state) {\n    // Get the initial time and step-step.\n    const { time: t0 = startDef, step = stepDef, now: n } = state;\n    // Get the step mode - from a key into `steps` or a numerical value.\n    const s = (steps[step] ?? step);\n    const diff = (s === steps.diff);\n    const t = (now ?? n ?? nowDef[s] ?? s);\n\n    // Step by `s`:\n    // - `0` or falsey to `pause`\n    // - `steps.diff` for difference since last `time`\n    // - `steps.add` or a number to add a `time` step\n    const t1 = ((!s)? t0 : ((diff)? 0 : t0)+((isNaN(t))? t() : t));\n    const dt = t1-t0;\n\n    // If only returning a value, return the relevant calculated unknown.\n    if(!out) { return ((diff)? dt : t1); }\n\n    out.time = t1;\n    out.dt = dt;\n    out.step = step;\n\n    return out;\n}\n\nexport default timer;\n","const r = Array.prototype.reduce;\n\n/**\n * Reduce an array-like list.\n * Similar to native, but with iteratee-first arguments.\n * Supports the native single-argument behaviour.\n *\n * @see Array.prototype.reduce\n *\n * @param {function} f Iteratee function, called as `Array`'s `reduce` does.\n * @param {array|*} a List to reduce over, array or array-like.\n * @param {*} [to] The initial accumulator, if any; handled like `Array`'s\n *     `reduce` does, given or not.\n *\n * @returns {*} The result of running the reducer iteratee function over all\n *     elements of the list.\n */\nexport const reduce = (f, a, to) =>\n    // Needs separate `call` because native detects even `undefined` parameter.\n    ((to === undefined)? r.call(a, f) : r.call(a, f, to));\n\nexport default reduce;\n","import { reduce } from './reduce';\n\n/**\n * Map an array-like list.\n * Similar to native, but with iteratee-first arguments; and allows the object\n * into which properties will be mapped to be defined (a new array, by default),\n * avoiding always creating new arrays.\n *\n * @see Array.prototype.map\n * @see [reduce]{@link ./reduce.js}\n *\n * @param {function} f The iteratee function, given standard `Array.map`\n *     arguments, and any given `to`.\n * @param {array|*} a The list to map over, array or array-like.\n * @param {false|*} [to=[]] The initial accumulator, if given; `a` if falsey; or\n *     a new array if not given.\n *\n * @returns {*} The result of mapping `to` through the iteratee function over\n *     the `a` list.\n */\nexport const map = (f, a, to = []) => reduce((to, v, i) => {\n        to[i] = f(v, i, a, to);\n\n        return to;\n    },\n    a, (to || a));\n\nexport default map;\n","const e = Array.prototype.forEach;\n\n/**\n * Iterates a function over every element of a list, returning the list.\n *\n * @see Array.prototype.forEach\n *\n * @param {function} f The iteratee function.\n * @param {array|*} a List to iterate over, array or array-like.\n *\n * @returns {array|*} The given list.\n */\nexport const each = (f, a) => {\n    e.call(a, f);\n\n    return a;\n}\n\nexport default each;\n","const { fill } = Array.prototype;\nconst { isFinite } = Number;\nconst { floor } = Math;\n\n/**\n * Fills list with the given items filled via `Array`'s `fill`.\n *\n * @see Array.constructor\n * @see Array.prototype.fill\n * @see Number.isFinite\n *\n * @param {number|array|*} [l=0] How many items to create, or existing list.\n * @param {*} [value] A value to fill the array with; for `Array`'s `fill`.\n * @param {number} [start] Start index, inclusive; for `Array`'s `fill`.\n * @param {number} [end] End index, exclusive; for `Array`'s `fill`.\n *\n * @returns {array|*} List with items filled as given.\n */\nexport const range = (l = 0, value, start, end) =>\n    fill.call(((isFinite(l))? Array(floor(l)) : l), value, start, end);\n\nexport default range;\n","/**\n * Wraps an index over a given length, so that indexes greater than the length\n * loop back past `0`, and indexes less than `0` loop backward from the length.\n * Similar to the indexing behaviour of `Array`'s `slice`.\n * Indexing is the equivalent of a true _modulo_ operator, where JavaScript's\n * `%` operator is actually a _remainder_ operator.\n *\n * @see Array.prototpye.slice\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder\n *\n * @param {number} i Index to wrap.\n * @param {number} l Length to wrap the index over.\n *\n * @returns {number} The index wrapped over the length.\n */\nexport const wrapIndex = (i, l) => ((i%l)+l)%l;\n\nexport default wrapIndex;\n","import wrapIndex from './wrap-index';\n\n/**\n * Gives an index wrapped over a given length, or the entry at the wrapped\n * index in a given list; wrapped backwards, forwards, never exceeding bounds.\n *\n * @see [wrapIndex]{@link ./wrap-index.js}\n *\n * @param {number} i The index to wrap.\n * @param {number|array|*} l List to index, array or array-like; or numeric\n *     length for a numeric `wrapIndex` result instead.\n * @param {number} [end=l.length] Length to wrap the index over; allows wrapping\n *     over a sub-range of a list; if not given, tries the list's length.\n *\n * @returns {number|*} The index wrapped over the given length by `wrapIndex`;\n *     or the list entry at the wrapped index, if given a list.\n */\nexport const wrap = (i, l, end = l.length) =>\n    ((end || (end === 0))? l[wrapIndex(i, end)] : wrapIndex(i, l));\n\nexport default wrap;\n","/**\n * The 3 vertices of a 2D triangle covering the viewport in NDC coordinates ([-1, 1]).\n *\n * @export\n * @type {array.<array.<number>>}\n */\nexport const vertices = [[-1, -1], [-1, 4], [4, -1]];\n\nexport const count = vertices.length;\nexport const dim = 2;\n\n/**\n * The flat array of the above triangle, to be bound as a WebGL attribute buffer for\n * rendering the triangle in the vertex shader.\n * These positions will result in clipped NDC coordinates ([-1, 1]) over the\n * viewport's width and height.\n *\n * @export\n * @type {array.<number>}\n */\nexport const positions = vertices.flat();\n\nexport default positions;\n","/**\n * Default properties for `gpgpu` and `GL` capabilities and resources.\n *\n * @module\n * @category JS\n */\nimport { positions, count } from '@epok.tech/gl-screen-triangle';\n\nimport vertGLSL from './index.vert.glsl';\n\n/** Default vertex shader `GLSL` code. */\nexport const vertDef = vertGLSL;\n\n/**\n * Default vertex positions `attribute`; 3 points of a large flat triangle.\n *\n * @see {@link step.toStep}\n */\nexport const positionsDef = positions;\n\n/**\n * Default vertex `count`; 3 points of a large flat triangle.\n *\n * @see {@link step.toStep}\n */\nexport const countDef = count;\n\n// The required and optional `GL` extensions for a `gpgpu` state.\n\n/** Default required `GL` extensions; none. */\nexport const extensions = [];\n\n/** Default required `GL` extensions to render to `float` buffers. */\nexport const extensionsFloat =\n  ['oes_texture_float', 'webgl_color_buffer_float'];\n\n/** Default required `GL` extensions to render to `half float` buffers. */\nexport const extensionsHalfFloat =\n  ['oes_texture_half_float', 'ext_color_buffer_half_float'];\n\n/** Default optional `GL` extensions; update more data in one render pass. */\nexport const optionalExtensions = ['webgl_draw_buffers'];\n\n/**\n * Prefix namespace to avoid naming clashes; recommended.\n *\n * @see {@link index.vert.glsl}\n */\nexport const preDef = 'gpgpu_';\n\n/**\n * Default minimum allowable channels for `framebuffer` attachments.\n * This avoids `RGB32F` `framebuffer` attachments, which errors on Firefox.\n *\n * @see {@link state.framebuffer}\n * @see [Firefox `RGB32F` bug](https://bugzilla.mozilla.org/show_bug.cgi?id=1448632)\n */\nexport const channelsMinDef = 4;\n\n/**\n * Default minimum allowable channels for `framebuffer` attachments.\n * This avoids `RGB32F` `framebuffer` attachments, which errors on Firefox.\n *\n * @see {@link state.framebuffer}\n * @see [Firefox `RGB32F` bug](https://bugzilla.mozilla.org/show_bug.cgi?id=1448632)\n */\nexport const channelsMaxDef = 4;\n\n/**\n * Default maximum `texture`s bound per pass.\n *\n * @see {@link state.framebuffer}\n * @see {@link state.texture}\n */\nexport const buffersMaxDef = 1;\n\n/**\n * Default how many steps are bound as outputs, unavailable as input; for\n * platforms forbidding read/write of same buffer.\n */\nexport const boundDef = 1;\n\n/**\n * Default length of the data `texture`s sides to allocate; gives a square\n * power-of-two `texture` raising 2 to this power.\n */\nexport const scaleDef = 9;\n\n/**\n * Default width of the data `texture`s sides to allocate; gives a square\n * power-of-two `texture` raising 2 to the default scale.\n *\n * @see {@link state.framebuffer}\n * @see {@link state.texture}\n */\nexport const widthDef = 2**scaleDef;\n\n/**\n * Default height of the data `texture`s sides to allocate; gives a square\n * power-of-two `texture` raising 2 to the default scale.\n *\n * @see {@link state.framebuffer}\n * @see {@link state.texture}\n */\nexport const heightDef = 2**scaleDef;\n\n/** Default number steps of state to track. */\nexport const stepsDef = 2;\n/** Default values to track; gives 1 set of `texture` channels. */\nexport const valuesDef = [channelsMaxDef];\n\n// `GL` resource format defaults.\n\n/**\n * Default `texture` data type.\n *\n * @see {@link state.texture}\n */\nexport const typeDef = 'float';\n\n/**\n * Default `texture` minification filter.\n *\n * @see {@link state.texture}\n */\nexport const minDef = 'nearest';\n\n/**\n * Default `texture` magnification filter.\n *\n * @see {@link state.texture}\n */\nexport const magDef = 'nearest';\n\n/**\n * Default `texture` wrap mode, avoid `WebGL1` needing power-of-2 `texture`.\n *\n * @see {@link state.texture}\n */\nexport const wrapDef = 'clamp';\n\n/**\n * Default `framebuffer` depth attachment.\n *\n * @see {@link state.framebuffer}\n */\nexport const depthDef = false;\n\n/**\n * Default `framebuffer` stencil attachment.\n *\n * @see {@link state.framebuffer}\n */\nexport const stencilDef = false;\n\n/** Whether states merge into one `texture`; one merged `texture` by default. */\nexport const mergeDef = true;\n\n/**\n * A `RegExp` to find the `GLSL` version `number` in a `GL` parameter\n * `SHADING_LANGUAGE_VERSION` formatted `string`.\n */\nexport const glslRx = /[0-9\\.]+/;\n\n/**\n * Set a maximum to guard against number overflow.\n *\n * @todo Should be `(2**15)-1` for `mediump`, but seems to fail above `2**13`.\n * @see [SO](https://stackoverflow.com/a/67791670/716898)\n */\nexport const stepMaxDef = 2**13;\n\n/**\n * Default clear settings to clear each pass's `framebuffer`.\n *\n * @see {@link step.toStep}\n * @see {@link api.clear}\n * @see {@link api.framebuffer}\n *\n * @type {{color:[0,0,0,0],depth:1,stencil:0,framebuffer?:framebuffer}}\n * @prop {framebuffer} [framebuffer] Any `framebuffer` to clear, set upon each\n *   pass.\n */\nexport const clearPassDef = { color: [0, 0, 0, 0], depth: 1, stencil: 0 };\n\n/**\n * Default `getFramebuffer` options, to bind a given `color` to it.\n *\n * @see {@link step.updateMerge}\n * @see {@link api.framebuffer}\n * @see {@link api.getFramebuffer}\n *\n * @prop {texture|null} color Any `texture` to bind as a `framebuffer` output.\n */\nexport const copyFrameDef = { color: null };\n\n/**\n * Default `texture.subimage` options, to bind a given `color`.\n *\n * @see {@link step.updateMerge}\n * @see {@link api.texture}\n * @see {@link api.subimage}\n *\n * @prop {true} copy Indicates `texture.subimage` should copy data from the\n *   currently-bound `framebuffer`.\n */\nexport const copyImageDef = { copy: true };\n","/**\n * Default `gpgpu` vertex shader.\n *\n * @see [@epok.tech/gl-screen-triangle/uv-texture.vert.glsl](https://github.com/keeffEoghan/gl-screen-triangle/tree/master/uv-texture.vert.glsl)\n */\n\nprecision highp float;\n\n/**\n * Uses the default prefix namespace; replaced with any given prefix if this\n * shader's used during `toStep`.\n *\n * @see {@link const.preDef}\n * @see {@link step.toStep}\n */\nattribute vec2 gpgpu_position;\n\nvarying vec2 uv;\n\nvoid main() {\n  // Texture coordinates, range `[0, 1]`, y-axis points upwards.\n  uv = (gpgpu_position*0.5)+0.5;\n  gl_Position = vec4(gpgpu_position, 0, 1);\n}\n","/**\n * The `gpgpu` maps of data for optimal inputs/outputs on a platform.\n *\n * These maps show how to make optimal use of a platform's supported features,\n * how to pack/unpack their data from `framebuffer`s/`texture`s, perform minimal\n * needed samples to retrieve any past values they must derive from, etc.\n *\n * Shaders may declare values they output, values they derive from, groupings of\n * in/dependent values - without handling how these concerns map to the\n * particular platform resources they're using.\n *\n * Platform limits/features/extensions are accounted for, to produce the most\n * efficient mappings available with the least I/O when it comes to drawing\n * (draw passes, `texture` samples, etc).\n *\n * @module\n * @category JS\n *\n * @todo Allow passes within/across `texture`s; separate data/`texture` shapes.\n */\n\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport each from '@epok.tech/fn-lists/each';\n\nimport { valuesDef, channelsMaxDef, buffersMaxDef } from './const';\n\nconst { isInteger } = Number;\n\n/**\n * Determines whether a given value is valid and can be stored within the\n * channels available.\n *\n * @param {number} value A value to validate.\n * @param {number} [channelsMax] The maximum channels available to store values.\n *\n * @returns {boolean} Whether the given `value` is valid.\n */\nexport const validValue = (value, channelsMax = channelsMaxDef) =>\n  ((1 <= value) || (value <= channelsMax) ||\n    !!console.error(`\\`gl-gpgpu\\`: the given value (${value}) exceeds the `+\n      `range of channels available, \\`[1, ${channelsMax}]\\` inclusive.`,\n      value, channelsMax));\n\n/**\n * Minimise resource usage, order `values` to pack into blocks of `channelsMax`;\n * interpreted as indexes into the given `values`.\n *\n * @see {@link mapGroups}\n *\n * @example ```\n *   packValues([1, 2, 3], 4, []); // =>\n *   [2, 0, 1];\n *\n *   packValues([3, 2, 1], 4, []); // =>\n *   [0, 2, 1];\n *\n *   packValues([4, 3, 2], 4, []); // =>\n *   [0, 1, 2];\n *\n *   packValues([1, 1, 4, 2], 4, []); // =>\n *   [2, 3, 0, 1];\n * ```\n *\n * @param {array.<number>} values Each entry is how many interdependent channels\n *   are grouped into one texture in one pass, separate entries may be across\n *   one or more textures/passes. See `mapGroups`.\n * @param {number} [channelsMax=channelsMaxDef] The maximum number of channels\n *   per texture. See `mapGroups`.\n * @param {array} [to=[]] An `array` to store the result; a new `array` if not\n *   given.\n *\n * @returns {array.<number>} `to` The indexes of the given `values`, reordered\n *   to pack into the fewest buckets of `channelsMax` size or less; stored in\n *   the given `to` array.\n */\nexport function packValues(values, channelsMax = channelsMaxDef, to = []) {\n  // Fill `to` with indexes of `values`, and ensure it's the same length.\n  map((_, i) => i, values, to).length = values.length;\n\n  /** Counts the number of empty channels in the current group. */\n  let channels = channelsMax;\n  /** How many values have already been packed. */\n  let packed = 0;\n  /** Tracks the value that best fits the free channels (fills it tightest). */\n  let fitIndex = 0;\n  let fitSize = Infinity;\n\n  for(let i = 0; packed < values.length;) {\n    const v = packed+i;\n    const value = values[to[v]];\n\n    if(!validValue(value, channelsMax)) { return to; }\n\n    // Check how value fits the channels - valid is >= 0, perfect is 0.\n    const fit = channels-value;\n\n    if((fit >= 0) && (fit < fitSize)) {\n      fitSize = fit;\n      fitIndex = v;\n    }\n\n    // Not a perfect fit and can keep searching for better fits - continue.\n    if((fitSize !== 0) && (v < values.length-1)) { ++i; }\n    else {\n      // Got a perfect fit or the search ended - swap in best fit value.\n      const pack = to[fitIndex];\n\n      to[fitIndex] = to[packed];\n      to[packed] = pack;\n\n      // Reduce the free channels by the best value, reset if needed.\n      ((channels -= values[pack]) > 0) || (channels = channelsMax);\n      // Start the search again over the remaining unpacked entries.\n      fitIndex = ++packed;\n      fitSize = Infinity;\n      i = 0;\n    }\n  }\n\n  return to;\n}\n\n/**\n * Groups the `values` of `gpgpu` data across draw passes and data textures.\n *\n * @see {@link packValues}\n *\n * @example ```\n *   const x = 2;\n *   const y = 4;\n *   const z = 1;\n *   const maps = { values: [x, y, z], channelsMax: 4 };\n *\n *   // No optimisations - values not packed, single texture output per pass.\n *   mapGroups({ ...maps, buffersMax: 1, packed: false }); // =>\n *   {\n *     ...maps, packed: false,\n *     textures: [[0], [1], [2]], // length === 3\n *     passes: [[0], [1], [2]], // length === 3\n *     valueToTexture: [0, 1, 2], valueToPass: [0, 1, 2],\n *     textureToPass: [0, 1, 2]\n *   };\n *\n *   // Automatically packed values - values across fewer textures/passes.\n *   mapGroups({ ...maps, buffersMax: 1 }); // =>\n *   {\n *     ...maps, packed: [1, 0, 2],\n *     textures: [[1], [0, 2]], // length === 2\n *     passes: [[0], [1]], // length === 2\n *     valueToTexture: [1, 0, 1], valueToPass: [1, 0, 1],\n *     textureToPass: [0, 1]\n *   };\n *\n *   // Can bind more texture outputs per pass - values across fewer passes.\n *   mapGroups({ ...maps, buffersMax: 4 }); // =>\n *   {\n *     ...maps, packed: [1, 0, 2],\n *     textures: [[1], [0, 2]], // length === 2\n *     passes: [[0, 1]], // length === 1\n *     valueToTexture: [1, 0, 1], valueToPass: [0, 0, 0],\n *     textureToPass: [0, 0]\n *   };\n *\n *   // Custom packed values - fuller control.\n *   mapGroups({ ...maps, buffersMax: 4, packed: [0, 2, 1] }); // =>\n *   {\n *     ...maps, packed: [0, 2, 1],\n *     textures: [[0, 2], [1]], // length === 2\n *     passes: [[0, 1]], // length === 1\n *     valueToTexture: [0, 1, 0], valueToPass: [0, 0, 0],\n *     textureToPass: [0, 0]\n *   };\n *\n *   // Merge dependent values - fuller control, but no map for merged values.\n *   mapGroups({ ...maps, values: [x+z, y], buffersMax: 4 }); // =>\n *   {\n *     ...maps, packed: [1, 0],\n *     textures: [[1], [0]], // length === 2\n *     passes: [[0, 1]], // length === 1\n *     valueToTexture: [1, 0], valueToPass: [0, 0],\n *     textureToPass: [0, 0]\n *   };\n * ```\n *\n * @param {object} [maps=\\{\\}] Initial maps settings; new `object` if not given.\n *\n * @param {array.<number>} [maps.values=valuesDef()] An `array` where each\n *   `number` denotes how many value channels are grouped into one data-texture\n *   in one draw pass (where any value map logic isn't handled here); each\n *   separate number may be computed across one or more data-textures/passes.\n *\n *   Each value denotes the number of dependent channels to compute together;\n *   separate values denote channels that are independent, and may be drawn in\n *   the same or separate passes, depending on settings/support.\n *\n *   The order may affect the number of textures/passes needed; can maintain\n *   order as-is, or use a more efficient `packed` order. See `packValues`.\n *\n * @param {number} [maps.channelsMax=channelsMaxDef] Maximum channels per\n *   texture.\n * @param {number} [maps.buffersMax=buffersMaxDef] Maximum textures bound per\n *   pass.\n * @param {array.<number>} [maps.packed] An `array` of indexes into `values`\n *   packed into an order that best fits into blocks of `channelsMax` to\n *   minimise resources; or `false`y to use `values` in their given order; uses\n *   `packValues` if not given.\n * @param {object} [to=maps] An `object` to contain the results; modifies `maps`\n *   if not given.\n *\n * @returns {object} `to` The given `to` `object`; how `values` are grouped\n *   per-texture per-pass per-step, meta information, and given parameters.\n * @returns {array.<array.<number>>} `to.passes` Textures grouped into passes,\n *   as `arrays` corresponding to `framebuffer`s in separate draw passes; whose\n *   values are indexes into `to.textures`.\n * @returns {array.<array.<number>>} `to.textures` Values grouped into\n *   textures, as `array`s corresponding to `framebuffer` attachments, into\n *   which `values` are drawn; whose values are indexes into `to.values`.\n * @returns {array.<number>} `to.values` The `values`, as given.\n * @returns {number} `to.buffersMax` The max textures per pass, as given.\n * @returns {number} `to.channelsMax` The max channels per-texture, as given.\n * @returns {array.<number>} `to.valueToTexture` Inverse map from each index of\n *   `to.values` to the index of the data-texture containing it.\n * @returns {array.<number>} `to.valueToPass` Inverse map from each index of\n *   `to.values` to the index of the pass containing it.\n * @returns {array.<number>} `to.textureToPass` Inverse map from each index of\n *   `to.textures` to the index of the pass containing it.\n */\nexport function mapGroups(maps = {}, to = maps) {\n  const {\n      values = valuesDef(),\n      buffersMax = buffersMaxDef, channelsMax = channelsMaxDef,\n      // Pack `values` into blocks of `channelsMax` to minimise resources.\n      packed = packValues(values, channelsMax)\n    } = maps;\n\n  // Ensure any properties changed are included.\n  to.values = values;\n  to.buffersMax = buffersMax;\n  to.channelsMax = channelsMax;\n  to.packed = packed;\n\n  const passes = to.passes = [[]];\n  const textures = to.textures = [[]];\n  const valueToTexture = to.valueToTexture = [];\n  const valueToPass = to.valueToPass = [];\n  const textureToPass = to.textureToPass = [];\n  /** Counts the number of channels written in a single draw pass. */\n  let channels = 0;\n  // Get the value, via `packed` if valid, or directly as given in `values`.\n  const getValue = ((packed)? ((_, i) => values[i]) : ((v) => v));\n  const getIndex = ((packed)? ((i) => packed[i]) : ((i) => i));\n\n  return reduce((to, v, i) => {\n      const index = getIndex(i);\n      const value = getValue(v, index);\n\n      if(!validValue(value, channelsMax)) { return to; }\n\n      let p = passes.length-1;\n      let pass = passes[p];\n      let t = textures.length-1;\n      let texture = textures[t];\n\n      if((channels += value) > channelsMax) {\n        channels = value;\n        t = textures.push(texture = [])-1;\n        (pass.length >= buffersMax) && (p = passes.push(pass = [])-1);\n        pass.push(t);\n        textureToPass.push(p);\n      }\n      else if(pass.length === 0) {\n        pass.push(t);\n        textureToPass.push(p);\n      }\n\n      texture.push(index);\n      valueToTexture[index] = t;\n      valueToPass[index] = p;\n\n      return to;\n    },\n    values, to);\n}\n\n/**\n * Maps the minimal set of texture reads to derive the next state of values from\n * a past state of values they depend upon.\n *\n * @see {@link mapGroups}\n *\n * @example ```\n *   const maps = mapGroups({\n *     // See `mapGroups` examples for resulting maps.\n *     values: [2, 4, 1], channelsMax: 4, buffersMax: 1, packed: false,\n *     // Derived step/value indexes, per-value; sample entries include:\n *     derives: [\n *       // Single...\n *       2,\n *       // Empty...\n *       ,\n *       // Multiple...\n *       [\n *         // Defined step...\n *         [1, 0],\n *         // All values at any given level/step...\n *         true\n *       ]\n *     ]\n *   });\n *\n *   mapSamples(maps); // =>\n *   {\n *     ...maps,\n *     // Minimum texture samples for values; nested per-pass, per-value.\n *     // Deepest arrays are step/texture index pairs into `maps.textures`.\n *     samples: [\n *       [[0, 2]],\n *       null,\n *       [[1, 0], [0, 0], [0, 1], [0, 2]]\n *     ],\n *     // Value indexes into `to.samples`; nested per-pass, per-value.\n *     // Map from a value index to data it needs in the minimal samples.\n *     reads: [\n *       [[0]],\n *       null,\n *       [null, null, [0, 1, 2, 3]]\n *     ]\n *   };\n * ```\n *\n * @param {object} maps How values are grouped per-`texture` per-pass per-step.\n *   See `mapGroups`.\n * @param {true|array} [maps.derives] How any new values derive from past\n *   values. If not given `false`y, this returns with no changes.\n * @param {true|number|array} [maps.derives.[]] L1\n * @param {true|number|array} [maps.derives.[].[]] L2\n * @param {true|number} [maps.derives.[].[].[]] L3\n *\n * @param {true|array.<true,number,array.<true,number,array.<true,number>>>} [maps.derives]\n *   How values derive from past values.\n *\n *   If given as a sparse array, each entry relates the corresponding value to\n *   any past value steps/indexes it derives from - a value not derived from\n *   past values may have an empty/null entry; a value derives from past\n *   values where its entry has:\n *   - Numbers; deriving from the most recent state at the given value index.\n *   - Lists of numbers; deriving from the given past state index (1st number\n *     denotes how many steps ago), at the given value index (2nd number).\n *\n *   The nested hierarchy thus has any `pass,[values,[value,[step, value]]]`.\n *   If any level is given as `true`, maps to sample all values, at the given\n *   step (or most recent step, if none given).\n *\n *   If no `derives` given, no samples are mapped, `to` is returned unchanged.\n *\n * @param {array.<array.<number>>} maps.passes Textures grouped into passes. See\n *   `mapGroups`.\n * @param {array.<array.<number>>} maps.textures Values grouped into textures. See\n *   `mapGroups`.\n * @param {array.<number>} maps.valueToTexture Inverse map from each value index\n *   to the data texture index containing it.\n * @param {object} [to=maps] The object to store the result in; `maps` if not\n *   given.\n *\n * @returns {object} `to` The given `to` object, with resulting maps added for\n *   any given `maps.derives`.\n * @returns {array.<array.<array.<number>>>} `[to.samples]` Map of the minimum\n *   set of indexes into `maps.textures` that need to be sampled per-pass,\n *   to get all `derives` needed for each value of `maps.values` of each\n *   pass of `maps.passes`.\n * @returns {array.<array.<array.<number>>>} `[to.reads]` Sparse map from\n *   each value of `derives` to its step and texture indexes in `to.samples`.\n * @returns {true|array.<true,number,array.<true,number,array.<true,number>>>}\n *   `[to.derives]` How new values derive from past values, as given.\n */\nexport function mapSamples(maps = {}, to = maps) {\n  const { derives, passes, textures, valueToTexture } = maps;\n\n  if(!derives) { return to; }\n\n  const reads = to.reads = [];\n  const cache = {};\n\n  const all = (step = 0) =>\n    cache[step] ??= map((t, v) => [step, v], valueToTexture);\n\n  const getAddSample = (pass, value) => function add(set, derive, d) {\n    let step = 0;\n    let texture;\n\n    if(derive === true) { return reduce(add, all(step), set); }\n    else if(isInteger(derive)) { texture = valueToTexture[derive]; }\n    else if(derive[1] === true) { return reduce(add, all(derive[0]), set); }\n    else {\n      step = derive[0];\n      texture = valueToTexture[derive[1]];\n    }\n\n    if(!(isInteger(step) && isInteger(texture))) {\n      return console.error('`mapSamples`: invalid map for sample',\n        derives, maps, pass, value, derive, d, step, texture);\n    }\n\n    // Create the set if not already created.\n    const to = (set || []);\n    // Check for any existing matching step/texture read in the set.\n    const i = to.findIndex(([s, t]) => (s === step) && (t === texture));\n\n    // Add the read for this value in this pass; creating any needed maps.\n    ((reads[pass] ??= [])[value] ??= [])\n      // A new read as needed, or any existing matching read.\n      .push((i < 0)? to.push([step, texture])-1 : i);\n\n    return to;\n  };\n\n  const getAddSamples = (pass) => (set, value) => {\n    const valueDerives = ((derives === true)? derives : derives[value]);\n\n    return ((!valueDerives && (valueDerives !== 0))? set\n      : (((valueDerives === true) || isInteger(valueDerives))?\n        getAddSample(pass, value)(set, valueDerives)\n      : reduce(getAddSample(pass, value), valueDerives, set)));\n  }\n\n  to.samples = map((pass, p) => reduce((set, texture) =>\n        reduce(getAddSamples(p), textures[texture], set),\n      pass, null),\n    passes, []);\n\n  return to;\n}\n\n/**\n * Maps a full step, creates maps grouping given values per-`texture` per-pass\n * per-step, and minimal samples and reads if new values derive from past ones.\n *\n * @see {@link mapGroups}\n * @see {@link mapSamples}\n *\n * @param {object} [maps] Input value maps and settings.\n * @param {object} [to=maps] An `object` to contain the results; modifies `maps`\n *   if not given.\n *\n * @returns {object} `to` The given `to` object; how `values` are grouped\n *   per-`texture` per-pass per-step, meta information, and given parameters;\n *   and minimal samples and reads for any given `maps.derives`.\n */\nexport const mapStep = (maps, to = maps) => mapSamples(mapGroups(maps, to), to);\n\nexport default mapStep;\n","/**\n * @module\n * @category JS\n */\n\nimport map from '@epok.tech/fn-lists/map';\nimport range from '@epok.tech/fn-lists/range';\n\nconst { isFinite, isInteger } = Number;\n\n/**\n * Returns the given width, for various properties in order of precedence.\n *\n * @see {@link data.toData}\n *\n * @param {object} value Size (width) `number`, or an `object` containing it.\n * @param {number} [value.width] Width; supersedes further aliases.\n * @param {number} [value.w] Alias of `width`; supersedes further aliases.\n * @param {number} [value.x] Alias of `width`; supersedes further aliases.\n * @param {object} [value.shape] Shape (width) `number`, or an `object`\n *   containing it; supersedes further aliases.\n * @param {object} [value.size] Size (width) `number`, or an `object`\n *   containing it; supersedes further aliases.\n * @param {number} [value.side] Width and height; supersedes further aliases.\n * @param {number} [value.0] Alias of `width`; supersedes `value` itself.\n *\n * @returns {number} The width as given in one of the expected properties, or\n *   any given `value` number, or `null`ish if no width could be resolved.\n */\nexport function getWidth(value) {\n  const { width, w, x, shape, size, side, 0: v0 } = value;\n\n  return width ?? w ?? x ??\n    (shape && getWidth(shape)) ?? (size && getWidth(size)) ??\n    side ?? v0 ?? ((isFinite(value))? value : null);\n}\n\n/**\n * Returns the given height, for various properties in order of precedence.\n *\n * @see {@link data.toData}\n *\n * @param {object} value Size (height) `number`, or an `object` containing it.\n * @param {number} [value.height] Height; supersedes further aliases.\n * @param {number} [value.h] Alias of `height`; supersedes further aliases.\n * @param {number} [value.y] Alias of `height`; supersedes further aliases.\n * @param {object} [value.shape] Shape (height) `number`, or an `object`\n *   containing it; supersedes further aliases.\n * @param {object} [value.size] Size (height) `number`, or an `object`\n *   containing it; supersedes further aliases.\n * @param {number} [value.side] Width and height; supersedes further aliases.\n * @param {number} [value.1] Alias of `height`; supersedes `value` itself.\n *\n * @returns {number} The height as given in one of the expected properties, or\n *   any given `value` number, or `null`ish if no height could be resolved.\n */\nexport function getHeight(value) {\n  const { height, h, y, shape, size, side, 1: v1 } = value;\n\n  return height ?? h ?? y ??\n    (shape && getHeight(shape)) ?? (size && getHeight(size)) ??\n    side ?? v1 ?? ((isFinite(value))? value : null);\n}\n\n/**\n * Gives the number of entries to draw a full state, for various parameters.\n * Effectively equivalent to `gl_VertexID` in `WebGL2`.\n *\n * @see {@link getWidth}\n * @see {@link getHeight}\n * @see {@link data.toData}\n *\n * @param {object} [size=1] Size `number` of data resources, or an `object`\n *   containing it; width if `height` is given as a second parameter.\n *   See `getWidth` and `getHeight`.\n * @param {number} [size.entries] The `number` of entries of data resources.\n * @param {object} [height=1] Height `number` of data resources, or an `object`\n *   containing it.\n *\n * @returns {number} The number of entries needed to draw a full state; each\n *   entry of a data-texture (its area, equivalent to `state.size.entries`).\n */\nexport const countDrawEntries = (size = 1, height = 1) =>\n  size?.entries ?? (getWidth(size) ?? 1)*(getHeight(height) ?? 1);\n\n/**\n * Gives the `array` of indexes needed to draw a full state.\n *\n * @param {object} size The `number` of entries in each data-`texture`; or an\n *   `object` of size/type of data resources.\n *\n * @returns {array.<number>} An `array` of indexes for drawing all\n *   data-`texture` entries, numbered `0` to `size-1`.\n */\nexport const getDrawIndexes = (size) =>\n  map((_, i) => i, range(isInteger(size)? size : countDrawEntries(size)), 0);\n\n/**\n * 2 raised to the given numeric power, or `null` if not given.\n *\n * @param {number} [scale] The power to raise 2 to.\n *\n * @returns 2 raised to the given numeric power, or `null` if not given.\n */\nexport const getScaled = (scale) => ((isFinite(scale))? 2**scale : null);\n","/**\n * The `gpgpu` state and `GL` data resources.\n *\n * Handles `framebuffer`s, `texture`s; and the main meta info.\n *\n * @module\n * @category JS\n *\n * @todo Allow passes into or across `texture`s; separate shapes of data and\n *   `texture`s.\n * @todo In-place updates of complex resources and meta info.\n */\n\nimport range from '@epok.tech/fn-lists/range';\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\n\nimport { getWidth, getHeight, getScaled } from './size';\n\nimport {\n    widthDef, heightDef, stepsDef, valuesDef, channelsMinDef, typeDef,\n    minDef, magDef, wrapDef, depthDef, stencilDef, mergeDef\n  } from './const';\n\nconst { isInteger } = Number;\n\n/**\n * Set up the `gpgpu` resources and meta info for a state of a number data.\n *\n * @example ```\n *   const api = {\n *     framebuffer: ({ depth, stencil, width, height, color }) => null,\n *     texture: ({ type, min, mag, wrap, width, height, channels }) => null\n *   };\n *\n *   // Example with `webgl_draw_buffers` extension support, for 4 buffers.\n *   let maps = mapGroups({ values: [1, 2, 3], buffersMax: 4, packed: 0 });\n *   let state = { steps: 2, side: 10, maps };\n *\n *   const s0 = toData(api, state, {}); // =>\n *   {\n *     ...state,\n *     size: {\n *       steps: 2, passes: 2, textures: 4,\n *       width: 10, height: 10, shape: [10, 10], entries: 100\n *     },\n *     steps: [[s0.passes[0][0].framebuffer], [s0.passes[1][0].framebuffer]],\n *     // This setup results in fewer passes, as more buffers can be bound.\n *     passes: [\n *       [\n *         {\n *           framebuffer: api.framebuffer(s0.passes[0][0]),\n *           color: [s0.textures[0][0].texture, s0.textures[0][1].texture],\n *           map: [0, 1], // maps.passes[0]\n *           entry: 0, index: 0, step: 0,\n *           depth: false, stencil: false, width: 10, height: 10\n *         }\n *       ],\n *       [\n *         {\n *           framebuffer: api.framebuffer(s0.passes[1][0]),\n *           color: [s0.textures[1][0].texture, s0.textures[1][1].texture],\n *           map: [0, 1], // maps.passes[0]\n *           entry: 1, index: 0, step: 1,\n *           depth: false, stencil: false, width: 10, height: 10\n *         }\n *       ]\n *     ],\n *     textures: [\n *       [\n *         {\n *           texture: api.texture(s0.textures[0][0]),\n *           map: [0, 1], // maps.textures[0]\n *           entry: 0, index: 0, step: 0, pass: 0,\n *           type: 'float', width: 10, height: 10, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         },\n *         {\n *           texture: api.texture(s0.textures[0][1]),\n *           map: [2], // maps.textures[1]\n *           entry: 1, index: 1, step: 0, pass: 0,\n *           type: 'float', width: 10, height: 10, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         }\n *       ],\n *       [\n *         {\n *           texture: api.texture(s0.textures[1][0]),\n *           map: [0, 1], // maps.textures[0]\n *           entry: 2, index: 0, step: 1, pass: 0,\n *           type: 'float', width: 10, height: 10, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         },\n *         {\n *           texture: api.texture(s0.textures[1][1]),\n *           map: [2], // maps.textures[1]\n *           entry: 3, index: 1, step: 1, pass: 0,\n *           type: 'float', width: 10, height: 10, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         }\n *       ]\n *     ]\n *   };\n *\n *   // Example with no `webgl_draw_buffers` extension support, only 1 buffer.\n *   maps = mapGroups({ values: [1, 2, 3], buffersMax: 1, packed: 0 });\n *   state = { type: 'uint8', steps: 2, scale: 5, maps };\n *\n *   const s1 = toData(api, state, {}); // =>\n *   {\n *     ...state,\n *     size: {\n *       steps: 2, passes: 4, textures: 4,\n *       width: 32, height: 32, shape: [32, 32], entries: 1024\n *     },\n *     steps: [\n *       [s1.passes[0][0].framebuffer, s1.passes[0][1].framebuffer],\n *       [s1.passes[1][0].framebuffer, s1.passes[1][1].framebuffer]\n *     ],\n *     // This setup results in more passes, as fewer buffers can be bound.\n *     passes: [\n *       [\n *         {\n *           framebuffer: api.framebuffer(s1.passes[0][0]),\n *           color: [s1.textures[0][0].texture],\n *           map: [0], // maps.passes[0]\n *           entry: 0, index: 0, step: 0,\n *           depth: false, stencil: false, width: 32, height: 32\n *         },\n *         {\n *           framebuffer: api.framebuffer(s1.passes[0][1]),\n *           color: [s1.textures[0][1].texture],\n *           map: [1], // maps.passes[1]\n *           entry: 1, index: 1, step: 0,\n *           depth: false, stencil: false, width: 32, height: 32\n *         }\n *       ],\n *       [\n *         {\n *           framebuffer: api.framebuffer(s1.passes[1][0]),\n *           color: [s1.textures[1][0].texture],\n *           map: [0], // maps.passes[0]\n *           entry: 2, index: 0, step: 1,\n *           depth: false, stencil: false, width: 32, height: 32\n *         },\n *         {\n *           framebuffer: api.framebuffer(s1.passes[1][1]),\n *           color: [s1.textures[1][1].texture],\n *           map: [1], // maps.passes[1]\n *           entry: 3, index: 1, step: 1,\n *           depth: false, stencil: false, width: 32, height: 32\n *         }\n *       ]\n *     ],\n *     textures: [\n *       [\n *         {\n *           texture: api.texture(s1.textures[0][0]),\n *           map: [0, 1], // maps.textures[0]\n *           entry: 0, index: 0, step: 0, pass: 0,\n *           type: 'uint8', width: 32, height: 32, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         },\n *         {\n *           texture: api.texture(s1.textures[0][1]),\n *           map: [2], // maps.textures[1]\n *           entry: 1, index: 1, step: 0, pass: 1,\n *           type: 'uint8', width: 32, height: 32, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         }\n *       ],\n *       [\n *         {\n *           texture: api.texture(s1.textures[1][0]),\n *           map: [0, 1], // maps.textures[0]\n *           entry: 2, index: 0, step: 1, pass: 0,\n *           type: 'uint8', width: 32, height: 32, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         },\n *         {\n *           texture: api.texture(s1.textures[1][1]),\n *           map: [2], // maps.textures[1]\n *           entry: 3, index: 1, step: 1, pass: 1,\n *           type: 'uint8', width: 32, height: 32, channels: 4,\n *           min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *         }\n *       ]\n *     ]\n *   };\n * ```\n *\n * @todo Example using `merge`.\n *\n * @see {@link api.texture}\n * @see {@link api.framebuffer}\n * @see {@link maps.mapGroups}\n * @see {@link maps.mapSamples}\n * @see {@link step.toStep}\n * @see {@link macros.macroSamples}\n * @see {@link macros.macroTaps}\n * @see {@link macros.macroPass}\n * @see {@link size.getWidth}\n * @see {@link size.getHeight}\n * @see {@link size.getScaled}\n *\n * @see [`sampler array index must be a literal expression`](https://stackoverflow.com/a/60110986/716898)\n * @see [`sampler2DArray`](https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_2d_array.html)\n * @see [`sampler3D`](https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_3d.html)\n *\n * @param {object} api The API for `GL` resources.\n * @param {texture} [api.texture] Function creating `GL` `texture`s.\n * @param {framebuffer} [api.framebuffer] Function creating `GL` `framebuffer`s.\n * @param {object} [state=\\{\\}] The state parameters.\n *\n * @param {number} [state.width=widthDef] Data width, aliases follow in order\n *   of precedence. See `getWidth`.\n * @param {number} [state.w] Alias of `state.width`. See `getWidth`.\n * @param {number} [state.x] Alias of `state.width`. See `getWidth`.\n * @param {number} [state.0] Alias of `state.width`. See `getWidth`.\n *\n * @param {number} [state.height=heightDef] Data height, aliases follow in order\n *   of precedence. See `getHeight`.\n * @param {number} [state.h] Alias of `state.height`. See `getHeight`.\n * @param {number} [state.y] Alias of `state.height`. See `getHeight`.\n * @param {number} [state.1] Alias of `state.height`. See `getHeight`.\n * @param {number} [state.shape] Data size. See `getWidth` and `getHeight`.\n * @param {number} [state.size] Data size. See `getWidth` and `getHeight`.\n * @param {number} [state.side] Data size of width/height.\n *   See `getWidth` and `getHeight`.\n * @param {number} [state.scale=scaleDef] Data size of width/height as a square\n *   power-of-two size, 2 raised to this power. See `getScaled`.\n *\n * @param {number|array} [state.steps=stepsDef] How many steps of state to\n *   track, or the list of states if already set up.\n * @param {object} [state.maps] How `state.maps.values` are grouped\n *   per-`texture` per-pass per-step. See `mapGroups`.\n * @param {array.<number>} [state.maps.values=valuesDef()] How values of each\n *   data item may be grouped into `texture`s across passes; set up here if not\n *   given. See `mapGroups`.\n * @param {number} [state.maps.channelsMin=channelsMinDef] The minimum allowed\n *   channels for `framebuffer` attachments; allocates unused channels as needed\n *   to reach this limit.\n * @param {number} [state.maps.textures] How values are grouped into `texture`s.\n *   See `mapGroups`.\n *\n * @param {string} [state.type=typeDef] Any `texture` data type value.\n * @param {string} [state.min=minDef] Any `texture` minification filter value.\n * @param {string} [state.mag=magDef] Any `texture` magnification filter value.\n * @param {string} [state.wrap=wrapDef] Any `texture` wrap mode value.\n * @param {object} [state.depth=depthDef] Any `framebuffer` depth attachment, or\n *   a flag for whether it should be created.\n * @param {object} [state.stencil=stencilDef] Any `framebuffer` stencil\n *   attachment, or a flag for whether it should be created.\n *\n * @param {object} [state.merge=mergeDef] Whether to merge states into\n *   one `texture`; `true`y handles merging here, with any given properties used\n *   as-is (the merged `texture` already set up); `false`y uses un-merged\n *   `array`s of `texture`s.\n *\n *   Merging allows shaders to access past steps by non-constant lookups; e.g:\n *   attributes cause `\"sampler array index must be a literal expression\"` on\n *   `GLSL3` spec and some platforms (e.g: `D3D`); but takes more work to copy\n *   the last pass's bound `texture`/s to merge into the past `texture`, so\n *   should be used to variably access past steps or avoid limits of `array`s of\n *   `texture`s.\n *   Only this merged past `texture` and those bound in an active pass are\n *   created, as upon each pass the output will be copied to the past `texture`,\n *   and bound `texture`s reused in the next pass.\n *   If not merging, all state is as output by its pass in its own one of the\n *   `array`s of `texture`s.\n *\n *   The default merged `texture` is laid out as `[texture, step]` on the\n *   `[x, y]` axes, respectively; if other layouts are needed, the merge\n *   `texture` can be given here to be used as-is, and the merging/copying and\n *   lookup logic in their respective hooks. See `toStep` and `macroTaps`.\n *   If a merge `texture` is given, size information is interpreted in a similar\n *   way and precedence as it is from `state`. See `getWidth` and `getHeight`.\n *\n * @param {number} [state.merge.width] Merged data width, aliases follow in\n *   order of precedence. See `state`.\n * @param {number} [state.merge.w] Alias of `state.merge.width`. See `state`.\n * @param {number} [state.merge.x] Alias of `state.merge.width`. See `state`.\n * @param {number} [state.merge.0] Alias of `state.merge.width`. See `state`.\n * @param {number} [state.merge.height] Merged data height, aliases follow in\n *   order of precedence. See `state`.\n * @param {number} [state.merge.h] Alias of `state.merge.height`. See `state`.\n * @param {number} [state.merge.y] Alias of `state.merge.height`. See `state`.\n *   See `state`.\n * @param {number} [state.merge.1] Alias of `state.merge.height`. See `state`.\n * @param {number} [state.merge.shape] Merged data size. See `state`.\n * @param {number} [state.merge.size] Merged data size. See `state`.\n * @param {number} [state.merge.side] Merged data size of width/height.\n * @param {number} [state.merge.scale] Merged data size of width/height as a\n *   square power-of-two size, 2 raised to this power. See `state`.\n *\n * @param {object} [to=state] The state object to set up. Modifies the given\n *   `state` object by default.\n *\n * @returns {object} `to` The state object, set up with the data resources and\n *   meta information, for use with `toStep` and drawing:\n * @returns {object.<number,array.<number,array.<number>>>} `to.maps` Any given\n *   `state.maps`. See `mapGroups`.\n * @returns {array.<array.<object.<texture,string,number,array.<number>>>>}\n *   `to.textures` The `texture`s per-step, as `array`s of objects of `texture`s\n *   and meta info. See `to.maps.textures`.\n * @returns {array.<array.<object.<framebuffer,number,array.<number>>>>}\n *   `to.passes` Passes per step, as `array`s of objects of `framebuffer`s,\n *   referencing `to.textures`, and meta info. See `to.maps.passes`.\n * @returns {array.<framebuffer<array.<texture>>>} `to.steps`\n *   Hierarchy of steps of state, as an `array` of `framebuffer`s from\n *   `to.passes`, with `array`s of `texture`s from `to.textures`, and meta\n *   information; set up here, or the given `state.steps` if it's an `array`.\n *   State data may be drawn into the `framebuffer`s accordingly.\n *   See `mapGroups` and `toStep`.\n * @returns {object|undefined} `[to.merge]` If merging, a given or new merged\n *   `texture` and copier `framebuffer`, with meta info. See `toStep` and\n *   `macroTaps`.\n * @returns {object.<texture,string,number>|undefined} `[to.merge.all]` Any\n *   given `state.merge.all`, or newly-created merged `texture` and meta info.\n * @returns {object.<framebuffer,string,number>|undefined} `[to.merge.next]` Any\n *   given `state.merge.next`, or newly-created `framebuffer` and meta info; for\n *   copying each pass's data into the `merge`d `texture`.\n * @returns {object} `to.size` Size/type information of the created resources.\n * @returns {string} `to.size.type` Data type of `framebuffer`s and `texture`s.\n * @returns {boolean} `to.size.depth` Whether `framebuffer`s attach depth.\n * @returns {boolean} `to.size.stencil` Whether `framebuffer`s attach stencil.\n * @returns {number} `to.size.channelsMin` Minimum channels in any `texture`.\n * @returns {number} `to.size.steps` Number of `to.steps` in the main flow.\n * @returns {number} `to.size.passes` Number of `to.passes` in `to.steps`.\n * @returns {number} `to.size.framebuffers` Number of `framebuffer`s created.\n * @returns {number} `to.size.textures` Number of `to.textures` in `to.passes`.\n * @returns {number} `to.size.colors` Number of `texture`s created.\n * @returns {number} `to.size.width` Width of `framebuffer`s and `texture`s.\n * @returns {number} `to.size.height` Height of `framebuffer`s and `texture`s.\n * @returns {array.<number>} `to.size.shape` Shape of `framebuffer`s and\n *   `texture`s, as `[to.size.width, to.size.height]`.\n * @returns {number} `to.size.entries` Number of entries in each `texture`.\n * @returns {object.<number,string,array.<number>>|undefined} `[to.size.merge]`\n *   Any size/type information about any created or given `merge`d `texture`.\n */\nexport function toData({ texture, framebuffer }, state = {}, to = state) {\n  const {\n      maps, scale, steps = stepsDef, merge = mergeDef,\n      // Resource format settings.\n      type = typeDef, min = minDef, mag = magDef, wrap = wrapDef,\n      depth = depthDef, stencil = stencilDef\n    } = state;\n\n  const scaled = getScaled(scale);\n  const width = Math.floor(getWidth(state) ?? scaled ?? widthDef);\n  const height = Math.floor(getHeight(state) ?? scaled ?? heightDef);\n\n  // Ensure any properties changed are included.\n  to.steps = steps;\n  to.merge = merge;\n  to.type = type;\n  to.min = min;\n  to.mag = mag;\n  to.wrap = wrap;\n  to.depth = depth;\n  to.stencil = stencil;\n  to.width = width;\n  to.height = height;\n\n  const {\n      values = (maps.values = valuesDef),\n      channelsMin = (maps.channelsMin = channelsMinDef),\n      textures: texturesMap\n    } = maps;\n\n  /**\n   * All `framebuffer` attachments need the same number of channels; enough to\n   * hold all values a pass holds, or all passes hold if merging and reusing.\n   */\n  const passChannels = (pass, min) =>\n    reduce((min, t) =>\n        Math.max(min, reduce((sum, v) => sum+values[v], texturesMap[t], 0)),\n      pass, min);\n\n  /**\n   * If merging past `texture`s and reusing `texture` attachments in each pass's\n   * `framebuffer`, pre-compute the minimum channels for a reusable pool of\n   * `texture` attachments that can hold any pass's values; since all a\n   * `framebuffer`'s attachments also need the same number of channels, this is\n   * also the same number of channels across all passes.\n   */\n  const mergeChannels = ((!merge)? null\n    : reduce((min, p) => passChannels(p, min), maps.passes, channelsMin));\n\n  /** Size of the created resources. */\n  const size = to.size = {\n    type, depth, stencil, channelsMin: mergeChannels ?? channelsMin,\n    steps: steps.length ?? steps,\n    passes: 0, framebuffers: 0, textures: 0, colors: 0,\n    width, height, shape: [width, height], entries: width*height\n  };\n\n  /** The `texture`s created for the `step`/`pass` render flow. */\n  const textures = to.textures = [];\n  /** The passes created for the `step`/`pass` render flow. */\n  const passes = to.passes = [];\n  /** The `texture`s bound to the next pass; reused if merging. */\n  let colorPool;\n\n  /**\n   * Add a `texture` attachment and meta info to `texture`s if applicable; to\n   * return its new `texture` or a reused one to bind to a pass in `passes`.\n   */\n  const addTexture = (channels, w, h, step, pass) => (index, c, _, color) => {\n    /** Properties passed for `texture` creation, then meta info. */\n    const to = { channels, width: w, height: h, type, min, mag, wrap };\n\n    // Resources.\n\n    /**\n     * Add/reuse `texture` color attachments as needed; add minimal `texture`s.\n     * If merging, passes may reuse any pass's existing `texture` attachments;\n     * otherwise, each pass has its own dedicated `texture` attachments.\n     */\n    let entry = c;\n    let t = color?.[entry];\n\n    // Only create new `texture`s if existing ones can't be reused.\n    if(!t) {\n      t = texture?.(to);\n      entry = size.textures++;\n    }\n\n    // Add meta info.\n\n    /** Check if this is bound to a pass. */\n    const s = isInteger(step);\n    const p = isInteger(pass);\n    const i = isInteger(index);\n\n    /** Denotes attached `texture`; if merging, `texture`s are reused. */\n    to.texture = t;\n    /** Denotes attached `texture` entry; if merging, `texture`s are reused. */\n    to.entry = entry;\n\n    s && (to.step = step);\n\n    if(p) {\n      /** Denotes `framebuffer` attachments; may reuse underlying `texture`s. */\n      to.color = size.colors++;\n      to.pass = pass;\n    }\n\n    i && (to.map = texturesMap[to.index = index]);\n\n    // Check whether this `texture` is part of the `step`/`pass` render flow.\n    // If so, add to `textures`, return its `texture` to bind to a pass.\n    // If not, return the entire object.\n    return ((s && p && i)? ((textures[step] ??= [])[index] = to).texture : to);\n  };\n\n  /**\n   * Add a pass to `passes`, with its `texture`s bound; to return its\n   * `framebuffer` to one of `steps`.\n   */\n  const addPass = (step, color) => (pass, index) => {\n    /**\n     * All a `framebuffer`'s attachments need the same number of channels;\n     * ignored if a `color`'s given as it'll be defined there instead.\n     */\n    const channels = color ?? mergeChannels ??\n      ((pass)? passChannels(pass, channelsMin) : channelsMin);\n\n    // Resources.\n\n    /** Properties passed for `framebuffer` creation, then meta info. */\n    const to = {\n      depth, stencil, width, height,\n      /** Map the pass's `texture` color attachments and their meta info. */\n      color: color ??\n        map(addTexture(channels, width, height, step, index), pass,\n          // Reuse any existing color attachments if merging; otherwise make\n          // dedicated color attachments for each pass.\n          ((merge)? (colorPool ??= []) : []))\n    };\n\n    /** The `framebuffer` for this pass. */\n    to.framebuffer = framebuffer?.(to);\n\n    // Add meta info.\n\n    /** Denotes attached `framebuffer` entry. */\n    to.entry = size.framebuffers++;\n\n    if(pass) {\n      to.map = pass;\n      to.pass = size.passes++;\n    }\n\n    const s = isInteger(step);\n    const i = isInteger(index);\n\n    s && (to.step = step);\n    i && (to.index = index);\n\n    // Check whether this pass is part of the `step`/`pass` render flow.\n    // If so, add to `passes`, return its `framebuffer` for its step.\n    return ((pass && s && i)? ((passes[step] ??= [])[index] = to).framebuffer\n        // If not, return the entire object.\n      : to);\n  };\n\n  /**\n   * Set up resources needed to store data per-`texture` per-pass per-step.\n   * Use any given steps/passes or create new ones.\n   */\n  to.steps = map((passes, step) => passes || map(addPass(step), maps.passes),\n    ((isInteger(steps))? range(steps) : steps), 0);\n\n  // Finish here if merge is disabled.\n  if(!merge) { return to; }\n\n  // Set up the `texture` for states to be merged into.\n\n  /** Use any size info given in `merge`, as with `state` above. */\n  const mScaled = getScaled(merge.scale);\n  /** Use any given size info, or merge along `[texture, step]` axes. */\n  const mw = getWidth(merge) ?? mScaled ?? maps.textures.length*width;\n  const mh = getHeight(merge) ?? mScaled ?? size.steps*height;\n\n  to.merge = {\n    /** New merge `texture` and info, or use any given merge `texture`. */\n    all: merge.all ?? addTexture(mergeChannels, mw, mh)(),\n    /** Empty `framebuffer`, to copy data from each `texture` of each pass. */\n    next: merge.next ?? addPass(null, false)()\n  };\n\n  size.merge = { width: mw, height: mh, shape: [mw, mh], entries: mw*mh };\n\n  return to;\n}\n\nexport default toData;\n","export const setC2 = (out, x, y) => (!out && (out = []), (out[0] = x), (out[1] = y), out);\nexport const setC3 = (out, x, y, z) => (!out && (out = []), (out[0] = x), (out[1] = y), (out[2] = z), out);\nexport const setC4 = (out, x, y, z, w) => (!out && (out = []),\n    (out[0] = x),\n    (out[1] = y),\n    (out[2] = z),\n    (out[3] = w),\n    out);\nexport const setC6 = (out, a, b, c, d, e, f) => (!out && (out = []),\n    (out[0] = a),\n    (out[1] = b),\n    (out[2] = c),\n    (out[3] = d),\n    (out[4] = e),\n    (out[5] = f),\n    out);\nexport const setC = (out, ...xs) => {\n    !out && (out = []);\n    for (let i = 0, n = xs.length; i < n; i++) {\n        out[i] = xs[i];\n    }\n    return out;\n};\n","/**\n * The `gpgpu` inputs for `GL` `uniform`s.\n *\n * @module\n * @category JS\n */\n\nimport { setC2, setC4 } from '@thi.ng/vectors/setc';\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap';\n\nimport { boundDef, preDef } from './const';\n\n/**\n * Sets up `GL` `uniform` inputs for `gpgpu` calls, such as in `toStep`.\n *\n * The `uniform`s are defined as callback hooks to be called on each render pass\n * with global context and local state `object`s, allowing the use of different\n * `GL` APIs or author-defined hooks.\n *\n * Handles inputs of states as `array`s of data-`texture`s, or merged into one\n * data-`texture`; for `array`s of `texture`s, this arranges them on each step\n * so `GLSL` can dynamically sample the flattened `array` of `texture`s by a\n * constant step index; otherwise the single merged `texture` is bound once, and\n * `GLSL` can use a dynamic step index to sample states.\n *\n * @example ```javascript\n * const state = { pre: '', steps: 2, maps: mapStep({ values: [1, 2, 3] }) };\n * const api = {};\n *\n * toUniforms(toData(api, { ...state, merge: false }, {})); // =>\n * {\n *   stepNow: (context, state) => {},\n *   stateShape: (context, state) => {},\n *   viewShape: (context, state) => {},\n *   // Separate state data-`texture`s in an `array` (e.g: `sampler2D[]`).\n *   // State data-`texture`s for the 1st step ago, not bound as outputs.\n *   'states[0]': (context, state) => {},\n *   'states[1]': (context, state) => {},\n *   // Merged `texture` not used.\n *   states: (context, state) => null\n * };\n *\n * toUniforms(toData(api, { ...state, steps: 3, merge: false }, {})); // =>\n * {\n *   stepNow: (context, state) => {},\n *   stateShape: (context, state) => {},\n *   viewShape: (context, state) => {},\n *   // Separate state data-`texture`s in an `array` (e.g: `sampler2D[]`).\n *   // State data-`texture`s for the 1st step ago, not bound as outputs.\n *   'states[0]': (context, state) => {},\n *   'states[1]': (context, state) => {}\n *   // State data-`texture`s for the 2nd step ago, not bound as outputs.\n *   'states[2]': (context, state) => {},\n *   'states[3]': (context, state) => {},\n *   // Merged `texture` not used.\n *   states: (context, state) => null\n * };\n *\n * toUniforms(toData(api, { ...state, merge: true }, {})); // =>\n * {\n *   stepNow: (context, state) => {},\n *   stateShape: (context, state) => {},\n *   viewShape: (context, state) => {},\n *   // Merged states in one data-`texture` upon every pass (e.g: `sampler2D`,\n *   // or `sampler3D`/`sampler2DArray` where supported).\n *   states: (context, state) => {},\n *   // Separate data-`texture`s not used.\n *   'states[0]': (context, state) => null,\n *   'states[1]': (context, state) => null\n * };\n * ```\n *\n * @see {@link step.toStep}\n * @see {@link data.toData}\n * @see {@link maps.mapGroups}\n * @see {@link macros.macroSamples}\n * @see {@link macros.macroTaps}\n *\n * @param {object} state The `gpgpu` state. See `toData` and `mapGroups`.\n * @param {array|number} state.steps The `array` of steps, or number of steps.\n *   See `toData`.\n * @param {{textures?:number[][]}} state.maps How values are grouped into\n *   data-`texture`s (per-pass per-step). See `mapGroups`.\n * @param {string} [state.pre=preDef] Namespace prefix; `preDef` if not given.\n * @param {{all?:{texture?:object}}} [state.merge] Any merged state `texture`;\n *   uses separate state data-`texture`s if not given. See `toData`.\n *\n * @param {{shape?:number[],merge?:{shape?:number[]}}} [state.size] Any size of\n *   `state` data-`texture`s (as `vec2(width, height)`); with:\n *   - `shape`: Any `state` shape.\n *   - `merge.shape`: Any merged `states` shape, otherwise `state` shape.\n *\n *   See `toData`.\n *\n * @param {number} [state.bound=boundDef] Number of steps bound for output, not\n *   used for input; for platforms preventing read/write of the same `texture`.\n * @param {uniforms|object} [state.uniforms] Any `object` to merge the new\n *   `uniforms` into. See `to`.\n * @param {uniforms|object} [to=state.uniforms] Any `object` to contain the\n *   `uniform` hooks; modifies any `state.uniforms`, or a new `object` if not\n *   given. See `state.uniforms` and `uniforms`.\n *\n * @returns {{\n *     stepNow:(c,state:{stepNow:number})=>number,\n *     stateShape:(c,state:{size:{number}})=>[number,number,number,number],\n *     viewShape:(\n *       context:{drawingBufferWidth:number,drawingBufferHeight:number},s?\n *     )=>[number,number],\n *     states:()=>([])\n *   }}\n *\n * @param {{\n *     stepNow?:number,\n *     bound?:number,\n *     merge?:{texture:object},\n *     textures:{texture:object}[][]\n *   }} state Local properties (the `gpgpu` `state`); with:\n *   - `stepNow`: The current step of the `gpgpu` `state`.\n *   - `bound`: Number of steps bound to output; can't be bound as inputs.\n *   - `merge`: Any `object` containing merged data-`texture`.\n *     - `texture`: Any merged data-`texture`.\n *   - `textures`: Textures per-step, as `array`s of `object`s with a `texture`\n *     property. See `toData`.\n *\n *   The `to` set up with `uniform` callback hooks for the given `state`, to\n *   be called on each render pass for the latest `uniform` values; with:\n *   - `stepNow`: Gives any current step. See `toStep`.\n *   - `stateShape`: Gives any shape of any data-`texture`s; as\n *     `vec4(vec2(width, height), vec2(width, height))`; channels are `null`ish\n *     if there's no valid shape; with:\n *     - Any `state` shape; in `xy` channels.\n *     - Any merged `states` shape, otherwise `state` shape; in `zw` channels.\n *   - `viewShape`: Gives the `GL` viewport shape; as `vec2(width, height)`;\n *     given a `context` parameter with:\n *     - `drawingBufferWidth`: Current `GL` viewport width in pixels.\n *     - `drawingBufferHeight`: Current `GL` viewport height in pixels.\n *   - `states`: Gives the past steps data-`texture`s; as either:\n *     - Any merged data-`texture` as a single `GLSL` `sampler` (e.g: `2D`/\n *       `2DArray`/`3D`; up to to the `GL` API for `texture`); otherwise `null`.\n *     - Any separate data-`texture`s as a `GLSL` `array` of `sampler`s (e.g:\n *       `sampler2D[]`), each part/all of a `gpgpu` step's data and accessible\n *       by constant index (steps ago); otherwise `null`.\n *\n *   These property names may be prefixed with any given `state.pre`.\n *   See `toData` and `toStep`.\n */\nexport function toUniforms(state = {}, to = state.uniforms ??= {}) {\n  const { steps, maps, pre: n = preDef, bound = boundDef } = state;\n  const { textures } = maps;\n  const stepsL = steps.length ?? steps;\n  const texturesL = textures.length;\n  // Local caches.\n  const stateShape = [];\n  const viewShape = [];\n\n  /** Gives any current step. */\n  to[n+'stepNow'] = (_, s) => s.stepNow;\n\n  /** Gives any shape of `state` and any merged `states` data-`texture`s. */\n  to[n+'stateShape'] = (_, { size: { shape: s, merge: m } }) =>\n    ((s)? setC4(stateShape, ...s, ...(m?.shape ?? s)) : setC4(stateShape));\n\n  /** Gives the shape of the `GL` viewport. */\n  to[n+'viewShape'] = ({ drawingBufferWidth: w, drawingBufferHeight: h }) =>\n    setC2(viewShape, w, h);\n\n  /**\n   * Gives all `states` merged in one `texture`, if using `merge`;\n   * otherwise gives `null`.\n   */\n  to[n+'states'] = (_, s) => s.merge?.all?.texture ?? null;\n\n  /**\n   * Past steps, each some steps `ago`, from the current active step at `0`, as\n   * `[0,... stepsL-1-bound]`.\n   */\n  const addTextures = (ago) =>\n    /**\n     * Hooks to pull a given `texture` by the active pass `state`; lets `GLSL`\n     * access the `array` of `texture`s by constant index (steps ago).\n     * Only returns a value if not using a `merge`d `texture`; otherwise `null`.\n     */\n    each((_, t) => to[n+`states[${(ago*texturesL)+t}]`] =\n        (_, { merge: m, stepNow: s, bound: b = bound, textures: ts }) =>\n          ((m)? null : wrap(s-b-ago, ts)?.[t]?.texture),\n      textures);\n\n  /** Flatten all input `texture`s, as `uniform`s are kept in flat `array`s. */\n  for(let ago = 0, pl = stepsL-bound; ago < pl; ++ago) { addTextures(ago); }\n\n  return to;\n}\n\n/**\n * @todo [Fix `@callback`/`@typedef`](https://github.com/TypeStrong/typedoc/issues/1896):\n *   nested `@param`; omits `@return`/`@see`/`@this`\n *\n * @callback getUniform\n * A `function` hook to update a `GL` `uniform` value for a render pass.\n *\n * **See**\n * - {@link toUniforms}\n * - {@link data.toData}\n * - {@link api.texture}\n *\n * **Returns**\n * A `GL` uniform to be bound via a `GL` API.\n *\n * @param {{\n *     drawingBufferWidth:number,\n *     drawingBufferHeight:number\n *   }} context General or global properties; with:\n *   - `drawingBufferWidth`: Current `GL` viewport width in pixels.\n *   - `drawingBufferHeight`: Current `GL` viewport height in pixels.\n *\n * @param {{\n *     stepNow?:number,\n *     bound?:number,\n *     merge?:{texture:object},\n *     textures:{texture:object}[][]\n *   }} state Local properties (the `gpgpu` state); with:\n *   - `stepNow`: The current step of the `gpgpu` state.\n *   - `bound`: Number of steps bound to output; can't be bound as inputs.\n *   - `merge`: Any `object` containing merged data-`texture`.\n *     - `texture`: Any merged data-`texture`.\n *   - `textures`: Textures per-step, as `array`s of `object`s with a `texture`\n *     property. See `toData`.\n *\n * @returns {number|number[]|texture|object}\n */\n","const [{ length: start}, { length: end }] = '[object {type}]'.split('{type}');\n\n/**\n * Gives the type of a given input.\n *\n * @see https://stackoverflow.com/a/17772086/716898\n *\n * @param {*} x Any input to test.\n *\n * @returns {string} The type of `x`.\n */\nexport const type = (x) => toString.call(x).slice(start, -end);\n\nexport default type;\n","/**\n * The `GLSL` preprocessor macros for working with the `gpgpu` state and maps.\n *\n * Each set of different macros will result in new shader compilations - for\n * optimal performance, the fewest macros possible should be created, one per\n * each given set of inputs, ideally; caches here can be used for efficiency.\n *\n * @module\n * @category JS\n *\n * @todo Redo examples, especially `macroTaps` and `macroPass`.\n * @todo Ensure the `output_N` in `macroOutput` can work with `WebGL2`; look at\n *   using `layout(location=attach_N) out data_N`, not `gl_FragData[attach_N]`.\n *   - [SO: Multiple output textures from the same program](https://stackoverflow.com/questions/51793336/multiple-output-textures-from-the-same-program)\n *   - [SO: GL FragData must be constant zero](https://stackoverflow.com/questions/46740817/gl-fragdata-must-be-constant-zero)\n *   - [SO: How are layout qualifiers better than getAttribLocation in WebGL2](https://stackoverflow.com/questions/50258822/how-are-layout-qualifiers-better-than-getattriblocation-in-webgl2)\n */\n\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\nimport { type } from '@epok.tech/is-type/type';\n\nimport { preDef, boundDef } from './const';\n\n/** Escaped line-feed for easier reading. */\nexport const lineFeed = ' \\\\\\n';\nconst lf = lineFeed;\n\n/** The channels denoted for texture input/output. */\nexport const rgba = 'rgba';\n/** Simple shared cache for temporary or reusable objects. */\nexport const cacheDef = {};\n/** Gives cache keys from simple plain `object` inputs. */\nconst id = JSON.stringify;\n\n/** Names for each part of the macro handling process available to hooks. */\nexport const hooks = {\n  /** The full set of macros. */\n  macroPass: '',\n  /** Each part of the set of macros. */\n  macroValues: 'values', macroOutput: 'output',\n  macroSamples: 'samples', macroTaps: 'taps'\n};\n\n/**\n * Whether handling macros here; or the result of a given hook to handle it.\n *\n * Allows macros of the given key to be handled by external named hooks, to\n * replace any part of the functionality here in overall or granular ways.\n *\n * The macro names checked in this module are found in `hooks`.\n *\n * @example ```javascript\n * // Macros to be handled here, the default.\n * [hasMacros(), hasMacros({}), hasMacros({ macros: true })]]\n *   .every((m) => m == null);\n *\n * // Macros to be handled here, with prefix `'pre_'` instead of `'preDef'`.\n * hasMacros({ pre: 'pre_' }) == null;\n *\n * // Macros not created.\n * [hasMacros({ macros: false }), hasMacros({ macros: 0 })]\n *   .every((m) => m === '');\n *\n * // Macros for `'a'` handled by external `string` hook, not here.\n * hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'a') === '//A\\n';\n * // Macros for `'b'` handled by external `function` hook, not here.\n * hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'b') === '//B\\n';\n * // Macros specified `on` a `'frag'` not created.\n * hasMacros({ macros: { frag: 0, values_vert: 0 } }, '', 'frag') === '';\n * // Macros specified `on` a `'vert'` handled here.\n * hasMacros({ macros: { frag: 0, values_vert: 0 } }, '', 'vert') == null;\n * // Macros of `'values'`/`hooks.values` handled here.\n * hasMacros({ macros: { frag: 0, values_vert: 0 } }, 'values', '') == null;\n * // Macros of `'values'`/`hooks.values` specified `on` a `'vert'` not created.\n * hasMacros({ macros: { frag: 0, values_vert: 0 } }, 'values', 'vert') === '';\n * ```\n *\n * @see hooks\n *\n * @param {object} [state] Any `object` whose properties may handle macros.\n * @param {string} [key] Any name to check granularly within `macros`. See `hooks`.\n * @param {string} [on=''] Any further macro name specifier; if given, `key`\n *   itself and with this specifier are checked (i.e: `key` then `key+'_'+on`).\n *\n * @param {false|string|((...)=>string|null)|{}} [macros=state.macros] How\n *   macros should be handled, according to their type, in order of precedence:\n *   - `null`ish: macros to be handled here, `null`ish returned.\n *   - `true`: macros to be handled here, `null`ish returned.\n *   - `false`y: no macros to be handled here, empty `''` `string` returned.\n *   - `string`: no macros to be handled here, this hook value's used instead.\n *   - `function`: external `hasMacros`-like `function` hook, called with\n *     `macros(state, key, on, macros)`, the returned value used as shown here.\n *   - `object`: recurses with any value at the given `key`, with\n *     `hasMacros(state, key, on, macros[key])`.\n *   - Otherwise, macros to be handled here, `null`ish returned.\n *\n * @returns {null|string} Either the result of the macros handled elsewhere,\n *   or `null`ish if macros should be handled here.\n */\nexport function hasMacros(state, key, on = '', macros = state?.macros) {\n  if((macros ?? true) === true) { return null; }\n  else if(!macros) { return ''; }\n\n  const t = type(macros);\n\n  return ((t === 'String')? macros\n    : ((t === 'Function')?\n      hasMacros(state, key, on, macros(state, key, on, macros))\n    : (((macros instanceof Object) && (key in macros))?\n      hasMacros(state, key, on, macros[key])\n    : ((on)? hasMacros(state, ((key)? key+'_'+on : on), '', macros)\n    : null))));\n}\n\n/**\n * Generates an `array`-like declaration, as a `GLSL` syntax `string` compatible\n * with versions 1-3.\n *\n * Works around the lack of `const` `array`s in `GLSL` < 3. Used as the base for\n * the other `GLSL` version list types, ensuring a common standard while\n * offering further language features where available.\n *\n * @example ```javascript\n * getGLSLListBase('float', 'list', [0, 1, 2], 'const'); // =>\n * 'const int list_l = 3;'+lf+\n * 'const int list_0 = float(0);'+lf+\n * 'const int list_1 = float(1);'+lf+\n * 'const int list_2 = float(2);';\n * ```\n *\n * @param {string} type The `GLSL` list data-type.\n * @param {string} name The name of the `GLSL` list variable.\n * @param {array.<number,number[]>} a The list of `GLSL` values.\n * @param {string} [qualify=''] A `GLSL` qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The `GLSL1` array-like declaration string.\n */\nexport const getGLSLListBase = (type, name, a, qualify = '', init = type) =>\n  `const int ${name}_l = ${a.length};`+\n  reduce((s, v, i) =>\n      s+lf+(qualify && qualify+' ')+type+\n        ` ${name}_${i} = ${init}(${v.join?.(', ') ?? v});`,\n    a, '');\n\n/**\n * Generates an array-like declaration, as a `GLSL1` syntax string.\n *\n * Workaround for lack of `const` arrays in `GLSL` < 3. Adds a lookup macro\n * function; slow here, but standard.\n *\n * @see {@link getGLSLListBase}\n *\n * @example ```javascript\n * getGLSL1ListLike('float', 'list', [0, 1, 2], 'const'); // =>\n * 'const int list_l = 3;'+lf+\n * 'const int list_0 = float(0);'+lf+\n * 'const int list_1 = float(1);'+lf+\n * 'const int list_2 = float(2);\\n'+\n * '// Index macro `list_i` (e.g: `list_i(0)`) may be slow, `+\n *   'use name (e.g: `list_0`) if possible.\\n'+\n * '#define list_i(i) ((i == 2)? list_2 : ((i == 1)? list_1 : list_0))\\n';\n * ```\n *\n * @param {string} type The `GLSL` list data-type.\n * @param {string} name The name of the `GLSL` list variable.\n * @param {array.<number,array.<number>>} a The list of `GLSL` values.\n * @param {string} [qualify=''] A `GLSL` qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The `GLSL1` array-like declaration string.\n */\nexport const getGLSL1ListLike = (type, name, a, qualify = '', init = type) =>\n  getGLSLListBase(type, name, a, qualify, init)+'\\n'+\n  // @todo Would ideally use the concatenation macro, but can't in GLSL 1.\n  // `#define ${name}_i(i) ${name}_##i`;\n  `// Index macro \\`${name}_i\\` (e.g: \\`${name}_i(0)\\`) may be slow, `+\n    `use name (e.g: \\`${name}_0\\`) if possible.\\n`+\n  `#define ${name}_i(i) ${reduce((s, v, i) =>\n      ((i)? `((i == ${i})? ${name}_${i} : ${s})` : `${name}_${i}`),\n    a, '')}\\n`;\n\n/**\n * Generates an array declaration, as a `GLSL1` syntax string.\n *\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @see {@link getGLSLListBase}\n *\n * @example ```javascript\n * getGLSL1ListArray('vec3', 'list', [[1, 0, 0], [0, 2, 0], [0, 0, 3]]); // =>\n * 'const int list_l = 3;'+lf+\n * 'vec3 list_0 = vec3(1, 0, 0);'+lf+\n * 'vec3 list_1 = vec3(0, 2, 0);'+lf+\n * 'vec3 list_2 = vec3(0, 0, 3);'+lf+\n * 'vec3 list[list_l];'+lf+\n * 'list[0] = list_0;'+lf+\n * 'list[1] = list_1;'+lf+\n * 'list[2] = list_2;\\n'+\n * '#define list_i(i) list[i]\\n';\n * ```\n *\n * @param {string} type The `GLSL` list data-type.\n * @param {string} name The name of the `GLSL` list variable.\n * @param {array.<number,array.<number>>} a The list of `GLSL` values.\n * @param {string} [qualify=''] A `GLSL` qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The `GLSL1` array declaration string.\n */\nexport const getGLSL1ListArray = (type, name, a, qualify = '', init = type) =>\n  getGLSLListBase(type, name, a, qualify, init)+lf+\n  (qualify && qualify+' ')+type+` ${name}[${name}_l];`+\n  reduce((s, _, i) => s+lf+name+`[${i}] = ${name}_${i};`, a, '')+'\\n'+\n  `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Generates an array declaration, as a `GLSL3` syntax string.\n *\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @see {@link getGLSLListBase}\n *\n * @example ```javascript\n * getGLSL3List('int', 'list', [0, 1, 2], 'const'); // =>\n * 'const int list_l = 3;'+lf+\n * 'const int list_0 = int(0);'+lf+\n * 'const int list_1 = int(1);'+lf+\n * 'const int list_2 = int(2);'+lf+\n * 'const int list[list_l] = int[list_l](list_0, list_1, list_2);\\n'+\n * '#define list_i(i) list[i]\\n';\n * ```\n *\n * @param {string} type The `GLSL` list data-type.\n * @param {string} name The name of the `GLSL` list variable.\n * @param {array.<number,array.<number>>} a The list of `GLSL` values.\n * @param {string} [qualify=''] A `GLSL` qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The `GLSL3` array declaration string.\n */\nexport const getGLSL3List = (type, name, a, qualify = '', init = type) =>\n  getGLSLListBase(type, name, a, qualify, init)+lf+\n  (qualify && qualify+' ')+type+` ${name}[${name}_l] = ${init}[${name}_l](${\n    reduce((s, _, i) => (s && s+', ')+name+'_'+i, a, '')});\\n`+\n  `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Creates a `GLSL` definition of an array, and initialises it with the given\n * values, type, and variable name.\n *\n * The initialisation is valid `GLSL1` or greater syntax; but is written with\n * escaped new-lines so it may be used in a single-line (e.g: for preprocessor\n * macros).\n *\n * For a `qualify` of `const` on any `GLSL` < 3, falls back to using non-array\n * variables with the index appended to `name`, since `const` arrays aren't\n * supported before `GLSL3`.\n *\n * @see {@link getGLSL3List}\n * @see {@link getGLSL1ListLike}\n * @see {@link getGLSL1ListArray}\n *\n * @example ```javascript\n * getGLSLList('int', 'test', [0, 1]); // =>\n * 'const int test_l = 2;'+lf+\n * 'int test_0 = int(0);'+lf+\n * 'int test_1 = int(1);'+lf+\n * 'int test[test_l];'+lf+\n * 'test[0] = test_0;'+lf+\n * 'test[1] = test_1;\\n'+\n * '#define test_i(i) test[i]\\n';\n *\n * getGLSLList('ivec2', 'vecs', [[1, 0], [0, 1]], 'const', 3); // =>\n * 'const int vecs_l = 2;'+lf+\n * 'ivec2 vecs_0 = ivec2(1, 0);'+lf+\n * 'ivec2 vecs_1 = ivec2(0, 1);'+lf+\n * 'const ivec2 vecs[vecs_l] = ivec2[vecs_l](vecs_0, vecs_1);\\n'+\n * '#define vecs_i(i) vecs[i]\\n';\n *\n * getGLSLList('int', 'listLike', [0, 1], 'const', 1); // =>\n * 'const int listLike_l = 2;'+lf+\n * 'const int listLike_0 = int(0);'+lf+\n * 'const int listLike_1 = int(1);\\n'+\n * '// Index macro `listLike_i` (e.g: `listLike_i(0)`) may be slow, `+\n *   'use name (e.g: `listLike_0`) if possible.\\n'+\n * '#define listLike_i(i) ((i == 1)? listLike_1 : listLike_0)\\n';\n * ```\n *\n * @param {string} type The `GLSL` list data-type.\n * @param {string} name The name of the `GLSL` list variable.\n * @param {array.<number,array.<number>>} a The list of `GLSL` values.\n * @param {string} [qualify=''] A `GLSL` qualifier, if needed (e.g: `const`).\n * @param {number} [glsl=1] The `GLSL` version to target, if specified.\n * @param {string} [init] A data-type initialiser.\n *\n * @returns {string} The `GLSL` (1 or 3) array or array-like declaration string.\n */\nexport const getGLSLList = (type, name, a, qualify = '', glsl = 1, init) =>\n  ((glsl >= 3)? getGLSL3List\n  : ((qualify.trim() === 'const')? getGLSL1ListLike : getGLSL1ListArray))\n    (type, name, a, qualify, init);\n\n/**\n * Defines the values within textures per-step, as `GLSL` preprocessor macros.\n *\n * These macros define mappings from values to their textures and channels.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see {@link hasMacros}\n * @see {@link maps.mapGroups}\n * @see {@link data.toData}\n * @see {@link cacheDef}\n *\n * @example ```javascript\n * const state = { pre: '', steps: 2 };\n * const maps = { values: [2, 4, 1], channelsMax: 4 };\n *\n * // No optimisations - values not packed, single texture output per pass.\n * state.maps = mapGroups({ ...maps, buffersMax: 1, packed: 0 });\n * macroValues(state); // =>\n * '#define texture_0 0\\n'+\n * '#define channels_0 rg\\n'+\n * '\\n'+\n * '#define texture_1 1\\n'+\n * '#define channels_1 rgba\\n'+\n * '\\n'+\n * '#define texture_2 2\\n'+\n * '#define channels_2 r\\n'+\n * '\\n'+\n * '#define textures 3\\n'+\n * '#define passes 3\\n'+\n * '#define stepsPast 1\\n'+\n * '#define steps 2\\n'+\n * '\\n';\n *\n * // Automatically packed values - values across fewer textures/passes.\n * state.maps = mapGroups({ ...maps, buffersMax: 1 });\n * state.size = { entries: 2**5 };\n * macroValues(state); // =>\n * '#define texture_1 0\\n'+\n * '#define channels_1 rgba\\n'+\n * '\\n'+\n * '#define texture_0 1\\n'+\n * '#define channels_0 rg\\n'+\n * '\\n'+\n * '#define texture_2 1\\n'+\n * '#define channels_2 b\\n'+\n * '\\n'+\n * '#define entries 32\\n'+\n * '#define textures 2\\n'+\n * '#define passes 2\\n'+\n * '#define stepsPast 1\\n'+\n * '#define steps 2\\n'+\n * '\\n';\n *\n * // Can bind more texture outputs per pass - values across fewer passes.\n * state.maps = mapGroups({ ...maps, buffersMax: 4 });\n * macroValues(state); // =>\n * '#define texture_1 0\\n'+\n * '#define channels_1 rgba\\n'+\n * '\\n'+\n * '#define texture_0 1\\n'+\n * '#define channels_0 rg\\n'+\n * '\\n'+\n * '#define texture_2 1\\n'+\n * '#define channels_2 b\\n'+\n * '\\n'+\n * '#define entries 32\\n'+\n * '#define textures 2\\n'+\n * '#define passes 1\\n'+\n * '#define stepsPast 1\\n'+\n * '#define steps 2\\n'+\n * '\\n';\n * ```\n *\n * @param {object} state Properties used to generate the macros. See `toData`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *   the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled\n *   or prefixed. See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {object} state.maps How values are grouped per-`texture` per-pass\n *   per-step.\n * @param {array.<number>} state.maps.values How values of each data item are\n *   grouped into `texture`s. See `mapGroups`.\n * @param {array.<array.<number>>} state.maps.textures The groupings of values\n *   into `texture`s. See `mapGroups`.\n * @param {array} state.maps.passes Passes drawn per-step. See `mapGroups`.\n * @param {array|number} state.steps States drawn across frames. See `toData`.\n * @param {number} [state.bound=boundDef] How many steps are bound as outputs,\n *   unavailable as inputs.\n * @param {object} [state.size] Any size information about the GL resources.\n * @param {number} [state.size.entries] The number of data entries per `texture`\n *   (the `texture`'s area), if given. See `toData`.\n * @param {object|false} [state.cache=cacheDef] Any object to cache any inputs'\n *   results in, `false`y to skip caching; uses `cacheDef` if not given.\n *\n * @returns {string} The `GLSL` preprocessor macros defining the maps from\n *   values to `texture`s and channels.\n */\nexport function macroValues(state, on) {\n  const key = hooks.macroValues;\n  let to = hasMacros(state, key, on);\n\n  if(to != null) { return to; }\n\n  const {\n      maps, steps, bound = boundDef, size, pre: n = preDef,\n      cache = cacheDef\n    } = state;\n\n  const { values, textures, passes: { length: passesL } } = maps;\n  const stepsL = steps.length ?? steps;\n  const entries = size?.entries;\n\n  const c = cache &&\n    `macro@${key}@${n\n      }|${bound}|${id(values)}|${id(textures)}|${stepsL}|${passesL}|${entries}`;\n\n  to = cache?.[c] ??\n    reduce((s, texture, t, _, i = 0) => reduce((s, v) =>\n          s+`#define ${n}texture_${v} ${t}\\n`+\n          `#define ${n}channels_${v} ${rgba.slice(i, i += values[v])}\\n\\n`,\n        texture, s),\n      textures, '')+\n    ((entries)? `#define ${n}entries ${entries}\\n` : '')+\n    `#define ${n}textures ${textures.length}\\n`+\n    `#define ${n}passes ${passesL}\\n`+\n    `#define ${n}stepsPast ${stepsL-bound}\\n`+\n    `#define ${n}steps ${stepsL}\\n`+\n    `#define ${n}bound ${bound}\\n\\n`;\n\n  return ((cache)? cache[c] = to : to);\n}\n\n/**\n * Defines the outputs being drawn to per-pass, as `GLSL` preprocessor macros.\n *\n * These macros define mappings from values to their outputs, if bound.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see {@link hasMacros}\n * @see {@link maps.mapGroups}\n * @see {@link data.toData}\n * @see {@link cacheDef}\n *\n * @example ```javascript\n * const maps = { values: [2, 4, 1], channelsMax: 4 };\n *\n * // No optimisations - values not packed, single texture output per pass.\n * const state = {\n *   pre: '', passNow: 0,\n *   maps: mapGroups({ ...maps, buffersMax: 1, packed: 0 })\n * };\n *\n * macroOutput(state); // =>\n * '#define passNow 0\\n'+\n * '\\n'+\n * '#define bound_0 0\\n'+\n * '#define attach_0 0\\n'+\n * '#define output_0 gl_FragData[attach_0].rg\\n'+\n * '\\n';\n *\n * // Automatically packed values - values across fewer textures/passes.\n * state.maps = mapGroups({ ...maps, buffersMax: 1 });\n * macroOutput(state); // =>\n * '#define passNow 0\\n'+\n * '\\n'+\n * '#define bound_1 0\\n'+\n * '#define attach_1 0\\n'+\n * '#define output_1 gl_FragData[attach_1].rgba\\n'+\n * '\\n';\n *\n * // Next pass in this step.\n * ++state.passNow;\n * macroOutput(state); // =>\n * '#define passNow 1\\n'+\n * '\\n'+\n * '#define bound_0 1\\n'+\n * '#define attach_0 0\\n'+\n * '#define output_0 gl_FragData[attach_0].rg\\n'+\n * '\\n'+\n * '#define bound_2 1\\n'+\n * '#define attach_2 0\\n'+\n * '#define output_2 gl_FragData[attach_2].b\\n'+\n * '\\n';\n *\n * // Can bind more texture outputs per pass - values across fewer passes.\n * state.maps = mapGroups({ ...maps, buffersMax: 4 });\n * state.passNow = 0;\n * macroOutput(state); // =>\n * '#define passNow 0\\n'+\n * '\\n'+\n * '#define bound_1 0\\n'+\n * '#define attach_1 0\\n'+\n * '#define output_1 gl_FragData[attach_1].rgba\\n'+\n * '\\n'+\n * '#define bound_0 1\\n'+\n * '#define attach_0 1\\n'+\n * '#define output_0 gl_FragData[attach_0].rg\\n'+\n * '\\n'+\n * '#define bound_2 1\\n'+\n * '#define attach_2 1\\n'+\n * '#define output_2 gl_FragData[attach_2].b\\n'+\n * '\\n';\n * ```\n *\n * @param {object} state Properties for generating the macros. See `toData`:\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *   the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *   See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `pre` if not given.\n * @param {number} state.passNow The index of the currently active pass.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *   per-step. See `mapGroups`.\n * @param {array.<number>} state.maps.values How values of each data item may be\n *   grouped into textures across passes. See `mapGroups`.\n * @param {array.<array.<number>>} state.maps.textures The groupings of values\n *   into textures. See `mapGroups`.\n * @param {array.<array.<number>>} state.maps.passes The groupings of textures\n *   into passes. See `mapGroups`.\n * @param {object|false} [state.cache=cacheDef] Any object to cache any inputs'\n *   results in, `false`y to skip caching; uses `cacheDef` if not given.\n *\n * @returns {string} `GLSL` preprocessor macros for the pass's bound outputs.\n */\nexport function macroOutput(state, on) {\n  const key = hooks.macroOutput;\n  let to = hasMacros(state, key, on);\n\n  if(to != null) { return to; }\n\n  const { passNow: p, maps, pre: n = preDef, cache = cacheDef } = state;\n  const { values, textures, passes } = maps;\n  const pass = passes[p];\n\n  const c = cache &&\n    `macro@${key}@${n}|${p}|${id(values)}|${id(textures)}|${id(passes)}`;\n\n  to = cache?.[c] ??\n    `#define ${n}passNow ${p}\\n`+\n    reduce((s, texture, bound, _, i = 0) => reduce((s, v) =>\n          s+'\\n'+\n          `#define ${n}bound_${v} ${texture}\\n`+\n          `#define ${n}attach_${v} ${bound}\\n`+\n          `#define ${n}output_${v} gl_FragData[${n}attach_${v}].${\n            rgba.slice(i, i += values[v])}\\n`,\n        textures[texture], s),\n      pass, '')+'\\n';\n\n  return ((cache)? cache[c] = to : to);\n}\n\n/**\n * Defines the texture samples/reads per-pass, as `GLSL` preprocessor macros.\n *\n * The macros define the mapping between the values and those they derive from,\n * as step/texture locations in a `samples` list, and indexes to read values\n * from sampled data in a `reads` list (once sampled into a `data` list, as in\n * `macroTaps` or similar).\n *\n * They're set up as function-like macros that may be called from the shader to\n * initialise the mappings arrays with a given name.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see {@link macroTaps}\n * @see {@link hasMacros}\n * @see {@link getGLSLList}\n * @see {@link maps.mapStep}\n * @see {@link data.toData}\n * @see {@link cacheDef}\n *\n * @example ```javascript\n * const values = [2, 4, 1];\n * const derives = [2, , [[1, 0], true]];\n * const maps = { values, derives, channelsMax: 4 };\n *\n * // No optimisations - values not packed, single texture output per pass.\n * const state =\n *   { pre: '', maps: mapStep({ ...maps, buffersMax: 1, packed: 0 }) };\n *\n * // Uses the first pass by default.\n * macroSamples(state); // =>\n * '#define useSamples'+lf+\n *   'const int samples_l = 1;'+lf+\n *   'const ivec2 samples_0 = ivec2(0, 2);\\n'+\n * '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *   'use name (e.g: `samples_0`) if possible.\\n'+\n * '#define samples_i(i) samples_0\\n'+\n * '\\n'+\n * '#define useReads_0'+lf+\n *   'const int reads_0_l = 1;'+lf+\n *   'const int reads_0_0 = int(0);\\n'+\n * '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+\n *   'use name (e.g: `reads_0_0`) if possible.\\n'+\n * '#define reads_0_i(i) reads_0_0\\n'+\n * '\\n';\n *\n * // Next pass in this step - no derives, no samples nor reads.\n * state.passNow = 1;\n * macroSamples(state); // =>\n * '';\n *\n * // Next pass in this step.\n * ++state.passNow;\n * macroSamples(state); // =>\n * '#define useSamples'+lf+\n *   'const int samples_l = 4;'+lf+\n *   'const ivec2 samples_0 = ivec2(1, 0);'+lf+\n *   'const ivec2 samples_1 = ivec2(0, 0);'+lf+\n *   'const ivec2 samples_2 = ivec2(0, 1);'+lf+\n *   'const ivec2 samples_3 = ivec2(0, 2);\\n'+\n * '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *   'use name (e.g: `samples_0`) if possible.\\n'+\n * '#define samples_i(i) ((i == 3)? samples_3 : ((i == 2)? samples_2 '+\n *   ': ((i == 1)? samples_1 : samples_0)))\\n'+\n * '\\n'+\n * '#define useReads_2'+lf+\n *   'const int reads_2_l = 4;'+lf+\n *   'const int reads_2_0 = int(0);'+lf+\n *   'const int reads_2_1 = int(1);'+lf+\n *   'const int reads_2_2 = int(2);'+lf+\n *   'const int reads_2_3 = int(3);\\n'+\n * '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+\n *   'use name (e.g: `reads_2_0`) if possible.\\n'+\n * '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *   ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n * '\\n';\n *\n * // Automatically packed values - values across fewer textures/passes.\n * // Can bind more texture outputs per pass - values across fewer passes.\n * // Also fewer samples where values share derives or textures.\n * state.maps = mapGroups({ ...maps, buffersMax: 4 });\n * state.passNow = 0;\n * macroSamples(state); // =>\n * '#define useSamples'+lf+\n *   'const int samples_l = 3;'+lf+\n *   'const ivec2 samples_0 = ivec2(0, 1);'+lf+\n *   'const ivec2 samples_1 = ivec2(1, 1);'+lf+\n *   'const ivec2 samples_2 = ivec2(0, 0);\\n'+\n * '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *   'use name (e.g: `samples_0`) if possible.\\n'+\n * '#define samples_i(i) '+\n *   '((i == 2)? samples_2 : ((i == 1)? samples_1 : samples_0))\\n'+\n * '\\n'+\n * '#define useReads_0'+lf+\n *   'const int reads_0_l = 1;'+lf+\n *   'const int reads_0_0 = int(0);\\n'+\n * '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+\n *   'use name (e.g: `reads_0_0`) if possible.\\n'+\n * '#define reads_0_i(i) reads_0_0\\n'+\n * '\\n'+\n * '#define useReads_2'+lf+\n *   'const int reads_2_l = 4;'+lf+\n *   'const int reads_2_0 = int(1);'+lf+\n *   'const int reads_2_1 = int(0);'+lf+\n *   'const int reads_2_2 = int(2);'+lf+\n *   'const int reads_2_3 = int(0);\\n'+\n * '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+\n *   'use name (e.g: `reads_2_0`) if possible.\\n'+\n * '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *   ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n * '\\n';\n * ```\n *\n * @param {object} state Properties used to generate the macros. See `toData`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both the\n *   hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *   See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {number} [state.passNow=0] The index of the currently active pass;\n *   uses the first pass if not given.\n * @param {object} state.maps  How `values` are grouped per-texture per-pass\n *   per-step. See `mapGroups`.\n * @param {array.<array.<array.<number>>>} [state.maps.samples] The minimal set\n *   of texture samples to use. See `mapSamples`.\n * @param {array.<array.<array.<number>>>} [state.maps.reads] The mappings from\n *   values to the corresponding `state.samples`. See `mapSamples`.\n * @param {number} [state.glsl=1] The `GLSL` language version.\n *   See `getGLSLList`.\n * @param {object|false} [state.cache=cacheDef] Any object to cache any inputs'\n *   results in, `false`y to skip caching; uses `cacheDef` if not given.\n *\n * @returns {string} `GLSL` preprocessor macros defining the mappings for\n *   samples and reads, for each value.\n */\nexport function macroSamples(state, on) {\n  const key = hooks.macroSamples;\n  let to = hasMacros(state, key, on);\n\n  if(to != null) { return to; }\n\n  const {\n      passNow: p = 0, maps, glsl, pre: n = preDef, cache = cacheDef\n    } = state;\n\n  const { samples, reads } = maps;\n  const passSamples = samples?.[p];\n  const passReads = reads?.[p];\n\n  const c = cache &&\n    `macro@${key}@${n}|${p}|${id(passSamples)}|${id(passReads)}|${glsl}`;\n\n  to = cache?.[c] ??\n    ((!passSamples)? ''\n    : `#define ${n}useSamples${lf+\n        getGLSLList('ivec2', n+'samples', passSamples, 'const', glsl)}\\n`)+\n    ((!passReads)? ''\n    : reduce((s, reads, v) =>\n          `${s}#define ${n}useReads_${v}${lf+\n            getGLSLList('int', n+'reads_'+v, reads, 'const', glsl)}\\n`,\n        passReads, ''));\n\n  return ((cache)? cache[c] = to : to);\n}\n\n/**\n * Defines the samples of textures per-pass, as `GLSL` preprocessor macros.\n *\n * The macros define the minimal sampling of textures for the data the active\n * pass's values derive from; creates a `data` list containing the samples; the\n * `samples` list variable names are required as created by `macroSamples`.\n *\n * Handles sampling states in a flat array of textures, or merged in one texture\n * (in both `sampler2D`, and `sampler3D`/`sampler2DArray` where supported).\n * Merging allows shaders to access past steps by non-constant lookups; e.g:\n * attributes cause `sampler array index must be a literal expression` on\n * `GLSL3` spec and other platforms (e.g: `D3D`); note these need texture repeat\n * wrapping.\n *\n * They're set up as function-like macros that may be called from the shader to\n * initialise the mappings arrays with a given name.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see [`sampler array index must be a literal expression`](https://stackoverflow.com/a/60110986/716898)\n * @see [`sampler2DArray`](https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_2d_array.html)\n * @see [`sampler3D`](https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_3d.html)\n *\n * @see {@link macroSamples}\n * @see {@link hasMacros}\n * @see {@link getGLSLList}\n * @see {@link maps.mapStep}\n * @see {@link data.toData}\n * @see {@link inputs.toUniforms}\n * @see {@link cacheDef}\n *\n * @example ```javascript\n * const values = [2, 4, 1];\n * const derives = [2, , [[1, 0], true]];\n * const maps = { values, derives, channelsMax: 4 };\n *\n * // No optimisations - values not packed, single texture output per pass.\n * const state =\n *   { pre: '', maps: mapStep({ ...maps, buffersMax: 1, packed: 0 }) };\n *\n * // Uses the first pass by default.\n * macroTaps(state); // =>\n * '@todo';\n *\n * // Next pass in this step - no derives, no samples nor reads.\n * state.passNow = 1;\n * macroTaps(state); // =>\n * '';\n *\n * // Next pass in this step.\n * ++state.passNow;\n * macroTaps(state); // =>\n * '@todo';\n *\n * // Automatically packed values - values across fewer textures/passes.\n * // Can bind more texture outputs per pass - values across fewer passes.\n * // Also fewer samples where values share derives or textures.\n * state.maps = mapGroups({ ...maps, buffersMax: 4 });\n * state.passNow = 0;\n * macroTaps(state); // =>\n * '@todo';\n * ```\n *\n * @param {object} state Properties used to generate the macros. See `toData`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *   the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *   See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {number} [state.passNow=0] The index of the currently active pass;\n *   uses the first pass if not given.\n * @param {object} state.maps  How `values` are grouped per-texture per-pass\n *   per-step. See `mapGroups`.\n * @param {array.<array.<array.<number>>>} [state.maps.samples] The minimal set\n *   of texture samples to use. See `mapSamples`.\n * @param {object} [state.merge] Any merged state texture; uses separate state\n *   textures if not given. See `toData`.\n * @param {number} [state.glsl=1] The `GLSL` language version.\n *   See `getGLSLList`.\n * @param {object|false} [state.cache=cacheDef] Any object to cache any inputs'\n *   results in, `false`y to skip caching; uses `cacheDef` if not given.\n *\n * @returns {string} The `GLSL` preprocessor macros defining the minimal\n *   sampling of textures, to suit how states are stored (array of textures, or\n *   all merged into one texture) and supported `GLSL` language features.\n */\nexport function macroTaps(state, on) {\n  const key = hooks.macroTaps;\n  let to = hasMacros(state, key, on);\n\n  if(to != null) { return to; }\n\n  const {\n      passNow: p = 0, maps, merge, glsl, pre: n = preDef,\n      cache = cacheDef\n    } = state;\n\n  const passSamples = maps.samples?.[p];\n  const index = !merge;\n\n  const c = cache &&\n    `macro@${key}@${n}|${p}|${id(passSamples)}|${index}|${glsl}`;\n\n  if((to = cache?.[c]) != null) { return to; }\n\n  const glsl3 = (glsl >= 3);\n  /** Which texture sampling function is available. */\n  const texture = 'texture'+((glsl3)? '' : '2D');\n  /** Short and common names for functions and parameters. */\n  const f = n+'tapState';\n  const tap = '#define '+f;\n  /** Common parameters, passed as `(..., stepBy, textureBy)` */\n  const by = `stepBy, textureBy`;\n  /** Aliases default names for brevity, main functions offer more control. */\n  const aka = `#define ${f}(uv)`+lf+f;\n  const akaBy = `#define ${f}By(uv, ${by})`+lf+f;\n  /** The current `sample`, as `[step, texture]`. */\n  const st = n+'samples_';\n  /** Prefix for private temporary variables. */\n  const t = '_'+n;\n  /** A temporary `array` to pass to `getGLSLList`. */\n  const tapsSamples = cache[key+':tapsSamples'] ??= [];\n  const tapsL = tapsSamples.length = passSamples?.length ?? 0;\n\n  /** The main `texture`-sampling logic. */\n  to = ((index)? '' : `#define ${n}mergedStates\\n\\n`)+\n    ((!tapsL)? ''\n    : ((index)?\n      /** Separate un-merged `texture`s accessed by constant index. */\n      '// States in a `sampler2D[]`; looks up 1D index and 2D `uv`; '+lf+\n        'past steps go later in the list.\\n'+\n      `// Pass constant array index values; \\`textures\\`.\\n`+\n      `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n      tap+`s(uv, states, textures)`+lf+\n        // Compute before the loop for lighter work.\n        `const int ${t}tlI = int(textures);`+lf+\n        `vec2 ${t}uvI = vec2(uv);`+lf+\n        // Sample into the `data` output list.\n        getGLSLList('vec4', n+'data',\n          map((_, i) => texture+\n              // Offset step, `texture`.\n              `(states[(int(${st+i}.s)*${t}tlI)+int(${st+i}.t)], ${t}uvI)`,\n            passSamples, tapsSamples),\n          '', glsl)+'\\n'+\n      '// States may also be sampled by shifted step/texture.\\n'+\n      `// Pass constant array index values; \\`textures, ${by}\\`.\\n`+\n      `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n      tap+`sBy(uv, states, textures, ${by})`+lf+\n        // Compute before the loop for lighter work.\n        `const int ${t}tlIB = int(textures);`+lf+\n        `ivec2 ${t}byIB = ivec2(${by});`+lf+\n        `vec2 ${t}uvIB = vec2(uv);`+lf+\n        // Sample into the `data` output list.\n        getGLSLList('vec4', n+'data',\n          map((_, i) =>\n              texture+'(states['+\n                  // Offset step.\n                  `((int(${st+i}.s)+${t}byIB.s)*${t}tlIB)+`+\n                  // Offset `texture`.\n                  `int(${st+i}.t)+${t}byIB.t`+\n                `], ${t}uvIB)`,\n            passSamples, tapsSamples),\n          '', glsl)+'\\n'+\n      '// Preferred aliases: index suits states array constant access.\\n'+\n      aka+`s(uv, ${n}states, ${n}textures)\\n`+\n      akaBy+`sBy(uv, ${n}states, ${n}textures, ${by})\\n`\n    : /** Merged 2D `texture`. */\n      '// States merged to a `sampler2D`, scales 2D `uv` over '+\n        '`[textures, steps]`.\\n'+\n      '// Step from now into the past going upwards in the texture.\\n'+\n      `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n      tap+`2(uv, states, stepNow, steps, textures)`+lf+\n        // Compute before the loop for lighter work.\n        `vec2 ${t}l2 = vec2(textures, steps);`+lf+\n        `vec2 ${t}uv2 = vec2(uv)/${t}l2;`+lf+\n        // Steps advance in reverse, top-to-bottom.\n        `vec2 ${t}s2 = vec2(1, -1)/${t}l2;`+lf+\n        // Offset `texture`, step.\n        // Each step stored in `texture` top downward at `-stepNow`.\n        // Most recent step to look up is at `-stepNow+1`.\n        `vec2 ${t}i2 = vec2(0, 1)-vec2(0, stepNow);`+lf+\n        // Sample into the `data` output list.\n        getGLSLList('vec4', n+'data',\n          // Would repeat wrap; but `WebGL1` needs power-of-2.\n          map((_, i) =>\n              texture+`(states, `+\n                // Offset `texture`, step.\n                `fract(${t}uv2+fract((vec2(${st+i}).ts+${t}i2)*${t}s2)))`,\n            passSamples, tapsSamples),\n          '', glsl)+'\\n'+\n      '// States may also be sampled by shifted step/texture.\\n'+\n      `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n      tap+`2By(uv, states, stepNow, steps, textures, ${by})`+lf+\n        // Compute before the loop for lighter work.\n        `vec2 ${t}l2B = vec2(textures, steps);`+lf+\n        `vec2 ${t}uv2B = vec2(uv)/${t}l2B;`+lf+\n        // Steps advance in reverse, top-to-bottom.\n        `vec2 ${t}s2B = vec2(1, -1)/${t}l2B;`+lf+\n        // Offset `texture`, step.\n        // Each step stored in `texture` top downward at `-stepNow`.\n        // Most recent step to look up is at `-stepNow+1`.\n        `vec2 ${t}i2B = vec2(${by}).ts+vec2(0, 1)-vec2(0, stepNow);`+lf+\n        // Sample into the `data` output list.\n        getGLSLList('vec4', n+'data',\n          // Would repeat wrap; but `WebGL1` needs power-of-2.\n          map((_, i) =>\n              texture+`(states, `+\n                // Offset `texture`, step.\n                `fract(${t}uv2B+fract((vec2(${st+i}).ts+${t}i2B)*${t}s2B)))`,\n            passSamples, tapsSamples),\n          '', glsl)+'\\n'+\n      ((!glsl3)?\n        '// Preferred aliases: 2D suits merged texture in GLSL < 1.\\n'+\n        aka+`2(uv, ${n}states, ${n}stepNow, ${n}steps, ${n}textures)\\n`+\n        akaBy+\n          `2By(uv, ${n}states, ${n}stepNow, ${n}steps, ${n}textures, ${by})\\n`\n      : /**\n         * Merged 3D `texture` types, supported from `GLSL3`.\n         * @todo Check and finish this.\n         */\n        '// States merged to `sampler3D` or `sampler2DArray`; 2D `uv` '+\n          'to 3D; scales `x` over `textures`, `z` over `steps` as:\\n'+\n        '// - `sampler3D`: the number of steps; depth, `[0, 1]`.\\n'+\n        '// - `sampler2DArray`: `1` or less; layer, `[0, steps-1]`.\\n'+\n        `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n        tap+`3(uv, states, stepNow, steps, textures)`+lf+\n          /** @see `...2()` above. */\n          // Compute before the loop for lighter work.\n          `vec2 ${t}l3 = vec2(textures, steps);`+lf+\n          `vec2 ${t}uv3 = vec2(uv)/${t}l3;`+lf+\n          // Offset `texture`.\n          `float ${t}sx3 = 1.0/${t}l3.x;`+lf+\n          // Offset step.\n          `float ${t}s3 = -float(stepNow);`+lf+\n          `float ${t}sz3 = -1.0/${t}l3;`+lf+\n          // Sample into the `data` output list.\n          getGLSLList('vec4', n+'data',\n            // Would repeat wrap; but `sampler2DArray` layer can't.\n            map((_, i) =>\n                texture+'(states, fract(vec3('+\n                  // Offset `texture`.\n                  `${t}uv3.x+(float(${st+i}.t)*${t}sx3), ${t}uv3.y, `+\n                  // Offset step: `sampler3D` depth, `[0, 1]`;\n                  // `sampler2DArray` layer, `[0, steps-1]`.\n                  `(float(${st+i}.s)+${t}s3)*${t}sz3)))`,\n              passSamples, tapsSamples),\n            '', glsl)+'\\n'+\n        '// States may also be sampled by shifted step/`texture`.\\n'+\n        `// Use \\`${n}data\\` list; ignore temporary \\`${t}\\` names.\\n`+\n        tap+`3By(uv, states, stepNow, steps, textures, ${by})`+lf+\n          /** @see `...2By()` above. */\n          // Compute before the loop for lighter work.\n          `vec2 ${t}l3B = vec2(textures, steps);`+lf+\n          `vec2 ${t}uv3B = (vec2(uv)+vec2(textureBy, 0))/${t}l3B;`+lf+\n          // Offset `texture`.\n          `float ${t}sx3B = 1.0/${t}l3B.x;`+lf+\n          // Offset step.\n          `float ${t}s3B = float(stepBy)-float(stepNow);`+lf+\n          `float ${t}sz3B = -1.0/${t}l3B;`+lf+\n          // Sample into the `data` output list.\n          getGLSLList('vec4', n+'data',\n            // Would repeat wrap; but `sampler2DArray` layer can't.\n            map((_, i) =>\n                texture+'(states, fract(vec3('+\n                  // Offset `texture`.\n                  `${t}uv3B.x+(float(${st+i}.t)*${t}sx3B), ${t}uv3B.y, `+\n                  // Offset step: `sampler3D` depth, `[0, 1]`;\n                  // `sampler2DArray` layer, `[0, steps-1]`.\n                  `(float(${st+i}.s)+${t}s3B)*${t}sz3B)))`,\n              passSamples, tapsSamples),\n            '', glsl)+'\\n'+\n        '// Preferred aliases: 3D suits merged texture in `GLSL` 3+.\\n'+\n        aka+`3(uv, ${n}states, ${n}stepNow, ${n}steps, ${n}textures)\\n`+\n        akaBy+\n          `3By(uv, ${n}states, ${n}stepNow, ${n}steps, ${n}textures, ${by})\\n`\n      ))+'\\n');\n\n  return ((cache)? cache[c] = to : to);\n}\n\n/**\n * Defines all `GLSL` preprocessor macro values, `texture` samples, and outputs\n * for the active pass.\n *\n * The macros define the mapping between the active values, their `texture`s and\n * channels, bound outputs, and other macros useful for a draw pass.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see {@link hasMacros}\n * @see {@link macroValues}\n * @see {@link macroOutput}\n * @see {@link macroTaps}\n * @see {@link macroSamples}\n * @see {@link maps.mapStep}\n * @see {@link data.toData}\n *\n * @example ```javascript\n * const values = [2, 4, 1];\n * const derives = [2, , [[1, 0], true]];\n *\n * // Automatically packed values - values across fewer `texture`s/passes.\n * // Only a single `texture` output per pass - values across more passes.\n * const state = {\n *   passNow: 0, steps: 2, size: { entries: 2**5 },\n *   maps: mapStep({ values, derives, channelsMax: 4, buffersMax: 1 })\n * };\n *\n * macroPass(state); // =>\n * '#define gpgpu_texture_1 0\\n'+\n * '#define gpgpu_channels_1 rgba\\n'+\n * '\\n'+\n * '#define gpgpu_texture_0 1\\n'+\n * '#define gpgpu_channels_0 rg\\n'+\n * '\\n'+\n * '#define gpgpu_texture_2 1\\n'+\n * '#define gpgpu_channels_2 b\\n'+\n * '\\n'+\n * '#define gpgpu_entries 32\\n'+\n * '#define gpgpu_textures 2\\n'+\n * '#define gpgpu_passes 2\\n'+\n * '#define gpgpu_stepsPast 1\\n'+\n * '#define gpgpu_steps 2\\n'+\n * '\\n'+\n * '#define gpgpu_passNow 0\\n'+\n * '\\n'+\n * '#define gpgpu_bound_1 0\\n'+\n * '#define gpgpu_attach_1 0\\n'+\n * '#define gpgpu_output_1 gl_FragData[gpgpu_attach_1].rgba\\n'+\n * '\\n';\n *\n * // Next pass and extra step.\n * ++state.steps;\n * ++state.passNow;\n * state.pre = '';\n * macroPass(state); // =>\n * '#define texture_1 0\\n'+\n * '#define channels_1 rgba\\n'+\n * '\\n'+\n * '#define texture_0 1\\n'+\n * '#define channels_0 rg\\n'+\n * '\\n'+\n * '#define texture_2 1\\n'+\n * '#define channels_2 b\\n'+\n * '\\n'+\n * '#define entries 32\\n'+\n * '#define textures 2\\n'+\n * '#define passes 2\\n'+\n * '#define stepsPast 2\\n'+\n * '#define steps 3\\n'+\n * '\\n'+\n * '#define passNow 1\\n'+\n * '\\n'+\n * '#define bound_0 1\\n'+\n * '#define attach_0 0\\n'+\n * '#define output_0 gl_FragData[attach_0].rg\\n'+\n * '\\n'+\n * '#define bound_2 1\\n'+\n * '#define attach_2 0\\n'+\n * '#define output_2 gl_FragData[attach_2].b\\n'+\n * '\\n'+\n * '#define useSamples'+lf+\n *   'const int samples_l = 3;'+lf+\n *   'const ivec2 samples_0 = ivec2(0, 1);'+lf+\n *   'const ivec2 samples_1 = ivec2(1, 1);'+lf+\n *   'const ivec2 samples_2 = ivec2(0, 0);\\n'+\n * '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+\n *   'use name (e.g: `samples_0`) if possible.\\n'+\n * '#define samples_i(i)'+lf+\n *   '((i == 2)? samples_2 : ((i == 1)? samples_1 : samples_0))\\n'+\n * '\\n'+\n * '#define useReads_0'+lf+\n *   'const int reads_0_l = 1;'+lf+\n *   'const int reads_0_0 = int(0);\\n'+\n * '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+\n *   'use name (e.g: `reads_0_0`) if possible.\\n'+\n * '#define reads_0_i(i) reads_0_0\\n'+\n * '\\n'+\n * '#define useReads_2'+lf+\n *   'const int reads_2_l = 4;'+lf+\n *   'const int reads_2_0 = int(1);'+lf+\n *   'const int reads_2_1 = int(0);'+lf+\n *   'const int reads_2_2 = int(2);'+lf+\n *   'const int reads_2_3 = int(0);\\n'+\n * '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+\n *   'use name (e.g: `reads_2_0`) if possible.\\n'+\n * '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *   ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n * '\\n'+\n * '// States in a `sampler2D[]`; looks up 1D index and 2D `uv`.\\n'+\n * '@todo';\n * ```\n *\n * @param {object} state Properties for generating the macros. See `toData`\n *   and `mapGroups`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *   the hook key and this specifier are checked (e.g: `key` and `key_on`).\n *\n * @returns {string} The `GLSL` preprocessor macros defining the mappings for\n *   values, `texture`s, channels, bound outputs of the active pass, etc. See\n *   `macroValues`, `macroOutput`, and `macroSamples`.\n */\nexport const macroPass = (state, on) =>\n  hasMacros(state, hooks.macroPass, on) ??\n    macroValues(state, on)+macroOutput(state, on)+macroSamples(state, on)+\n    macroTaps(state, on);\n\nexport default macroPass;\n","/**\n * The `gpgpu` update step.\n *\n * Connects inputs to the `GL` state and renders an update step.\n *\n * @module\n * @category JS\n *\n * @todo [Fix `@callback`/`@typedef`](https://github.com/TypeStrong/typedoc/issues/1896):\n *   nested `@param`; omits `@return`/`@see`/`@this`\n */\n\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap';\n\nimport { macroPass } from './macros';\n\nimport {\n    vertDef, preDef, positionsDef, countDef, stepMaxDef,\n    clearPassDef, copyFrameDef, copyImageDef\n  } from './const';\n\n/**\n * Convenience to get the currently active `framebuffer`.\n *\n * @see {@link toStep}\n * @see {@link data.toData}\n *\n * @param {object} state The `gpgpu` state.\n * @param {object[][]} state.passes Passes per step. See `toData`.\n * @param {number} [state.stepNow] Any active state step index. See `toStep`.\n * @param {number} [state.passNow] Any active draw pass index. See `toStep`.\n *\n * @returns {object} Any active step's active pass object, of the given `state`.\n */\nexport const getPass = ({ passes: ps, stepNow: s, passNow: p }) =>\n  wrap(s, ps)?.[p];\n\n/**\n * Merged `texture` update, called upon each pass.\n *\n * Copies the active pass's output into the merged `texture`, from each of its\n * `framebuffer` attachments one by one (to support multiple draw buffers).\n * Matches the lookup logic defined in `macroTaps`.\n *\n * @todo Update docs.\n *\n * @see [SO reading from multiple `framebuffer`s](https://stackoverflow.com/a/34160982/716898)\n * @see {@link getPass}\n * @see {@link state.framebuffer}\n * @see {@link state.texture}\n * @see {@link data.toData}\n * @see {@link maps.mapGroups}\n * @see {@link macros.macroTaps}\n *\n * @param {object} state A `gpgpu` state of the active pass.\n * @param {{color:texture[],map:number[]}[][]} state.passes Passes per\n *   step; any active one's found via `getPass`, with:\n *   - `color`: `array` of data-`texture`s.\n *   - `map`: `array` of `number`s, showing how the `texture`s are grouped\n *     per-pass. See `getPass`, `toData`, and `mapGroups`.\n * @param {merge} state.merge The merged `texture` to update.\n * @param {number} [state.stepNow] The currently active state step, if any.\n *\n * @returns {texture} The merged `texture`, updated by the active pass's output;\n *   matches the lookup logic defined in `macroTaps`.\n */\nexport function updateMerge(state) {\n  const {\n      merge, stepNow: s, size,\n      copyFrame: cf = copyFrameDef, copyImage: ci = copyImageDef\n    } = state;\n\n  const { color, map: pass } = getPass(state);\n  const { all: { texture }, next: { framebuffer } } = merge;\n  const to = texture?.subimage;\n  let f = framebuffer;\n\n  // Silent exit if there's not enough info ready now to perform the update.\n  if(!(to && f && color && pass && (s || (s === 0)))) { return texture; }\n\n  /** Handle `object`s or `regl`-like extended `function`s. */\n  (f.call !== Function.call) && (f = f.call);\n\n  const { steps: sl, width: w, height: h } = size;\n  /** Start at the top of the `texture`, move down row-per-step and wrap. */\n  const y = (s%sl)*h;\n\n  /**\n   * Reusable `framebuffer` binds and copies each of the pass `texture`s along\n   * the merged `texture`.\n   */\n  each((c, i) =>\n      (cf.color = c) &&\n        f.call(f, cf).use.call(f, () => to.call(texture, ci, pass[i]*w, y)),\n    color);\n\n  return texture;\n}\n\n/**\n * Creates a `gpgpu` update step function, for use with a `gpgpu` state object.\n *\n * @todo Make this fully and consistently extensible; improve `pipeline`.\n * @todo Example.\n *\n * @see {@link buffer}\n * @see {@link command}\n * @see {@link subimage}\n * @see {@link onStep}\n * @see {@link onPass}\n * @see {@link getPass}\n * @see {@link data.toData}\n * @see {@link maps.mapGroups}\n * @see {@link macros.macroPass}\n * @see {@link inputs.toUniforms}\n *\n * @param {object} api An API for `GL` resources.\n * @param {buffer} [api.buffer] Function to set up a `GL` buffer.\n * @param {clear} [api.clear] Function to clear `GL` view or `framebuffer`.\n * @param {command} [api.command=api] Function to create a `GL` render pass,\n *   given options, to be called later with options; `api` if not given.\n * @param {object} state The `gpgpu` state to use. See `toData` and `mapGroups`.\n * @param {object} state.maps How values are grouped per-`texture` per-pass\n *   per-step. See `mapGroups`.\n * @param {number[][]} state.maps.passes How textures are grouped into passes.\n *   See `mapGroups`.\n * @param {object} [state.merge] Any merged state `texture`; uses separate state\n *   textures if not given.\n * @param {object} [state.merge.texture] Any `GL` `texture` of `state.merge`.\n * @param {subimage} [state.merge.texture.subimage] A function to update part of\n *   the merge `GL` `texture` object data. See `subimage`.\n * @param {function} [state.merge.update] Hook to update, if any; if not given,\n *   `state.merge.texture` is updated here with active states upon each pass.\n *\n *   The default merged `texture` is laid out as `[texture, step]` on the\n *   `[x, y]` axes, respectively; if other layouts are needed, this merge update\n *   hook can be given to use as-is, and the setup and lookup logic in their\n *   respective hooks.\n *\n *   See `toData` and `macroTaps`.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n * @param {string} [state.vert=vertDef] The step vertex shader `GLSL`; a\n *   simple flat screen shader if not given.\n * @param {string} state.frag The step fragment shader `GLSL`.\n * @param {object} [state.uniforms=toUniforms(state)] The step uniforms;\n *   modifies any given. See `toUniforms`.\n * @param {number[]|buffer} [state.positions=positionsDef()] The step position\n *   `attribute`s; 3 points of a large flat triangle if not given.\n * @param {number} [state.count=state.positions.length*0.5] The `number` of\n *   elements/`attribute`s to draw.\n * @param {object} [state.pipeline] Any `GL` command properties to mix in\n *   overriding those ones added here; all passed to `api.command`.\n * @param {string} [state.vert=vertDef] Vertex `GLSL` code to prepend `macro`s.\n * @param {string[]} [state.verts] Preprocesses and caches vertex `GLSL`\n *   code per-pass if given, otherwise processes just-in-time before each pass.\n * @param {string} [state.frag] Fragment `GLSL` to prepend `macro`s.\n * @param {string[]} [state.frags] Preprocesses and caches fragment `GLSL`\n *   code per-pass, otherwise processes just-in-time before each pass.\n * @param {onStep} [onStep] Callback upon each step.\n * @param {onPass} [onPass] Callback upon each pass.\n * @param {object} [to=state] The `object` to set up. Modifies the given `state`\n *   `object` by default.\n *\n * @returns {object} `to` The given `to` `object`; set up with a `gpgpu` step\n *   `function` and related properties, to use with the `gpgpu` state.\n * @returns {string} `to.vert` The given/new `state.vert` vertex shader `GLSL`.\n * @returns {string} `to.frag` The given `state.frag` fragment shader `GLSL`.\n * @returns {string[]} `[to.verts]` Any cached pre-processed vertex shaders\n *   `GLSL`, if `state.verts` was given.\n * @returns {string[]} `[to.frags]` Any cached pre-processed fragment shaders\n *   `GLSL`, if `state.verts` was given.\n * @returns {object} `to.uniforms` The given `state.uniforms`.\n * @returns {number} `to.count` The given or new `state.count`.\n * @returns {buffer} `to.positions` The given or new `state.positions`; via\n *   `api.buffer`.\n * @returns {command} `to.pass` A `GL` command `function` to draw a given pass;\n *   via `api`/`api.command`.\n * @returns {function} `to.step` The main `function` to perform all the draw\n *   pass `GL` commands for a given state step.\n */\nexport function toStep(api, state = {}, to = state) {\n  /** Handle `object`s or `regl`-like extended `function`s, for `command`. */\n  const { buffer, clear, command = api } = api;\n\n  const {\n      merge, pipeline, verts, frag, frags, uniforms, attributes, maps,\n      // Update any default vertex `shader` to use the given `pre`.\n      pre: n = preDef, vert = vertDef.replaceAll(preDef, n || ''),\n      // Any vertex `count`, and `positions` to be passed to `buffer`.\n      count = countDef, positions = positionsDef\n    } = state;\n\n  // Ensure any properties changed are included.\n  to.pre = n;\n  to.vert = vert;\n  to.count = count;\n  to.positions = buffer(positions);\n\n  // May pre-process and keep the `shader`s for all passes in advance.\n  if(verts || frags) {\n    // Keep the current pass.\n    const { passNow } = state;\n\n    verts && (to.verts = verts);\n    frags && (to.frags = frags);\n\n    each((pass, p) => {\n        // Create `macro`s for this pass in advance.\n        state.passNow = p;\n        // Specify a `'vert'` type `shader` for any per-`shader` `macro` hooks.\n        verts && (verts[p] ??= macroPass(state, 'vert')+vert);\n        // Specify a `'frag'` type `shader` for any per-`shader` `macro` hooks.\n        frags && (frags[p] ??= macroPass(state, 'frag')+frag);\n      },\n      maps.passes);\n\n    // Set the pass back to what it was.\n    state.passNow = passNow;\n  }\n\n  /** A `command` to render `pass` updates via a `GL` `pipeline` description. */\n  to.pass = command(to.pipeline = {\n    // Uses the full-screen vertex `shader` state by default.\n    vert(_, s) {\n      const { passNow: p, step: { vert: v = vert, verts: vs = verts } } = state;\n\n      // Specify a `'vert'` type `shader` for any per-`shader` `macro` hooks.\n      return vs?.[p] ?? macroPass(s, 'vert')+v;\n    },\n    frag(_, s) {\n      const { passNow: p, step: { frag: f = frag, frags: fs = frags } } = state;\n\n      // Specify a `'frag'` type `shader` for any per-`shader` `macro` hooks.\n      return fs?.[p] ?? macroPass(s, 'frag')+f;\n    },\n    /** Need an active `pass` with `framebuffer`, or may draw to the screen. */\n    framebuffer: (_, s) => getPass(s)?.framebuffer,\n    count, uniforms,\n    attributes: {\n      [n+'position']: (_, s) => s.positions,\n      ...attributes\n    },\n    depth: { enable: false },\n    /** Any `pipeline` properties shallow-override others of the same name. */\n    ...pipeline\n  });\n\n  /** Any merged `texture`'s update, set up if not already given. */\n  merge && ((to.merge = merge).update ??= updateMerge);\n\n  /** Executes the next step and all its passes. */\n  to.step = (state = to) => {\n    const {\n        steps, merge, pass, onPass, onStep,\n        stepMax = stepMaxDef, clearPass = clearPassDef\n      } = state;\n\n    let { stepNow = 0 } = state;\n\n    /** Guard for number overflow; set to 0 to ignore or handle in `GLSL`. */\n    stepNow = state.stepNow = (stepNow+1)%(stepMax || Infinity);\n\n    const mergeUpdate = merge?.update;\n    const stepProps = onStep?.(state, wrap(stepNow, steps)) ?? state;\n\n    each((p, i) => {\n        stepProps.passNow = i;\n\n        const passProps = onPass?.(stepProps, p) ?? stepProps;\n\n        /** @todo Remove `clear` call if unnecessary? */\n        ((clearPass.framebuffer = getPass(passProps)?.framebuffer) &&\n          clear(clearPass));\n\n        pass(passProps);\n        // Update any merged `texture` upon each pass.\n        mergeUpdate?.(passProps);\n      },\n      stepProps.maps.passes);\n\n    delete clearPass.framebuffer;\n\n    return state;\n  };\n\n  return to;\n}\n\n/**\n * @todo [Fix `@callback`/`@typedef`](https://github.com/TypeStrong/typedoc/issues/1896):\n *   nested `@param`; omits `@return`/`@see`/`@this`\n *\n * @callback onStep\n * Callback upon each step.\n *\n * **See**\n * - {@link toStep}\n * - {@link data.toData}\n * - {@link state.framebuffer}\n *\n * **Returns**\n * - A `stepProps` object to use for each of the step's next passes; or\n *   `null`ish to use the given `props`.\n *\n * @param {object} [props] The `props` passed to `run`.\n * @param {framebuffer[]} step The `framebuffer`s for `props.stepNow` from\n *   `props.steps`, where the next state step will be drawn. See `toData`.\n *\n * @returns {object}\n */\n\n/**\n * @todo [Fix `@callback`/`@typedef`](https://github.com/TypeStrong/typedoc/issues/1896):\n *   nested `@param`; omits `@return`/`@see`/`@this`\n *\n * @callback onPass\n * Callback upon each pass.\n *\n * **See**\n * - {@link toStep}\n * - {@link maps.mapGroups}\n *\n * **Returns**\n * - A `passProps` object to use for the render `command` call; or `null`ish to\n *   use the given `stepProps`.\n *\n * @param {object} [stepProps] The `props` passed to `run` via any `onStep`.\n * @param {number[]} pass The maps for the next pass. See `mapGroups`.\n *\n * @returns {object}\n */\n\n/** A wrapper around `updateMerge`, handy for testing. */\nfunction updateMergeTest(state, update = updateMerge, after = 2) {\n  const { color, map: pass } = getPass(state);\n  const { merge: { all, next }, stepNow: s, passNow: p, size, maps } = state;\n  const { channels } = all;\n  const { steps: sl, shape: [w, h], merge: { shape: [wl, hl] } } = size;\n  const tl = maps.textures.length;\n  const y = (s%sl)*h;\n  const lc = y*tl*w;\n  const to = update(state);\n  let f = next?.framebuffer;\n\n  /** Handle `object`s or `regl`-like extended `function`s. */\n  (f.call !== Function.call) && (f = f?.call);\n\n  console.warn(s, p, pass, ':');\n  console.warn('- l', 0, 'r', tl*w, 'w', w, 'wl', wl);\n  console.warn('- t', y, 'b', y+h, 'h', h, 'hl', hl);\n  console.warn('- c', channels, 'lc', lc*channels, 'rc', (lc+(w*h))*channels,\n    'sc', w*h*channels, 'slc', wl*hl*channels);\n\n  f.call(f, { color: to }).use.call(f, () =>\n    console.warn(Array.prototype.reduce.call(regl.read(), (o, v, i) =>\n        o+((i)? ',\\t' : '')+\n        ((!i)? ''\n        : ((i%(tl*w*h*channels) === 0)?\n            `\\n${'='.repeat(100)}step${'='.repeat(100)}\\n`\n        : ((i%(tl*w*channels) === 0)? '\\n'\n        : ((i%(w*channels) === 0)? ' || \\t'\n        : ((i%channels === 0)? ' / \\t' : '')))))+\n        (i*1e-3).toFixed(3).slice(2)+': '+((v)? v.toFixed(2) : '___'),\n      '\\n')));\n\n  if(s && after && s%(sl*after) === 0) { debugger; }\n\n  return to;\n}\n\nexport default toStep;\n","/**\n * **Main `index.js` - see [`readme`](..)**\n *\n * [![`gl-gpgpu` particles demo](media://demo-particles-regl-frames.png)](..)\n *\n * [GPGPU](https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units)\n * state-stepping - declaratively maps optimal draw passes, shaders, `GL`\n * resources, inputs, outputs - lets you focus on your logic, BYO-renderer.\n *\n * Decouples logic from rendering approach/engine.\n * Each module and hook may be used as given, or piecemeal, or overridden.\n *\n * @module (root)\n * @category Root\n * @category JS\n */\n\nimport './api';\nimport { glslRx } from './const';\nimport { mapStep } from './maps';\nimport { toData } from './data';\nimport { toUniforms } from './uniforms';\nimport { toStep } from './step';\n\nconst { isFinite } = Number;\n\n/**\n * Parse a `GLSL` version into a `number`.\n *\n * @see {@link const.glslRx}\n *\n * @param {string|number} version A `GLSL` version `string`, expected in a `GL`\n *   parameter `SHADING_LANGUAGE_VERSION` format to parse into a `number`, from\n *   any first found version number or the full given `string` otherwise; or a\n *   `number`, to use as-is.\n *\n * @returns {number} A `GLSL` version `number`, parsed from the given `version`.\n */\nexport const getGLSL = (version) =>\n  ((isFinite(version))? version\n  : parseFloat(version?.match?.(glslRx)?.[0] ?? version, 10));\n\n/**\n * Sets up all the maps, data, inputs, and commands for a `gpgpu` process.\n *\n * Hooks up each main part in order into the complete process. Each part may\n * also be used individually for more custom behaviour; see their documentation.\n *\n * @see {@link maps.mapStep}\n * @see {@link maps.mapGroups}\n * @see {@link maps.mapSamples}\n * @see {@link data.toData}\n * @see {@link uniforms.toUniforms}\n * @see {@link step.toStep}\n * @see {@link macros.macroPass}\n *\n * @param {object} api An API for `GL` resources. See `toData` and `toStep`.\n * @param {object} [api.limits=api] A map of `GL` resource limits.\n * @param {number} [api.limits.maxDrawbuffers] The maximum number of `GL`\n *   `texture`s a `framebuffer` can bind in a single draw call.\n * @param {object} [state=\\{\\}] State properties to set up; a new `object` by\n *   default. See `toData`, `toUniforms`, and `toStep`.\n * @param {object} [state.maps] How values are grouped per-`texture` per-pass\n *   per-step. Sets up new maps if not given or missing its mapped properties.\n *   See `mapStep`.\n * @param {number} [state.maps.buffersMax=api.limits.maxDrawbuffers] Maximum\n *   number of `texture`s per draw pass. Uses more passes above this limit.\n * @param {object} [to=state] The `object` to set up. Modifies the given `state`\n *   object by default.\n *\n * @returns {object} The given `to` data `object`; set up with data resources\n *   for a `gpgpu` process. See `mapStep`, `toData`, `toUniforms`, `toStep`.\n */\nexport function gpgpu(api, state = {}, to = state) {\n  const { maxDrawbuffers, glsl: apiGLSL } = api.limits ?? api;\n  const { maps = {}, glsl = apiGLSL } = state;\n  const { buffersMax } = maps;\n\n  /** The parsed `GLSL` version. */\n  to.glsl = getGLSL(glsl);\n\n  // Temporary updates to set up `maps` then `state`.\n  /** Any `maps.buffersMax` supersedes any `maxDrawbuffers` from the `api`. */\n  maps.buffersMax ??= maxDrawbuffers;\n  state.maps = mapStep(maps, to.maps ??= {});\n\n  toData(api, state, to);\n  toUniforms(state, to.uniforms ??= {});\n  toStep(api, state, to);\n\n  // Undo any temporary changes made above to the given `maps` and `state`.\n  /** @todo Improve, this is awkward. */\n  (state.maps = maps).buffersMax = buffersMax;\n\n  return to;\n}\n\nexport default gpgpu;\n","/**\n * How many vertexes for a given form to cover each entry's steps of state:\n * - If 2 states or form are given, gives a setup of pairs for a line segment\n *   between each entry's steps of state using `gl.LINES`.\n * - If fewer than 2 states or form are given, gives a setup for a point at each\n *   entry's steps of state using `gl.POINTS`.\n *\n * Possibly useful for other forms too.\n *\n * Corresponds to the indexing logic in the `indexForms` `GLSL` function.\n *\n * @module\n * @category JS\n *\n * @see {@link index-forms/index-states.glsl!}\n * @see {@link index-forms/index-entries.glsl!}\n * @see [`gl.LINES`](https://webglfundamentals.org/webgl/lessons/webgl-points-lines-triangles.html)\n *\n * @param {number} [states=1] How many steps of state each entry has.\n * @param {number} [form=2] How many steps of state each form covers.\n * @param {number} [count=1] How many entries, if any; result to be multiplied\n *   externally if not given.\n *\n * @returns {number} The number of vertexes needed for the given `form` to cover\n *   all steps of `states`; over all `count` if given, to be multiplied\n *   externally if not given.\n *\n * @remarks [[include:src/index-forms/readme.md]]\n */\nexport const indexForms = (states = 1, form = 2, count = 1) =>\n  Math.max(1, (states-form)+1)*form*count;\n\nexport default indexForms;\n","/** Demo implementation of 3D particle Verlet/Euler integration simulation. */\n\nimport getRegl from 'regl';\nimport clamp from 'clamp';\nimport { perspective } from '@thi.ng/matrices/perspective';\nimport { lookAt } from '@thi.ng/matrices/lookat';\nimport timer from '@epok.tech/fn-time';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\nimport each from '@epok.tech/fn-lists/each';\nimport range from '@epok.tech/fn-lists/range';\nimport wrap from '@epok.tech/fn-lists/wrap';\n\nimport gpgpu from '../../src';\n\nimport { extensionsFloat, extensionsHalfFloat, optionalExtensions }\n  from '../../src/const';\n\nimport { macroPass } from '../../src/macros';\nimport { mapStep } from '../../src/maps';\nimport { toUniforms } from '../../src/uniforms';\nimport { getDrawIndexes } from '../../src/size';\nimport indexForms from '../../src/index-forms';\n\nimport stepFrag from './step.frag.glsl';\nimport drawVert from './draw.vert.glsl';\nimport drawFrag from './draw.frag.glsl';\n\nself.gpgpu = gpgpu;\nself.macroPass = macroPass;\nself.mapStep = mapStep;\nself.toUniforms = toUniforms;\nself.getDrawIndexes = getDrawIndexes;\nself.indexForms = indexForms;\n\nconst canvas = document.querySelector('canvas');\n\n// Scroll to the top.\nconst scroll = () => setTimeout(() => canvas.scrollIntoView(true), 0);\n\nscroll();\n\nfunction toggleError(e) {\n  canvas.classList[(e)? 'add' : 'remove']('hide');\n  document.querySelector('.error').classList[(e)? 'remove' : 'add']('hide');\n  document.querySelector('aside').classList[(e)? 'add' : 'remove']('show');\n  scroll();\n}\n\ntoggleError();\n\n// Handle query parameters.\n\nconst getQuery = (search = location.search) => new URLSearchParams(search);\n\nfunction setQuery(entries, q = getQuery()) {\n  entries &&\n    each(([k, v = null]) => ((v === null)? q.delete(k) : q.set(k, v)), entries);\n\n  return q;\n}\n\nconst query = getQuery();\n\nconst fragDepth = query.get('depth') === 'frag';\n\n// Set up GL.\n\nconst extend = {\n  required: extensionsHalfFloat,\n  optional: ((fragDepth)?\n      [...extensionsFloat, ...optionalExtensions, 'ext_frag_depth']\n    : [...extensionsFloat, ...optionalExtensions])\n};\n\nconst pixelRatio = Math.max(devicePixelRatio, 1.5) || 1.5;\n\nconst regl = self.regl = getRegl({\n  canvas, pixelRatio,\n  extensions: extend.required, optionalExtensions: extend.optional,\n  onDone: toggleError\n});\n\nconsole.group('Extensions');\n\nconsole.log('required',\n  (extend.required &&\n    reduce((o, e) => o+(o && '; ')+e+': '+regl.hasExtension(e),\n      extend.required, '')));\n\nconsole.log('optional',\n  (extend.optional &&\n    reduce((o, e) => o+(o && '; ')+e+': '+regl.hasExtension(e),\n      extend.optional, '')));\n\nconsole.groupEnd();\n\n/**\n * How many state values (channels) are tracked independently of others.\n * The order here is the order used in the shaders and generated macros, but for\n * optimal lookups may be `packed` into channels/textures/passes differently.\n */\nconst valuesMap = (new Map())\n  // Position, uses 3 channels.\n  .set('position', 3)\n  // Motion, uses 3 channels.\n  .set('motion', 3)\n  // Life, uses 1 channel.\n  .set('life', 1);\n\nconst values = [];\nconst valuesIndex = {};\n\nvaluesMap.forEach((v, k) => valuesIndex[k] = values.push(v)-1);\nconsole.log(values, '`values`');\n\n/** Limits of this device and these `values`. */\nconst { maxTextureUnits, maxTextureSize, lineWidthDims, pointSizeDims } =\n  regl.limits;\n\n/** Whether to merge states into one texture; separate textures if not given. */\nconst useMerge = query.get('merge');\n\n/**\n * Merge by default for maximum platform compatibility.\n * @todo Should work in one of these cases:\n * ```\n *   const merge = ((useMerge)? (useMerge !== 'false') : (stepsPast > 1));\n *   const merge = ((useMerge)? (useMerge !== 'false') : (form !== 1));\n * ```\n */\nconst merge = !useMerge || (useMerge !== 'false');\n\n/** How many steps are used for output at a given time. */\nconst bound = 1;\n\n/**\n * Better stay farther under maximum texture size, for errors/crashes.\n * @todo Drawing issues with `scale` and `steps` both over 10.\n */\nconst limits = { scale: [0, Math.log2(maxTextureSize)] };\n/** A scale that seems to work well from experimentation with `GL` limits. */\nconst niceScale = clamp(8, ...limits.scale);\n\n/** The data entries scale, from user input or default best-guess. */\nconst scale = clamp((parseFloat(query.get('scale'), 10) || niceScale),\n  ...limits.scale);\n\n/** The steps of state to track. */\nlimits.steps = [\n  1+bound,\n  ((merge)?\n      // Maximum steps must fit the maximum total texture size if merging.\n      Math.floor(maxTextureSize/(2**scale))\n      // Maximum steps must fit the maximum total texture units if separate.\n    : Math.floor((maxTextureUnits-bound)/reduce((s, v) => s+v, values)*4))\n];\n\nconsole.log('limits', limits, regl.limits);\n\n/**\n * 2 active states, as many others as can be bound; at least 2 past states\n * needed for Verlet integration, 1 for Euler integration.\n */\nconst steps = Math.floor(clamp(parseFloat(query.get('steps'), 10) || 2+bound,\n  ...limits.steps));\n\n/** How many past steps (not bound to outputs) are in the GPGPU state. */\nconst stepsPast = steps-bound;\n/** Whether to allow Verlet integration; within available resource limits. */\nconst canVerlet = stepsPast > 1;\n\n/**\n * Form vertexes to draw; if not given, uses trails of 'lines' if there are\n * enough steps, or 'points' if not.\n */\nconst form = Math.floor(parseFloat(query.get('form'), 10) || 0);\n\n/** How wide the form is; to be scaled by `viewScale`. */\nconst wide = parseFloat(query.get('wide'), 10) || 4e-3*pixelRatio;\n\n/** How many older state positions to fizz around, and other inputs. */\nconst fizz = {\n  at: parseFloat(query.get('fizz') ?? clamp(stepsPast, 5, 2e2), 10) || 0,\n  max: parseFloat(query.get('fizz-max') ?? clamp(stepsPast*1e-3, 7e-3, 15e-3),\n    10) || 0,\n  rate: parseFloat(query.get('fizz-rate') ?? 2e-5, 10) || 0,\n  curve: parseFloat(query.get('fizz-curve') ?? 1.7, 10) || 0\n};\n\n/** How much to shake the source around while idling. */\nconst shakeSource = parseFloat(query.get('shake-source') ?? 2e-3, 10) || 0;\n/** How much to shake the sink around while idling. */\nconst shakeSink = parseFloat(query.get('shake-sink') ?? 7e-2, 10) || 0;\n\n/** Hue range between 2 values. */\nconst hues = query.getAll('hue');\n\n// Parse any present hues, fill any missing hues, using only up to 2 hues.\nmap((h, i) => parseFloat(h, 10) || hues[i-1]+0.33 || 0.9,\n  range(hues, '', hues.length, hues.length = 2), 0);\n\n/**\n * Variable-step (delta-time) if given `false`y/`NaN`; fixed-step (add-step)\n * if given another number; uses default fixed-step if not given.\n */\nconst timeQuery = query.get('timestep');\n\n/** Whether to use a fixed timestep or render variably as soon as possible. */\nconst timestep = parseFloat(timeQuery ?? 1e3/60, 10) || null;\n\nconsole.log(location.search+':\\n', ...([...query.entries()].flat()), '\\n',\n  'steps:', steps, 'scale:', scale, 'timestep:', timestep, 'merge:', merge,\n  'depth:', fragDepth, 'form:', form, 'wide:', wide, 'fizz:', fizz,\n  'hues:', hues, 'shakeSource:', shakeSource, 'shakeSink:', shakeSink);\n\n// Set up the links.\n\nfunction setupLink(a, to) {\n  const { search, hash } = a;\n  const has = (search.length > 1) && getQuery(search).entries();\n\n  return a.href = '?'+\n    setQuery((has && to)? [...has, ...to] : ((has)? [...has] : to))+hash;\n}\n\nsetupLink(document.querySelector('#verlet'),\n  [['steps', 2+bound], ['scale', 9]]);\n\nsetupLink(document.querySelector('#euler'), [['steps', 1+bound], ['scale', 9]]);\nsetupLink(document.querySelector('#long'), [['steps', 9+bound], ['scale', 8]]);\nsetupLink(document.querySelector('#trace'), [['steps', 3e2], ['scale', 4]]);\nsetupLink(document.querySelector('#bubbles'));\nsetupLink(document.querySelector('#million'));\n\nsetupLink(document.querySelector('#trails'),\n  [['form', ((form)? ((form+1)%3 || null) : 1)]]);\n\nsetupLink(document.querySelector('#timestep'),\n  [['timestep', ((timeQuery == null)? '' : null)]]);\n\nsetupLink(document.querySelector('#merge'),\n  [['merge', ((!useMerge)? false : ((useMerge === 'false')? true : null))]]);\n\n/**\n * How state values map to any past state values they derive from.\n * Denoted as an array, nested 1-3 levels deep:\n * 1. In `values` order, indexes `values` to derive from, 1 step past.\n * 2. Indexes `values` to derive from, 1 step past.\n * 3. Shows how many steps past, then indexes `values` to derive from.\n */\nconst derives = [];\n\n// Position value derives from:\nderives[valuesIndex.position] = [\n  // Position, 2 steps past.\n  [wrap(1, stepsPast), valuesIndex.position],\n  // Position, 1 step past.\n  valuesIndex.position,\n  // Motion, 1 step past.\n  valuesIndex.motion,\n  // Life, 1 step past.\n  valuesIndex.life\n];\n\n// Motion value derives from:\nderives[valuesIndex.motion] = [\n  // Motion, 1 step past.\n  valuesIndex.motion,\n  // Life, 1 step past.\n  valuesIndex.life,\n  // Position, 1 step past.\n  valuesIndex.position\n];\n\n// Life value derives from:\nderives[valuesIndex.life] = [\n  // Life, last step past.\n  [wrap(-1, stepsPast), valuesIndex.life],\n  // Life, 1 step past.\n  valuesIndex.life\n];\n\nconsole.log(derives, '`derives`');\n\n/** Shake source or sink around while idling. */\nfunction shake(at, shaken, by, idle) {\n  const l = (Math.min(idle/4e3, 1)**3)*by;\n\n  if(!l) { return at; }\n\n  const a = Math.random()*Math.PI*2;\n  const [x, y, z, g] = at;\n\n  shaken[0] = x+(Math.cos(a)*l);\n  shaken[1] = y+(Math.sin(a)*l);\n  shaken[2] = z;\n  g != null && (shaken[3] = g);\n\n  return shaken;\n}\n\n/** The main `gl-gpgpu` state. */\nconst state = gpgpu(regl, {\n  // Logic given as state values, `gl-gpgpu` maps optimal inputs and outputs.\n  maps: {\n    // How many state values (channels) are tracked independently of others.\n    values,\n    // How state values map to any past state values they derive from.\n    derives\n  },\n  // How many steps of state to track.\n  steps,\n  // How many states are bound to frame-buffer outputs at any step.\n  bound,\n  // How many entries to track, here encoded as the power-of-2 size per side\n  // of the data texture: `(2**scale)**2`; can also be given in other ways.\n  scale,\n  // Whether to merge states into one texture; separate textures if not given.\n  merge,\n  // Data type according to platform capabilities.\n  // @todo Seems to move differently with `'half float'` Verlet integration.\n  type: ((extensionsFloat.every(regl.hasExtension))? 'float' : 'half float'),\n  // Configure macro hooks, global or per-shader.\n  macros: {\n    // No macros needed for the `vert` shader; all other macros generated.\n    macroVert: false\n  },\n  // A fragment shader to compute each state step, with `gl-gpgpu` macros.\n  // Vertex shaders can also be given.\n  frag: stepFrag,\n  // Macros are prepended to `frag` shader per-pass, cached in `frags`.\n  frags: [],\n  // Custom uniforms in addition to those `gl-gpgpu` provides.\n  uniforms: {\n    dt: (_, { props: { timer: t, rate: r } }) => t.dt*r,\n    dt0: (_, { props: { timer: t, rate: r } }) => t.dts[0]*r,\n    dt1: (_, { props: { timer: t, rate: r } }) => t.dts[1]*r,\n    time: (_, { props: { timer: t, rate: r } }) => t.time*r,\n    loop: (_, { props: { timer: t, loop: l } }) => Math.sin(t.time/l*Math.PI)*l,\n\n    // Shake the source around while idling.\n    source: (_, { props: { source: { at, shaken, shake: by }, timer: t } }) =>\n      shake(at, shaken, by, t.idle),\n\n    // Shake the sink around while idling.\n    sink: (_, { props: { sink: { at, shaken, shake: by }, timer: t } }) =>\n      shake(at, shaken, by, t.idle),\n\n    lifetime: regl.prop('props.lifetime'),\n    useVerlet: regl.prop('props.useVerlet'),\n    epsilon: regl.prop('props.epsilon'),\n    moveCap: regl.prop('props.moveCap'),\n    g: regl.prop('props.g'),\n    scale: regl.prop('props.scale'),\n\n    // One option in these arrays is used, by Euler/Verlet respectively.\n    spout: (_, { props: { spout: ss, useVerlet: u } }) => ss[+u],\n    // drag: (_, { props: { drag: ds, useVerlet: u } }) => ds[+u]\n  },\n  // Custom properties to be passed to shaders mixed in with `gl-gpgpu` ones.\n  props: {\n    // Set up the timer.\n    timer: timer((timestep)?\n        // Fixed-step (add-step).\n        { step: timestep, dts: range(2, 0), idle: 0 }\n        // Real-time (variable delta-time).\n      : { step: '-', now: () => regl.now()*1e3, dts: range(2, 0), idle: 0 }),\n\n    // Speed up or slow down the passage of time.\n    rate: 1,\n    // Loop time over this period to avoid instability of parts of the demo.\n    loop: 3e3,\n    // A particle's lifetime range, and whether it's allowed to spawn.\n    lifetime: [3e2, 4e3, +true],\n    // Whether to use Verlet (midpoint) or Euler (forward) integration.\n    useVerlet: +canVerlet,\n    // A small number greater than 0; avoids speeds exploding.\n    epsilon: 1e-5,\n    // How faar a particle can move in any frame.\n    moveCap: 4e-2,\n    // Whether to invert particle flow towards rather than away from source.\n    invert: false,\n    // The position around which particles spawn.\n    source: {\n      at: [0, 0, 0.4],\n      // Shake around while idling.\n      shake: shakeSource, shaken: []\n    },\n    // Sink position, and universal gravitational constant.\n    sink: {\n      at: [\n        // Sink position.\n        0, 0, 0.6,\n        // Universal gravitational constant (scaled).\n        6.674e-11*5e10\n      ],\n      // Shake around while idling.\n      shake: shakeSink, shaken: []\n    },\n    // Constant acceleration of gravity; and whether to use it or the `sink`.\n    g: [\n      // Constant acceleration of gravity.\n      0, -9.80665, 0,\n      // Whether to use it or the `sink`.\n      +false\n    ],\n    // For numeric accuracy, encoded as exponent `[b, p] => b*(10**p)`.\n    scale: [1, -7],\n\n    // One option in these arrays is used, by Euler/Verlet respectively.\n\n    // The distance from the `source`, and speed, that particles spawn with.\n    spout: [[0, 3e3], [0, 2e2]],\n    // Drag coefficient.\n    // drag: [range(3, 1e-3), range(3, 1e-1)]\n  }\n});\n\nconsole.log(self.state = state);\n\nconsole.group('How `values` are `packed` to fit texture channels efficiently');\nconsole.log(state.maps.values, '`values` (referred to by index)');\nconsole.log(state.maps.packed, '`packed` (indexes `values`)');\nconsole.log(...state.maps.textures, '`textures` (indexes `values`)');\nconsole.log(state.maps.valueToTexture, '`valueToTexture` (indexes `textures`)');\nconsole.groupEnd();\n\n// Set up rendering.\n\n/**\n * Draw all states with none bound as outputs.\n * @todo Errors without `merge`; why, if the framebuffer isn't bound?\n */\nconst drawBound = +(!merge);\n\nconst drawSteps = steps-drawBound;\nconst useLines = merge && (drawSteps > 1);\n\nconsole.log('drawSteps', drawSteps, 'useLines', useLines);\n\n/**\n * Vertex counts by form; how many steps a form covers, for all entries;\n * respectively for: none, points, lines.\n * Note `state.size.entries` equals the value returned by `countDrawIndexes`.\n */\nconst drawCounts = map((_, f) => indexForms(drawSteps, f, state.size.entries),\n  range(2+useLines), 0);\n\nconst viewScale = ({ drawingBufferWidth: w, drawingBufferHeight: h }) =>\n  Math.min(w, h);\n\n/** Reuse the `gpgpu` state, mix in drawing-specific state. */\nconst drawState = {\n  ...state,\n  // Omit some properties unused in drawing for some clarity.\n  count: undefined, vert: undefined, frag: undefined, attributes: undefined,\n  // Override other properties for drawing.\n  bound: drawBound,\n  // Drawing, not data - so no `output` macros. Also, don't need `frag` macros.\n  macros: { output: 0, frag: 0 },\n  drawProps: {\n    projection: [],\n    view: lookAt([], [0, 0, 4], [0, 0, 0], [0, 1, 0]),\n    // How many vertexes per form.\n    form: clamp(form || 2, 1, 1+useLines),\n    // Vertex counts by form; how many steps a form covers, for all entries.\n    counts: drawCounts,\n    // Which primitives can be drawn.\n    primitive: null,\n    primitives: [, 'points', 'lines'],\n    // How wide the form is; to be scaled by `viewScale`.\n    wide,\n    // How many older state positions to fizz around, and other inputs.\n    fizz,\n    // Hue range to colour particles.\n    hues,\n\n    // One option in these arrays is used, by Euler/Verlet respectively.\n\n    // Speed-to-colour scaling, as `[multiply, power]`.\n    pace: [[1e-3, 0.4], [3e2, 0.4]]\n  },\n  // Map everything similarly to the `gpgpu` step, `mapStep` can be reused to\n  // create new mappings with some additions for drawing.\n  maps: mapStep({\n    ...state.maps,\n    // This one pass can bind textures for input; not output across passes.\n    texturesMax: maxTextureUnits,\n\n    /**\n     * One set of lookups/reads of all values in one pass.\n     * Passing `true` adds all values at that level of nesting:\n     * `pass|[values|[value|[step, value]]]`\n     * Thus, this example means that the _first_ value derives from:\n     * - All values 1 step past (`true`).\n     * - The position value 2 steps past.\n     * Makes `reads_0_i` macros for each `i => [step, value]` of\n     * `[[0, 0], [0, 1], [0, 2], [1, 0]]`\n     */\n    derives: [[true, [wrap(1, drawSteps), valuesIndex.position]]]\n  })\n};\n\n/** The `GL` render command pipeline state. */\nconst drawPipeline = {\n  // Use `gpgpu` `macro` mappings by prepending `macro`s from a single pass.\n  vert: macroPass(drawState)+drawVert,\n  frag: drawFrag,\n  // Maximum count here to set up buffers, can be partly used later.\n  attributes: { index: getDrawIndexes(Math.max(...drawCounts)) },\n  // Hook up `gpgpu` uniforms by adding them here.\n  uniforms: toUniforms(drawState, {\n    ...drawState.uniforms,\n    projection: regl.prop('drawProps.projection'),\n    view: regl.prop('drawProps.view'),\n    // How many vertexes per form.\n    form: regl.prop('drawProps.form'),\n    fizz: regl.prop('drawProps.fizz.at'),\n    fizzMax: regl.prop('drawProps.fizz.max'),\n    fizzRate: regl.prop('drawProps.fizz.rate'),\n    fizzCurve: regl.prop('drawProps.fizz.curve'),\n    hues: regl.prop('drawProps.hues'),\n    pace: (_, { drawProps: dp, props: p }) => dp.pace[+p.useVerlet],\n    pointSize: (c, p) => clamp(p.drawProps.wide*viewScale(c), ...pointSizeDims)\n  }),\n  lineWidth: (c, p) => clamp(p.drawProps.wide*viewScale(c), ...lineWidthDims),\n  // Vertex counts by form; how many steps a form covers, for all entries.\n  count: (_, { count: c, drawProps: { counts: cs, form: f } }) => c ?? cs[f],\n  depth: { enable: true },\n  blend: { enable: true, func: { src: 'one', dst: 'one minus src alpha' } },\n\n  primitive: (_, { drawProps: { primitive: p, primitives: ps, form: f } }) =>\n    p ?? ps[f]\n};\n\nconsole.log((self.drawState = drawState), (self.drawPipeline = drawPipeline));\n\n/** Function to execute the render command pipeline state every frame. */\nconst draw = regl(drawPipeline);\n\nfunction stepTime(state) {\n  const { dts } = state;\n\n  dts[0] = dts[1];\n  state.idle += (dts[1] = timer(state).dt);\n\n  return state;\n}\n\nconst clearView = { color: [0, 0, 0, 0], depth: 1 };\n\nregl.frame(() => {\n  try {\n    stepTime(state.props.timer);\n    // Compute the next step of state.\n    state.step();\n    // Update the draw state.\n    drawState.stepNow = (state.stepNow+1)-drawBound;\n    regl.clear(clearView);\n    draw(drawState);\n  }\n  catch(e) { toggleError(e); }\n});\n\nfunction stopEvent(e) {\n  e.stopPropagation();\n  e.preventDefault();\n}\n\n/** Pause the spawning while pointer is held down. */\nlet hold;\n\n/** Pause particles spawning. */\ncanvas.addEventListener('contextmenu', (e) => {\n  // Whether a particle's allowed to spawn.\n  state.props.lifetime[2] = +false;\n  hold = false;\n  stopEvent(e);\n});\n\n/** Toggle physics and graphics modes. */\ncanvas.addEventListener((('onpointerup' in self)? 'pointerup'\n    : (('ontouchend' in self)? 'touchend' : 'mouseup')),\n  (e) => {\n    /** Unpause the spawning when pointer is released. */\n    const spawned = state.props.lifetime[2];\n    const held = hold;\n\n    // Whether a particle's allowed to spawn.\n    state.props.lifetime[2] = +true;\n    hold = false;\n\n    // Don't switch modes if pointer was being held down, particles weren't\n    // allowed to spawn, or any non-primary button was released.\n    if(held || !spawned || (e.button !== 0)) { return; }\n\n    // Switch between physics/drawing modes if this wasn't press-held.\n\n    const { props: p, drawProps: d } = drawState;\n    const v = canVerlet && (p.useVerlet = 1-p.useVerlet);\n    const f = form || (d.form = 1+(useLines && ((canVerlet)? v : d.form%2)));\n\n    console.log('useVerlet', v, 'form', f,\n      // See how this derives other properties.\n      'count', drawPipeline.count(0, drawState),\n      'primitive', drawPipeline.primitive(0, drawState));\n  });\n\n/** Move either the source or the sink, according to primary pointer. */\ncanvas.addEventListener((('onpointermove' in self)? 'pointermove'\n    : (('ontouchmove' in self)? 'touchmove' : 'mousemove')),\n  (e) => {\n    const { clientX: x, clientY: y, type, pointerType, isPrimary = true } = e;\n    const { left, top, width: w, height: h } = canvas.getBoundingClientRect();\n    const { source: { at: i }, sink: { at: o }, invert } = state.props;\n    const touch = ((type === 'touchmove') || (pointerType === 'touch'));\n    /** Move source or sink, switch by primary/other pointer/s `xor` invert. */\n    const to = ((isPrimary !== invert)? i : o);\n    const size = Math.min(w, h);\n\n    to[0] = (((x-((w-size)*0.5)-left)/size)*2)-1;\n    to[1] = -((((y-((h-size)*0.5)-top)/size)*2)-1);\n    // For touch devices, don't pause spawn if touch moves while held down.\n    touch && (hold = true);\n    // Reset the idle time for any movement.\n    state.props.timer.idle = 0;\n  });\n\n/** Switch primary pointer control between source and sink. */\ncanvas.addEventListener('dblclick', (e) => {\n  state.props.invert = !state.props.invert;\n  stopEvent(e);\n});\n\n/** Resize the canvas and any dependent properties. */\nfunction resize() {\n  const w = canvas.width = innerWidth*pixelRatio;\n  const h = canvas.height = innerHeight*pixelRatio;\n\n  perspective(drawState.drawProps.projection, 60, w/h, 1e-4, 1e4);\n}\n\naddEventListener('resize', resize);\nresize();\n","/**\n * The update step for a GPGPU particle simulation.\n * Requires setup with preprocessor macros - see `macroPass`.\n * Executed in one or more passes; each chunk depending on a `gpgpu` macro may\n * be combined with others into one pass or separated into its own pass; `gpgpu`\n * preprocessor macros control the combination according to which `values` are\n * currently bound for `output` to the next `state`.\n *\n * @see {@link step.toStep}\n * @see {@link macros.macroPass}\n */\n\n#ifdef GL_EXT_draw_buffers\n  #extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\n\n// Setting up the macros and aliases `gl-gpgpu` provides.\n\n// Note that these `texture_i`/`channels_i`/`reads_i_j` indexes correspond to a\n// value at that index in the `values`/`derives` arrays provided to `gl-gpgpu`;\n// they are defined here to match that arrangement.\n\n// The texture channels each of the `values` is stored in.\n#define positionChannels gpgpu_channels_0\n#define motionChannels gpgpu_channels_1\n#define lifeChannels gpgpu_channels_2\n\n/** Set up sampling logic via `gl-gpgpu` macro. */\ngpgpu_useSamples\n\n// Set up minimal texture reads logic; only read what a value with a currently\n// bound output `derives` from other `values` for its next state.\n// See `derives` for indexing `reads_${bound value index}_${derives index}`.\n#ifdef gpgpu_output_0\n  #define positionOutput gpgpu_output_0\n  gpgpu_useReads_0\n  #define positionReadPosition0 gpgpu_reads_0_0\n  #define positionReadPosition1 gpgpu_reads_0_1\n  #define positionReadMotion gpgpu_reads_0_2\n  #define positionReadLife gpgpu_reads_0_3\n#endif\n#ifdef gpgpu_output_1\n  #define motionOutput gpgpu_output_1\n  gpgpu_useReads_1\n  #define motionReadMotion gpgpu_reads_1_0\n  #define motionReadLife gpgpu_reads_1_1\n  #define motionReadPosition gpgpu_reads_1_2\n#endif\n#ifdef gpgpu_output_2\n  #define lifeOutput gpgpu_output_2\n  gpgpu_useReads_2\n  #define lifeReadLifeLast gpgpu_reads_2_0\n  #define lifeReadLife1 gpgpu_reads_2_1\n#endif\n\n// The main shader.\n\n// States from `gl-gpgpu`; in separate textures or merged.\n#ifdef gpgpu_mergedStates\n  uniform sampler2D gpgpu_states;\n#else\n  uniform sampler2D gpgpu_states[gpgpu_stepsPast*gpgpu_textures];\n#endif\n\n/** Current step from `gl-gpgpu`; needed for `tapStates` or `tapStatesBy`. */\nuniform float gpgpu_stepNow;\n\n// Custom inputs for this demo.\n\nuniform float dt0;\nuniform float dt1;\nuniform float loop;\n/** A particle's lifetime range, and whether it's allowed to respawn. */\nuniform vec3 lifetime;\nuniform float useVerlet;\nuniform float epsilon;\nuniform float moveCap;\nuniform vec2 scale;\nuniform vec2 spout;\nuniform vec3 source;\n/** Sink position, and universal gravitational constant. */\nuniform vec4 sink;\n/** Constant acceleration of gravity; and whether to use it or the `sink`. */\nuniform vec4 g;\n// uniform vec3 drag;\n\nvarying vec2 uv;\n\n#pragma glslify: le = require(glsl-conditionals/when_le)\n#pragma glslify: random = require(glsl-random)\n\n#ifdef positionOutput\n  /** @todo Try Velocity Verlet integration. */\n  #pragma glslify: verlet = require(@epok.tech/glsl-verlet/p-p-a)\n#endif\n\n#ifdef lifeOutput\n  #pragma glslify: map = require(glsl-map)\n#endif\n\n#if defined(positionOutput) || defined(motionOutput)\n  #pragma glslify: tau = require(glsl-constants/TWO_PI)\n  #pragma glslify: onSphere = require(./on-sphere)\n#endif\n\n/**\n * Drag acceleration, constrained within the given velocity.\n * @see [Wikipedia on Verlet](https://en.wikipedia.org/wiki/Verlet_integration#Algorithmic_representation)\n */\n// vec3 dragAcc(vec3 velocity, vec3 drag) {\n//   vec3 l = abs(velocity);\n\n//   return clamp(-0.5*sign(velocity)*dot(velocity, velocity)*drag, -l, l);\n// }\n\nvoid main() {\n  // Sample the desired state values - creates the `gpgpu_data` `array`.\n  gpgpu_tapState(uv)\n\n  // Read values.\n\n  #ifdef positionOutput\n    vec3 position0 = gpgpu_data[positionReadPosition0].positionChannels;\n  #endif\n\n  // If reads all map to the same value sample, any of them will do.\n  #if defined(positionOutput) || defined(motionOutput)\n    #if defined(positionOutput)\n      #define readMotion positionReadMotion\n      #define readPosition positionReadPosition1\n    #elif defined(motionOutput)\n      #define readMotion motionReadMotion\n      #define readPosition motionReadPosition\n    #endif\n\n    vec3 position1 = gpgpu_data[readPosition].positionChannels;\n    vec3 motion = gpgpu_data[readMotion].motionChannels;\n  #endif\n\n  // If reads all map to the same value sample, any of them will do.\n  #if defined(positionOutput)\n    #define readLife positionReadLife\n  #elif defined(lifeOutput)\n    #define readLife lifeReadLife\n  #elif defined(motionOutput)\n    #define readLife motionReadLife\n  #endif\n\n  float life = gpgpu_data[readLife].lifeChannels;\n\n  #ifdef lifeOutput\n    float lifeLast = gpgpu_data[lifeReadLifeLast].lifeChannels;\n  #endif\n\n  // Update and output values.\n  // Note that the update/output logic components within each `#if` macro\n  // block from `gpgpu` are independent modules, as the `gpgpu` macros\n  // determine whether they're executed across one or more passes - they could\n  // also be coded in separate files called from here, however they're coded\n  // inline here for brevity, relevance, and easy access to shared variables.\n\n  /** Whether the particle is ready to respawn. */\n  float spawn = le(life, 0.0);\n\n  #if defined(positionOutput) || defined(motionOutput)\n    // Workaround for switching Euler/Verlet; interpret `motion` data as\n    // acceleration/velocity, respectively.\n    vec3 velocity = motion;\n    vec3 acceleration = motion;\n\n    /** Spawn randomly on a sphere around the source, move in that direction. */\n    vec3 spoutSpawn = random(loop-(uv*dt0))*\n      onSphere(random((uv+loop)/dt1)*tau, random((uv-loop)*dt0));\n  #endif\n\n  #ifdef positionOutput\n    /** For numeric accuracy, encoded as exponent `[b, p] => b*(10**p)`. */\n    float size = scale.s*pow(10.0, scale.t);\n\n    /**\n     * Constrain Verlet movement; handle here for better numerical accuracy.\n     * Any position changes below the movement cap remain the same; any\n     * bigger clamped towards current position, by the ratio over the limit.\n     */\n    vec3 back = mix(position0, position1,\n      clamp((distance(position1, position0)/moveCap)-1.0, 0.0, 1.0));\n\n    // Use either Euler integration...\n    vec3 positionTo = mix(position1+(velocity*dt1*size),\n      // ... or Verlet integration...\n      verlet(back, position1, acceleration*size, dt0, dt1),\n      // ... according to which is currently active.\n      useVerlet);\n\n    /** Spawn around the source. */\n    vec3 positionSpawn = source+(spout.x*spoutSpawn);\n\n    /** Output the next position value to its channels in the state texture. */\n    positionOutput = mix(positionTo, positionSpawn, spawn);\n  #endif\n  #ifdef motionOutput\n    /**\n     * Gravitate towards the sink point (simplified).\n     * @see [Wikipedia on gravitation](https://en.wikipedia.org/wiki/Newton%27s_law_of_universal_gravitation)\n     */\n    vec3 gravity = sink.xyz-position1;\n\n    gravity *= sink.w/max(dot(gravity, gravity), epsilon);\n\n    /** Use sink point, or constant acceleration due to gravity. */\n    acceleration = mix(gravity, g.xyz, g.w);\n\n    /** Can also combine other forces, e.g: drag. */\n    // acceleration += dragAcc(mix(velocity, acceleration*dt1, useVerlet), drag);\n\n    vec3 motionTo = mix(velocity+(acceleration*dt1), acceleration, useVerlet);\n    vec3 motionNew = spout.y*spoutSpawn;\n\n    /** Output the next motion value to its channels in the state texture. */\n    motionOutput = mix(motionTo, motionNew, spawn);\n  #endif\n  #ifdef lifeOutput\n    float lifeTo = max(life-dt1, 0.0);\n    float lifeNew = map(random(uv*loop), 0.0, 1.0, lifetime.s, lifetime.t);\n    /** Whether the oldest of this trail has faded. */\n    float faded = le(lifeLast, 0.0);\n\n    /**\n     * Output the next life value to its channels in the state texture.\n     * Only spawn life once the oldest step reaches the end of its lifetime\n     * (past and current life are both 0), and if it's allowed to respawn.\n     */\n    lifeOutput = mix(lifeTo, lifeNew, spawn*faded*lifetime.z);\n  #endif\n}\n","import { cross3 } from \"@thi.ng/vectors/cross\";\nimport { dot3 } from \"@thi.ng/vectors/dot\";\nimport { normalize3 } from \"@thi.ng/vectors/normalize\";\nimport { setC } from \"@thi.ng/vectors/setc\";\nimport { sub3 } from \"@thi.ng/vectors/sub\";\n/**\n * Constructs a 4x4 camera matrix for given `eye` position, look-at\n * `target` (both in world space) and normalized `up` vector. Creates\n * new matrix if `out` is `null`.\n *\n * @param out -\n * @param eye -\n * @param target -\n * @param up -\n */\nexport const lookAt = (out, eye, target, up) => {\n    const z = normalize3(null, sub3([], eye, target));\n    const x = normalize3(null, cross3([], up, z));\n    const y = normalize3(null, cross3([], z, x));\n    return setC(out || [], x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, -dot3(eye, x), -dot3(eye, y), -dot3(eye, z), 1);\n};\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see {@link macros.macroPass}\n * @see {@link macros.macroValues}\n */\n\nprecision highp float;\n\n// The texture channels each of the `values` is stored in.\n#define positionChannels gpgpu_channels_0\n#define motionChannels gpgpu_channels_1\n#define lifeChannels gpgpu_channels_2\n// Set up sampling logic.\ngpgpu_useSamples\n// Only the first value derives from all values, giving these minimal `reads`.\ngpgpu_useReads_0\n// These first `derives` are all in one pass, `0`, in the order of `values`.\n// See `values` for indexing `reads_0_${derives index == values index}`.\n#define readPosition1 gpgpu_reads_0_0\n#define readMotion gpgpu_reads_0_1\n#define readLife gpgpu_reads_0_2\n// Additional `derives` are individually specified.\n#define readPosition0 gpgpu_reads_0_3\n\nattribute float index;\n\n// States from `gl-gpgpu`; in separate textures or merged.\n#ifdef gpgpu_mergedStates\n  uniform sampler2D gpgpu_states;\n#else\n  uniform sampler2D gpgpu_states[gpgpu_stepsPast*gpgpu_textures];\n#endif\n\n/** Current step from `gl-gpgpu`; needed for `tapStates` or `tapStatesBy`. */\nuniform float gpgpu_stepNow;\n/** Further `gl-gpgpu` uniforms. */\nuniform vec4 gpgpu_stateShape;\nuniform vec2 gpgpu_viewShape;\n\nuniform mat4 projection;\nuniform mat4 view;\nuniform float pointSize;\nuniform float dt;\nuniform float time;\nuniform vec3 lifetime;\nuniform vec2 pace;\nuniform float useVerlet;\nuniform float form;\nuniform float loop;\nuniform vec2 hues;\n\nuniform float fizz;\nuniform float fizzMax;\nuniform float fizzRate;\nuniform float fizzCurve;\n\nvarying vec4 color;\nvarying vec3 center;\nvarying float radius;\n\n#pragma glslify: aspect = require(@epok.tech/glsl-aspect/contain)\n#pragma glslify: gt = require(glsl-conditionals/when_gt)\n#pragma glslify: random = require(glsl-random)\n#pragma glslify: map = require(glsl-map)\n#pragma glslify: tau = require(glsl-constants/TWO_PI)\n#pragma glslify: hsl2rgb = require(glsl-hsl2rgb)\n\n#pragma glslify: onSphere = require(./on-sphere)\n#pragma glslify: indexUV = require(../../src/lookup/index-uv)\n#pragma glslify: offsetUV = require(../../src/lookup/offset-uv)\n\n#if gpgpu_stepsPast > 1\n  // If multiple steps are given, shift into past steps.\n  // Lookups mostly equivalent; input and result iteration order differ.\n  #define indexFormsStates\n  #ifdef indexFormsStates\n    #pragma glslify: indexStates = require(../../src/index-forms/index-states)\n  #else\n    #pragma glslify: indexEntries = require(../../src/index-forms/index-entries)\n  #endif\n#endif\n\nconst vec4 noPosition = vec4(0, 0, -1, 0);\n\nvoid main() {\n  #if gpgpu_stepsPast > 1\n    // If multiple steps are given, find past step and entry.\n    // Lookups mostly equivalent; input and result iteration order differ.\n    #ifdef indexFormsStates\n      vec2 stepEntry = indexStates(index, gpgpu_stepsPast, form);\n    #else\n      vec2 stepEntry = indexEntries(index, gpgpu_entries, form);\n    #endif\n\n    float stepPast = stepEntry.s;\n    float entry = stepEntry.t;\n  #else\n    // If only 1 step is given, past step and entry are known.\n    float stepPast = 0.0;\n    float entry = index;\n  #endif\n\n  // Turn 1D index into 2D texture UV; offset to texel center, avoids errors.\n  vec2 st = offsetUV(indexUV(entry, gpgpu_stateShape.xy), gpgpu_stateShape.xy);\n\n  // Can also use the `reads` logic to take the minimum possible samples here.\n  // Sample the desired state values; creates the `gpgpu_data` `array`.\n  #if gpgpu_stepsPast > 1\n    // Shift into past steps.\n    gpgpu_tapStateBy(st, stepPast, 0)\n  #else\n    // No past steps, no shift.\n    gpgpu_tapState(st)\n  #endif\n\n  // Read values.\n  vec3 position0 = gpgpu_data[readPosition0].positionChannels;\n  vec3 position1 = gpgpu_data[readPosition1].positionChannels;\n  vec3 motion = gpgpu_data[readMotion].motionChannels;\n  float life = gpgpu_data[readLife].lifeChannels;\n  float alive = gt(life, 0.0);\n  float ago = stepPast/max(float(gpgpu_stepsPast-1), 1.0);\n  vec2 ar = aspect(gpgpu_viewShape);\n\n  /** Fizz randomly on a sphere around older positions. */\n  float fizzBy = pow(clamp(stepPast/fizz, 0.0, 1.0), fizzCurve)*fizzMax;\n  float fizzAt = (time/fizzBy)*mix(fizzRate, -fizzRate, mod(entry, 2.0));\n  float fizzAngle = (random(position1.xy)+fizzAt)*tau;\n  float fizzDepth = (sin(random(vec2(position1.z, ago))+fizzAt)+1.0)*0.5;\n  vec3 position = position1+(fizzBy*onSphere(fizzAngle, fizzDepth));\n\n  /** @todo Perspective camera transform. */\n  vec4 vertex = mix(noPosition, vec4(position.xy*ar, position.z, 1), alive);\n  // vec4 vertex = projection*view*mix(noPosition, vec4(position, 1), alive);\n  float depth = clamp(1.0-(vertex.z/vertex.w), 0.1, 1.0);\n  float alpha = clamp(pow(life/lifetime.t, 0.1)*pow(1.0-ago, 0.4), 0.0, 1.0);\n  float size = pointSize*depth*alpha;\n\n  gl_Position = vertex;\n  // gl_Position = projection*view*vertex;\n  gl_PointSize = size;\n\n  radius = size*0.5;\n\n  /**\n   * Convert vertex position to `gl_FragCoord` window-space.\n   * @see [SO](https://stackoverflow.com/a/7158573)\n   * @todo Might need the viewport `x` and `y` offset as well as `w` and `h`?\n   */\n  center = vec3(gpgpu_viewShape*((1.0+vertex.xy)/vertex.w)*0.5, vertex.z);\n\n  float speed = length(mix(motion, position1-position0, useVerlet))/dt;\n\n  color = vec4(hsl2rgb(fract(mix(hues.s, hues.t, entry/float(gpgpu_entries))),\n      mix(0.8, 0.1, ago),\n      mix(0.3, 0.8, clamp(pow(speed*pace.s, pace.t), 0.0, 1.0))),\n    alpha);\n}\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see {@link macros.macroPass}\n * @see {@link macros.macroValues}\n *\n * @todo Simple light shading.\n */\n\n#ifdef GL_EXT_frag_depth\n  #extension GL_EXT_frag_depth : enable\n#endif\n\nprecision highp float;\n\nvarying vec4 color;\nvarying vec3 center;\nvarying float radius;\n\nvoid main() {\n  // Fade out to transparent when the fragment is beyond the radius.\n  vec2 vc = center.xy-gl_FragCoord.xy;\n  float vcl2 = dot(vc, vc);\n  float r2 = radius*radius;\n\n  if(vcl2 > r2) { discard; }\n\n  /** @todo Ensure this is a correct distance to the sphere's surface. */\n  // float d2 = vcl2/r2;\n  // float d = sqrt(vcl2)/sqrt(r2);\n  // vec4 c = vec4(color.rgb, mix(color.a, 0.0, clamp(d2, 0.0, 1.0)));\n  // vec4 c = vec4(color.rgb, mix(color.a, 0.0, clamp(d, 0.0, 1.0)));\n\n  /** @todo Attenuated point lights shading. */\n  // gl_FragColor = c*c.a;\n  gl_FragColor = color*color.a;\n\n  #ifdef GL_EXT_frag_depth\n    float d2 = vcl2/r2;\n    // float d = sqrt(vcl2)/sqrt(r2);\n\n    gl_FragDepthEXT = center.z+d2;\n    // gl_FragDepthEXT = center.z+d;\n  #endif\n}\n"],"names":["$a01c1743429d3e59$exports","value","min","max","$b3964aaad8fda0da$export$6b5c1ceb16d01dc3","Math","PI","$b3964aaad8fda0da$export$460c4029b1a54a2e","sqrt","SQRT2","$68aa7d9ee9ca53ae$export$ba8c70ce75474f8d","out","x","y","z","$68aa7d9ee9ca53ae$export$644e79245f7d24b5","xs","i","n","length","$072421a093ed6183$export$89b5708c387cac6c","left","right","bottom","top","near","far","dx","dy","dz","$072421a093ed6183$export$afe7eeb07fe5f7b2","fovy","aspect","tan","$0367cff52b8c59c1$export$541149539f3a4684","fov","f","$9e5e53b76f010ff4$export$ea0ef2e80b79c3dc","a","b","$630cf5f84e081426$export$651a6eb01ea522f3","prefix","suffix","msg","undefined","_class","Error","constructor","super","$3128c18ce734bb9c$export$772aa0961a81b065","$3128c18ce734bb9c$export$9f1b9fbfe882200d","$4daa5afeca57f35e$export$1af3c925c49f37a2","fns","c","d","e","g","h","j","fn","slice","$6b49baca42efb0d0$export$c915e14294a7d06f","$dfb5b30c6d908610$export$eca2c7e8e95bbf0a","xform","$fef57b34ba00bad0$export$1af3c925c49f37a2","map","apply","$da47d07e174a640f$export$9652023d9040757","Symbol","iterator","$9a7c77cefab93b72$export$5adef4befe47917","rfn","$ea4e12bfe302938f$export$a7d1fa727cb10b0e","$ea4e12bfe302938f$export$ca96bc7645ad7951","$7b847044c2380372$export$ce266a425291df6c","deref","this","val","$7b847044c2380372$export$447808b60b7559bd","$7b847044c2380372$export$ebab785f9ea33473","$7b847044c2380372$export$f2412ace46b7b087","$7b847044c2380372$export$7ca7c14b24aa137b","$3072a586f8c8673a$var$parseArgs","args","$3072a586f8c8673a$export$533b26079ad0b4b","init","complete","reduce","acc","$reduce","$3072a586f8c8673a$var$reduceArray","$3072a586f8c8673a$var$reduceIterable","$3072a586f8c8673a$export$1650419e431d3ba3","$b7e823dcafb817e0$export$4cbf152802aa238","push","$f893a3757b99dddc$export$6f58e2338da23f4d","$f893a3757b99dddc$export$a6bff14a9cefe0e8","_","$f893a3757b99dddc$export$9b6eac2a13c3d07","impl","$ba3e37c792b66d25$export$871de8747c9eaa88","src","r","$237b0f7183f6b744$export$e5bd5b3b105c2a71","$79f29f153b83220e$export$d02631cccf789723","from","to","step","$79f29f153b83220e$export$9a58ef0d7ad3278c","i1","n1","Infinity","$4761cbe27dee2936$export$42d51816ce590c93","sep","first","join","$9164f56840376116$export$b7df5d561049483a","m","$e6027f8131fa1aae$export$9608d0eacffd6284","$e6027f8131fa1aae$var$$transduce","tfn","$2f28120a5e9dd6c0$export$8901015135f2fb22","iters","s","tuple","v","next","done","$1bdcc8fbde9dbea8$export$ab59e00737fb22e6","$1bdcc8fbde9dbea8$export$98e633703a635f","$684ae16ac4c6e87b$export$c37d18c23b2ea60c","dispatch","impls","Array","fallback","add","dim","default","$835cbc0e8ade207d$export$da5c1e34018ecc43","op","o","$835cbc0e8ade207d$export$4061f92b6da4a345","$edf93247eb71c2ac$var$indicesStrided","sym","$edf93247eb71c2ac$var$lookup","$edf93247eb71c2ac$var$indices","$edf93247eb71c2ac$var$assemble","tpl","syms","ret","opJoin","pre","post","strided","split","$edf93247eb71c2ac$var$assembleG","$edf93247eb71c2ac$export$6d9e0940428d9eae","$edf93247eb71c2ac$export$ef7acd7185315e22","Function","$edf93247eb71c2ac$export$aeba7862bf0c66c4","$edf93247eb71c2ac$export$e40cf5ce9a490533","$","$eb04e9e10bb8973b$var$$","$eb04e9e10bb8973b$export$94132a0e348806d4","$eb04e9e10bb8973b$export$6f9aa2c904053c13","$2d680bc1793551bc$var$$","$2d680bc1793551bc$export$57ce51e080b800","$2d680bc1793551bc$export$9bdeebc943bb634d","$0c5c7a375eff632c$export$523c9d3eb3d8d990","$0c5c7a375eff632c$export$b54ddf06b57709b1","$0c5c7a375eff632c$export$1c0ad2738a5ae4b0","$0c5c7a375eff632c$export$1f214a01989f466a","$b804d81b6158abb4$export$adaa4cf7ef1b65be","$b804d81b6158abb4$export$55640438a4edf3d6","$b804d81b6158abb4$export$9cbac02f28c9a9a9","$b804d81b6158abb4$export$a7c139a4194832bf","$35de51900c18e82b$export$6feaa6aa9769ce13","$8d96101118716470$export$f93b5905241a7cca","$8d96101118716470$export$27409c384c4283a","$8d96101118716470$export$4d77c846ee8dc708","$8d96101118716470$export$317805a8a51cab87","$2e2a25a52591e6ab$export$be3f796aed065412","diff","dt","pause","$2e2a25a52591e6ab$export$7548f4bc1b09ff22","$2e2a25a52591e6ab$export$85b884786400d38f","$2e2a25a52591e6ab$export$eb8a9b7a1ebec59a","Date","now","$2e2a25a52591e6ab$export$2e2bcd8739ae039","state","time","t0","_step","ref","ref1","t","t1","isNaN","$3ff2f9e4ab7bdeff$var$r","prototype","$3ff2f9e4ab7bdeff$export$533b26079ad0b4b","call","$3ff2f9e4ab7bdeff$export$2e2bcd8739ae039","$f132d33d57f1bee8$export$2e2bcd8739ae039","$3846eaa2ea51626f$var$e","forEach","$3846eaa2ea51626f$export$2e2bcd8739ae039","fill","$14f586be6fb44fe8$var$fill","isFinite","$14f586be6fb44fe8$var$isFinite","Number","floor","$14f586be6fb44fe8$var$floor","$14f586be6fb44fe8$export$2e2bcd8739ae039","l","start","end","$df9d8a68b07f20b6$export$2e2bcd8739ae039","$1998443839f93237$export$2e2bcd8739ae039","$609e7c658f51082e$export$ba60520149d1328e","$609e7c658f51082e$export$85b9a36db797e02b","$609e7c658f51082e$export$878041e1e4cd4218","flat","$bc78d1a683d7cfc1$export$dc207adda608f979","$parcel$interopDefault","$bc78d1a683d7cfc1$export$cfdc3a7c4cb854c6","$bc78d1a683d7cfc1$export$832d88422d279bbc","$bc78d1a683d7cfc1$export$ac0cd3cc21f80dfc","$bc78d1a683d7cfc1$export$4bceda1224fc5ab8","$bc78d1a683d7cfc1$export$b4781c2237bde956","$bc78d1a683d7cfc1$export$26945b8c914b7fc","$bc78d1a683d7cfc1$export$154f256b9eac9103","$bc78d1a683d7cfc1$export$b6267c3f91c57c78","$bc78d1a683d7cfc1$export$b029aceb5666f022","$bc78d1a683d7cfc1$export$617a37502ff8853","$bc78d1a683d7cfc1$export$ff01eb58fe4e69","$bc78d1a683d7cfc1$export$27fb0dad99ae5dd2","$bc78d1a683d7cfc1$export$47b10f415de592b1","$bc78d1a683d7cfc1$export$1fb689c67b965bff","$bc78d1a683d7cfc1$export$8d7f4a48e1f2b2a","$bc78d1a683d7cfc1$export$a211ab2c8ecded9a","$bc78d1a683d7cfc1$export$a1b7c201e9365814","$bc78d1a683d7cfc1$export$d5373eb478d25864","$bc78d1a683d7cfc1$export$5544d416ac8224f1","$bc78d1a683d7cfc1$export$2902d6d00b7c2bce","$bc78d1a683d7cfc1$export$2fcc13103217f9a3","color","depth","stencil","$bc78d1a683d7cfc1$export$78f9fb74e68ed5c6","$bc78d1a683d7cfc1$export$72e520e6a70b780c","copy","isInteger","$bbb23253d9fa3113$var$isInteger","$bbb23253d9fa3113$export$5ca26c99531348ec","channelsMax","console","error","$bbb23253d9fa3113$export$9d1d9285bd6d8c57","values","channels","packed","fitIndex","fitSize","fit","pack","$bbb23253d9fa3113$export$574963e692b662ec","maps","derives","passes","textures","valueToTexture","reads","cache","all","getAddSample","pass","set","derive","texture","findIndex","samples","p","valueDerives","getAddSamples","$bbb23253d9fa3113$export$798cdecdcbbf9755","buffersMax","valueToPass","textureToPass","getValue","getIndex","index","$bbb23253d9fa3113$export$96707a1f51900f3d","$590beef2a696b8fd$var$isFinite","$590beef2a696b8fd$var$isInteger","$590beef2a696b8fd$export$3c49c185de0c2bfc","width","w","shape","size","side","v0","$590beef2a696b8fd$export$c08559766941f856","height","v1","$590beef2a696b8fd$export$87ed20f81f3c66ff","entries","$590beef2a696b8fd$export$2815acae70277c92","$590beef2a696b8fd$export$f99427edb65f5558","scale","$db5eb7ff43e44c77$var$isInteger","$db5eb7ff43e44c77$export$24a6b176bdc41ce5","framebuffer","steps","merge","type","mag","wrap","scaled","channelsMin","texturesMap","passChannels","sum","mergeChannels","framebuffers","colors","colorPool","addTexture","entry","addPass","mScaled","mw","mh","$fac1b09e36acee4f$export$abee0037e1db715","$42d53ffb3630b5df$export$1aad3af825e3305b","uniforms","bound","stepsL","texturesL","stateShape","viewShape","stepNow","drawingBufferWidth","drawingBufferHeight","addTextures","ago","ts","pl","$3de062af33d77200$var$start","$3de062af33d77200$var$end","$3de062af33d77200$export$bf9fb029d174d554","toString","$5bb6ca9eea4b6017$export$497faa7f0daf9da","$5bb6ca9eea4b6017$var$id","JSON","stringify","$5bb6ca9eea4b6017$export$11949c6f5fba7dcd","$5bb6ca9eea4b6017$export$feaf5ffc92c2af94","key","on","macros","Object","$5bb6ca9eea4b6017$export$83d01c7b88bc16d5","name","qualify","$5bb6ca9eea4b6017$export$45db4de6da38aa8d","$5bb6ca9eea4b6017$export$3df19e70a88cb8cd","$5bb6ca9eea4b6017$export$1c7039c93eddfba","$5bb6ca9eea4b6017$export$c346962e7dd3191","glsl","trim","$5bb6ca9eea4b6017$export$d38b14fb9031108e","passesL","$5bb6ca9eea4b6017$export$84186522bf5a7d4d","passNow","$5bb6ca9eea4b6017$export$49873e279ff642c0","passSamples","passReads","$5bb6ca9eea4b6017$export$9cb6037fa2a40c2e","glsl3","tap","by","aka","akaBy","st","tapsSamples","$5bb6ca9eea4b6017$export$562ddd36066ad650","$dca3c1826e5966d7$export$d86e3abd7686c23f","ps","$dca3c1826e5966d7$export$12661000d11a17d2","copyFrame","cf","copyImage","ci","subimage","sl","use","$dca3c1826e5966d7$export$d89197afac86b993","api","buffer","clear","command","pipeline","verts","frag","frags","attributes","vert","replaceAll","count","positions","vs","fs","enable","update","onPass","onStep","stepMax","clearPass","mergeUpdate","stepProps","passProps","$2b0f5ebd78a3f030$var$isFinite","$2b0f5ebd78a3f030$export$2e2bcd8739ae039","maxDrawbuffers","apiGLSL","limits","version","parseFloat","match","$fb274f7b3d6bb589$export$2e2bcd8739ae039","states","form","self","gpgpu","macroPass","mapStep","toUniforms","getDrawIndexes","indexForms","$53e56069ca082632$var$canvas","document","querySelector","$53e56069ca082632$var$scroll","setTimeout","scrollIntoView","$53e56069ca082632$var$toggleError","classList","$53e56069ca082632$var$getQuery","search","location","URLSearchParams","$53e56069ca082632$var$query","$53e56069ca082632$var$fragDepth","get","$53e56069ca082632$var$extend","required","optional","$53e56069ca082632$var$pixelRatio","devicePixelRatio","$53e56069ca082632$var$regl","regl","$9acea99a8bf860b0$exports","extensions","optionalExtensions","onDone","group","log","hasExtension","groupEnd","$53e56069ca082632$var$valuesMap","Map","$53e56069ca082632$var$values","$53e56069ca082632$var$valuesIndex","k","maxTextureUnits","$53e56069ca082632$var$maxTextureUnits","maxTextureSize","$53e56069ca082632$var$maxTextureSize","lineWidthDims","$53e56069ca082632$var$lineWidthDims","pointSizeDims","$53e56069ca082632$var$pointSizeDims","$53e56069ca082632$var$useMerge","$53e56069ca082632$var$merge","$53e56069ca082632$var$limits","log2","$53e56069ca082632$var$niceScale","$53e56069ca082632$var$scale","$53e56069ca082632$var$steps","$53e56069ca082632$var$stepsPast","$53e56069ca082632$var$canVerlet","$53e56069ca082632$var$form","$53e56069ca082632$var$wide","$53e56069ca082632$var$fizz","at","rate","curve","$53e56069ca082632$var$shakeSource","$53e56069ca082632$var$shakeSink","$53e56069ca082632$var$hues","getAll","$53e56069ca082632$var$timeQuery","$53e56069ca082632$var$timestep","$53e56069ca082632$var$setupLink","hash","has","href","q","delete","$53e56069ca082632$var$setQuery","$53e56069ca082632$var$derives","$53e56069ca082632$var$shake","shaken","idle","random","cos","sin","position","motion","life","$53e56069ca082632$var$state","every","macroVert","props","timer","dt0","dts","dt1","loop","source","shake","sink","lifetime","prop","useVerlet","epsilon","moveCap","spout","ss","u","invert","$53e56069ca082632$var$drawBound","$53e56069ca082632$var$drawSteps","$53e56069ca082632$var$useLines","$53e56069ca082632$var$drawCounts","$53e56069ca082632$var$viewScale","$53e56069ca082632$var$drawState","output","drawProps","projection","view","eye","target","up","counts","primitive","primitives","pace","texturesMax","$53e56069ca082632$var$drawPipeline","fizz","fizzMax","fizzRate","fizzCurve","hues","dp","pointSize","wide","lineWidth","cs","blend","func","dst","drawState","drawPipeline","$53e56069ca082632$var$draw","$53e56069ca082632$var$clearView","$53e56069ca082632$var$stopEvent","stopPropagation","preventDefault","$53e56069ca082632$var$hold","$53e56069ca082632$var$resize","innerWidth","innerHeight","frame","$53e56069ca082632$var$stepTime","addEventListener","spawned","held","button","clientX","clientY","pointerType","isPrimary","getBoundingClientRect","touch"],"version":3,"file":"index.6d6cc7c6.js.map"}