<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Module: macros</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Module: macros</h1>

    




<section>

<header>
    
        
            
        
    
</header>

<article>
    <div class="container-overview">
    
        
            <div class="description">GPGPU GLSL preprocessor macros for each part of the state.

Careful defining these, as each set of different macros will result in new
shaders and compilations, missing the cache here and in the rendering system.
So, as few unique macros as possible should be created for a given set of
inputs, for efficiency.</div>
        

        
            















<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line1">line 1</a>
    </li></ul></dd>
    

    

    

    
    <dt class="tag-todo">To Do:</dt>
    <dd class="tag-todo">
        <ul>
            <li>Redo examples, especially `macroTaps` and `macroPass`.</li>
        
            <li>Allow passes into or across textures; separate data and texture shapes.</li>
        
            <li>Make everything function-like macro taking variable names? Makes
    variable names explicit (e.g: `useSamples(samples)`, `useReads_0(reads)`,
    `tapStateBy(data, st, stepPast, 0)`, `tapState(data, st)`), but makes
    interconnections harder (e.g: `macroValues`, `macroOutput`, `macroTaps`);
    probably impossible without concatenation macro anyway, namespace is OK.</li>
        </ul>
    </dd>
    
</dl>




















        
    
    </div>

    

    

    

    

    

    

    
        <h3 class="subsection-title">Members</h3>

        
            
<h4 class="name" id=".cache"><span class="type-signature">(static, constant) </span>cache<span class="type-signature"></span></h4>




<div class="description">
    Simple cache for temporary or reusable objects.
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line31">line 31</a>
    </li></ul></dd>
    

    

    

    
</dl>






        
            
<h4 class="name" id=".cr"><span class="type-signature">(static, constant) </span>cr<span class="type-signature"></span></h4>




<div class="description">
    Escaped carriage return for easier reading.
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line27">line 27</a>
    </li></ul></dd>
    

    

    

    
</dl>






        
            
<h4 class="name" id=".getGLSL1ListArray"><span class="type-signature">(static, constant) </span>getGLSL1ListArray<span class="type-signature"></span></h4>




<div class="description">
    Generates an array declaration, as a GLSL 1 syntax string.
Lookup and meta macros are added for consistency with other versions.
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line191">line 191</a>
    </li></ul></dd>
    

    

    

    
</dl>





    <h5>Example</h5>
    
    <pre class="prettyprint"><code>getGLSL1ListArray('vec3', 'list', [[1, 0, 0], [0, 2, 0], [0, 0, 3]]);
    // =>
    'const int list_l = 3;'+cr+
    'vec3 list_0 = vec3(1, 0, 0);'+cr+
    'vec3 list_1 = vec3(0, 2, 0);'+cr+
    'vec3 list_2 = vec3(0, 0, 3);'+cr+
    'vec3 list[list_l];'+cr+
    'list[0] = list_0;'+cr+
    'list[1] = list_1;'+cr+
    'list[2] = list_2;\n'+
    '#define list_i(i) list[i]\n';</code></pre>



        
            
<h4 class="name" id=".getGLSL1ListLike"><span class="type-signature">(static, constant) </span>getGLSL1ListLike<span class="type-signature"></span></h4>




<div class="description">
    Generates an array-like declaration, as a GLSL 1 syntax string.
Workaround for lack of `const` arrays in GLSL < 3.
Adds a lookup macro function; slow here, but standard.
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line156">line 156</a>
    </li></ul></dd>
    

    

    

    
</dl>





    <h5>Example</h5>
    
    <pre class="prettyprint"><code>getGLSL1ListLike('float', 'list', [0, 1, 2], 'const'); // =>
    'const int list_l = 3;'+cr+
    'const int list_0 = float(0);'+cr+
    'const int list_1 = float(1);'+cr+
    'const int list_2 = float(2);\n'+
    '// Index macro `list_i` (e.g: `list_i(0)`) may be slow, `+
        'use name (e.g: `list_0`) if possible.\n'+
    '#define list_i(i) ((i == 2)? list_2 : ((i == 1)? list_1 : list_0))\n';</code></pre>



        
            
<h4 class="name" id=".getGLSL3List"><span class="type-signature">(static, constant) </span>getGLSL3List<span class="type-signature"></span></h4>




<div class="description">
    Generates an array declaration, as a GLSL 3 syntax string.
Lookup and meta macros are added for consistency with other versions.
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line218">line 218</a>
    </li></ul></dd>
    

    

    

    
</dl>





    <h5>Example</h5>
    
    <pre class="prettyprint"><code>getGLSL3List('int', 'list', [0, 1, 2], 'const'); // =>
    'const int list_l = 3;'+cr+
    'const int list_0 = int(0);'+cr+
    'const int list_1 = int(1);'+cr+
    'const int list_2 = int(2);'+cr+
    'const int list[list_l] = int[list_l](list_0, list_1, list_2);\n'+
    '#define list_i(i) list[i]\n';</code></pre>



        
            
<h4 class="name" id=".getGLSLList"><span class="type-signature">(static, constant) </span>getGLSLList<span class="type-signature"></span></h4>




<div class="description">
    Creates a GLSL definition of an array, and initialises it with the given
values, type, and variable name.
The initialisation is valid GLSL 1.0 or greater syntax; but is written with
escaped new-lines so it may be used in a single-line - e.g: for preprocessor
macros.
For a `qualify` of `const` on any `glsl` less than `3`, falls back to using
non-array variables with the index appended to `name`, since `const` arrays
aren't supported before GLSL 3.0.
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line268">line 268</a>
    </li></ul></dd>
    

    

    

    
</dl>





    <h5>Example</h5>
    
    <pre class="prettyprint"><code>getGLSLList('int', 'test', [0, 1]); // =>
    'const int test_l = 2;'+cr+
    'int test_0 = int(0);'+cr+
    'int test_1 = int(1);'+cr+
    'int test[test_l];'+cr+
    'test[0] = test_0;'+cr+
    'test[1] = test_1;\n'+
    '#define test_i(i) test[i]\n';

    getGLSLList('ivec2', 'vecs', [[1, 0], [0, 1]], 'const', 3); // =>
    'const int vecs_l = 2;'+cr+
    'ivec2 vecs_0 = ivec2(1, 0);'+cr+
    'ivec2 vecs_1 = ivec2(0, 1);'+cr+
    'const ivec2 vecs[vecs_l] = ivec2[vecs_l](vecs_0, vecs_1);\n'+
    '#define vecs_i(i) vecs[i]\n';

    getGLSLList('int', 'listLike', [0, 1], 'const', 1); // =>
    'const int listLike_l = 2;'+cr+
    'const int listLike_0 = int(0);'+cr+
    'const int listLike_1 = int(1);\n'+
    '// Index macro `listLike_i` (e.g: `listLike_i(0)`) may be slow, `+
        'use name (e.g: `listLike_0`) if possible.\n'+
    '#define listLike_i(i) ((i == 1)? listLike_1 : listLike_0)\n';</code></pre>



        
            
<h4 class="name" id=".getGLSLListBase"><span class="type-signature">(static, constant) </span>getGLSLListBase<span class="type-signature"></span></h4>




<div class="description">
    Generates an array-like declaration, as a GLSL syntax string compatible with
all versions.
Workaround for lack of `const` arrays in GLSL < 3.
Used as the base for the other GLSL version list types, ensuring a standard
basis while offering further language features where available.
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line126">line 126</a>
    </li></ul></dd>
    

    

    

    
</dl>





    <h5>Example</h5>
    
    <pre class="prettyprint"><code>getGLSLListBase('float', 'list', [0, 1, 2], 'const'); // =>
    'const int list_l = 3;'+cr+
    'const int list_0 = float(0);'+cr+
    'const int list_1 = float(1);'+cr+
    'const int list_2 = float(2);';</code></pre>



        
            
<h4 class="name" id=".id"><span class="type-signature">(static, constant) </span>id<span class="type-signature"></span></h4>




<div class="description">
    Get cache keys without having to create new objects for `stringify`.
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line33">line 33</a>
    </li></ul></dd>
    

    

    

    
</dl>






        
            
<h4 class="name" id=".macroPass"><span class="type-signature">(static, constant) </span>macroPass<span class="type-signature"></span></h4>




<div class="description">
    Defines all GLSL preprocessor macro values, texture samples, and outputs for
the active pass.
The macros define the mapping between the active values, their textures and
channels, bound outputs, and other macros useful for a draw pass.
Caches the result if `macros` generation is enabled, to help reuse shaders.
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line1045">line 1045</a>
    </li></ul></dd>
    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li>hasMacros</li>
        
            <li>macroValues</li>
        
            <li>macroOutput</li>
        
            <li>macroTaps</li>
        
            <li>macroSamples</li>
        
            <li>mapFlow</li>
        
            <li>getState</li>
        </ul>
    </dd>
    

    
</dl>





    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const values = [2, 4, 1];
    const derives = [2, , [[1, 0], true]];

    // Automatically packed values - values across fewer textures/passes.
    // Only a single texture output per pass - values across more passes.
    const state = {
        passNow: 0, steps: 2, size: { count: 2**5 },
        maps: mapFlow({ values, derives, channelsMax: 4, buffersMax: 1 })
    };

    macroPass(state); // =>
    '#define gpgpu_texture_1 0\n'+
    '#define gpgpu_channels_1 rgba\n'+
    '\n'+
    '#define gpgpu_texture_0 1\n'+
    '#define gpgpu_channels_0 rg\n'+
    '\n'+
    '#define gpgpu_texture_2 1\n'+
    '#define gpgpu_channels_2 b\n'+
    '\n'+
    '#define count 32\n'+
    '#define gpgpu_textures 2\n'+
    '#define gpgpu_passes 2\n'+
    '#define gpgpu_stepsPast 1\n'+
    '#define gpgpu_steps 2\n'+
    '\n'+
    '#define gpgpu_passNow 0\n'+
    '\n'+
    '#define gpgpu_bound_1 0\n'+
    '#define gpgpu_attach_1 0\n'+
    '#define gpgpu_output_1 gl_FragData[gpgpu_attach_1].rgba\n'+
    '\n';

    // Next pass and extra step.
    ++state.steps;
    ++state.passNow;
    state.pre = '';
    macroPass(state); // =>
    '#define texture_1 0\n'+
    '#define channels_1 rgba\n'+
    '\n'+
    '#define texture_0 1\n'+
    '#define channels_0 rg\n'+
    '\n'+
    '#define texture_2 1\n'+
    '#define channels_2 b\n'+
    '\n'+
    '#define count 32\n'+
    '#define textures 2\n'+
    '#define passes 2\n'+
    '#define stepsPast 2\n'+
    '#define steps 3\n'+
    '\n'+
    '#define passNow 1\n'+
    '\n'+
    '#define bound_0 1\n'+
    '#define attach_0 0\n'+
    '#define output_0 gl_FragData[attach_0].rg\n'+
    '\n'+
    '#define bound_2 1\n'+
    '#define attach_2 0\n'+
    '#define output_2 gl_FragData[attach_2].b\n'+
    '\n'+
    '#define useSamples'+cr+
        'const int samples_l = 3;'+cr+
        'const ivec2 samples_0 = ivec2(0, 1);'+cr+
        'const ivec2 samples_1 = ivec2(1, 1);'+cr+
        'const ivec2 samples_2 = ivec2(0, 0);\n'+
    '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+
        'use name (e.g: `samples_0`) if possible.\n'+
    '#define samples_i(i)'+cr+
        '((i == 2)? samples_2 : ((i == 1)? samples_1 : samples_0))\n'+
    '\n'+
    '#define useReads_0'+cr+
        'const int reads_0_l = 1;'+cr+
        'const int reads_0_0 = int(0);\n'+
    '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+
        'use name (e.g: `reads_0_0`) if possible.\n'+
    '#define reads_0_i(i) reads_0_0\n'+
    '\n'+
    '#define useReads_2'+cr+
        'const int reads_2_l = 4;'+cr+
        'const int reads_2_0 = int(1);'+cr+
        'const int reads_2_1 = int(0);'+cr+
        'const int reads_2_2 = int(2);'+cr+
        'const int reads_2_3 = int(0);\n'+
    '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+
        'use name (e.g: `reads_2_0`) if possible.\n'+
    '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+
        ': ((i == 1)? reads_2_1 : reads_2_0)))\n'+
    '\n'+
    '// States in a `sampler2D[]`; looks up 1D index and 2D `uv`.\n'+
    '@todo';</code></pre>



        
            
<h4 class="name" id=".rgba"><span class="type-signature">(static, constant) </span>rgba<span class="type-signature"></span></h4>




<div class="description">
    The channels denoted for texture input/output.
</div>







<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line29">line 29</a>
    </li></ul></dd>
    

    

    

    
</dl>






        
    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    
    <h4 class="name" id=".default"><span class="type-signature">(static) </span>default<span class="signature">()</span><span class="type-signature"></span></h4>
    

    















<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line1055">line 1055</a>
    </li></ul></dd>
    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li><a href="module-macros.html#.macroPass">module:macros.macroPass</a></li>
        </ul>
    </dd>
    

    
</dl>




















        
            

    

    
    <h4 class="name" id=".hasMacros"><span class="type-signature">(static) </span>hasMacros<span class="signature">(props<span class="signature-attributes">opt</span>, key<span class="signature-attributes">opt</span>, on<span class="signature-attributes">opt</span>, macros<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {string|null|*}</span></h4>
    

    



<div class="description">
    Whether macros should be handled here; or the result of handling them by a
given named hook.
Allows macros of the given key to be handled by external named hooks, to
replace any part of the functionality here.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>props</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">The properties handling macros.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>key</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">The name for which macros should be handled.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>on</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    ''
                
                </td>
            

            <td class="description last">Any further macro `hooks` specifier; if given, both
    the hook key and this specifier are checked (e.g: `key` and `key_on`).</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>macros</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>
|

<span class="param-type">function</span>
|

<span class="param-type">object</span>
|

<span class="param-type">false</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    props.macros
                
                </td>
            

            <td class="description last">Whether and how
    GLSL preprocessor macros should be handled:
    - If it's false-y and non-nullish, no macros are handled here.
    - If it's a string, no macros are handled here as it's used instead.
    - If it's a function, it's passed the given `props`, `key`, `macros`, and
        the returned result is used.
    - If it's an object, any value at the given `key` is entered recursively,
        with the given `props`, `key`, and `macros[key]`.
    - Otherwise, returns `null` to indicate macros should be handled here.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line90">line 90</a>
    </li></ul></dd>
    

    

    

    
</dl>















<h5>Returns:</h5>

        
<div class="param-desc">
    Either the result of the macros handled elsewhere,
    or `null` if macros should be handled here.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>
|

<span class="param-type">null</span>
|

<span class="param-type">*</span>


    </dd>
</dl>

    




    <h5>Example</h5>
    
    <pre class="prettyprint"><code>// Macros to be handled here, the default.
    [hasMacros(), hasMacros({}), hasMacros({ macros: true })]]
        .every((m) => m === null);

    // Macros to be handled here, with prefix `'pre_'` instead of `'preDef'`.
    hasMacros({ pre: 'pre_' }) === null;

    // Macros not created.
    [hasMacros({ macros: false }), hasMacros({ macros: 0 })]
        .every((m) => m === '');

    // Macros for 'a' handled by external static hook, not here.
    hasMacros({ macros: { a: '//A\n', b: () => '//B\n' } }, 'a') === '//A\n';
    // Macros for 'b' handled by external function hook, not here.
    hasMacros({ macros: { a: '//A\n', b: () => '//B\n' } }, 'b') === '//B\n';
    // Macros specified `on` a 'frag' not created.
    hasMacros({ macros: { frag: 0 } }, '', 'frag') === '';
    // Macros specified `on` a 'vert' handled here.
    hasMacros({ macros: { frag: 0, a_vert: 0 } }, '', 'vert') === null;
    // Macros for hook `'a'` specified `on` a 'vert' not created.
    hasMacros({ macros: { frag: 0, a_vert: 0 } }, 'a', 'vert') === '';</code></pre>



        
            

    

    
    <h4 class="name" id=".macroOutput"><span class="type-signature">(static) </span>macroOutput<span class="signature">(state, on<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {string}</span></h4>
    

    



<div class="description">
    Defines the outputs being drawn to per-pass, as GLSL preprocessor macros.
These macros define mappings from values to their outputs, if bound.
Caches the result if `macros` generation is enabled, to help reuse shaders.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>state</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">Properties for generating the macros. See `getState`:</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>on</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">Any further macro `hooks` specifier; if given, both
    the hook key and this specifier are checked (e.g: `key` and `key_on`).</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.macros</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>
|

<span class="param-type">function</span>
|

<span class="param-type">object</span>
|

<span class="param-type">false</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">How macros are handled.
    See `hasMacros`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.pre</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    preDef
                
                </td>
            

            <td class="description last">Macros prefix; `pre` if not given.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.passNow</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">The index of the currently active pass.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.maps</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">How values are grouped per-texture per-pass
    per-step. See `mapGroups`.
                <h6>Properties</h6>
                

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>values</code></td>
            

            <td class="type">
            
                
<span class="param-type">array.&lt;number></span>


            
            </td>

            

            

            <td class="description last">How values of each data item may be
    grouped into textures across passes. See `mapGroups`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>textures</code></td>
            

            <td class="type">
            
                
<span class="param-type">array.&lt;array.&lt;number>></span>


            
            </td>

            

            

            <td class="description last">The groupings of values
    into textures. See `mapGroups`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>passes</code></td>
            

            <td class="type">
            
                
<span class="param-type">array.&lt;array.&lt;number>></span>


            
            </td>

            

            

            <td class="description last">The groupings of textures
    into passes. See `mapGroups`.</td>
        </tr>

    
    </tbody>
</table>

            </td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line485">line 485</a>
    </li></ul></dd>
    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li>hasMacros</li>
        
            <li>mapGroups</li>
        
            <li>getState</li>
        </ul>
    </dd>
    

    
</dl>















<h5>Returns:</h5>

        
<div class="param-desc">
    The GLSL preprocessor macros for the pass's bound outputs.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>


    </dd>
</dl>

    




    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const maps = { values: [2, 4, 1], channelsMax: 4 };

    // No optimisations - values not packed, single texture output per pass.
    const state = {
         pre: '', passNow: 0,
         maps: mapGroups({ ...maps, buffersMax: 1, packed: 0 })
    };

    macroOutput(state); // =>
    '#define passNow 0\n'+
    '\n'+
    '#define bound_0 0\n'+
    '#define attach_0 0\n'+
    '#define output_0 gl_FragData[attach_0].rg\n'+
    '\n';

    // Automatically packed values - values across fewer textures/passes.
    state.maps = mapGroups({ ...maps, buffersMax: 1 });
    macroOutput(state); // =>
    '#define passNow 0\n'+
    '\n'+
    '#define bound_1 0\n'+
    '#define attach_1 0\n'+
    '#define output_1 gl_FragData[attach_1].rgba\n'+
    '\n';

    // Next pass in this step.
    ++state.passNow;
    macroOutput(state); // =>
    '#define passNow 1\n'+
    '\n'+
    '#define bound_0 1\n'+
    '#define attach_0 0\n'+
    '#define output_0 gl_FragData[attach_0].rg\n'+
    '\n'+
    '#define bound_2 1\n'+
    '#define attach_2 0\n'+
    '#define output_2 gl_FragData[attach_2].b\n'+
    '\n';

    // Can bind more texture outputs per pass - values across fewer passes.
    state.maps = mapGroups({ ...maps, buffersMax: 4 });
    state.passNow = 0;
    macroOutput(state); // =>
    '#define passNow 0\n'+
    '\n'+
    '#define bound_1 0\n'+
    '#define attach_1 0\n'+
    '#define output_1 gl_FragData[attach_1].rgba\n'+
    '\n'+
    '#define bound_0 1\n'+
    '#define attach_0 1\n'+
    '#define output_0 gl_FragData[attach_0].rg\n'+
    '\n'+
    '#define bound_2 1\n'+
    '#define attach_2 1\n'+
    '#define output_2 gl_FragData[attach_2].b\n'+
    '\n';</code></pre>



        
            

    

    
    <h4 class="name" id=".macroSamples"><span class="type-signature">(static) </span>macroSamples<span class="signature">(state, on<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {string}</span></h4>
    

    



<div class="description">
    Defines the texture samples/reads per-pass, as GLSL preprocessor macros.
The macros define the mapping between the values and those they derive from,
as step/texture locations in a `samples` list, and indexes to read values
from sampled data in a `reads` list (once sampled into a `data` list, as in
`macroTaps` or similar).
They're set up as function-like macros that may be called from the shader to
initialise the mappings arrays with a given name.
Caches the result if `macros` generation is enabled, to help reuse shaders.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>state</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">Properties used to generate the macros. See `getState`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>on</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">Any further macro `hooks` specifier; if given, both
    the hook key and this specifier are checked (e.g: `key` and `key_on`).</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.macros</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>
|

<span class="param-type">function</span>
|

<span class="param-type">object</span>
|

<span class="param-type">false</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">How macros are handled.
    See `hasMacros`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.pre</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    preDef
                
                </td>
            

            <td class="description last">Macros prefix; `preDef` if not given.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.passNow</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    0
                
                </td>
            

            <td class="description last">The index of the currently active pass;
    uses the first pass if not given.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.maps</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">How `values` are grouped per-texture per-pass
    per-step. See `mapGroups`.
                <h6>Properties</h6>
                

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>samples</code></td>
            

            <td class="type">
            
                
<span class="param-type">array.&lt;array.&lt;array.&lt;number>>></span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">The minimal set of
    texture samples to use. See `mapSamples`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reads</code></td>
            

            <td class="type">
            
                
<span class="param-type">array.&lt;array.&lt;array.&lt;number>>></span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">The mappings from
    values to the corresponding `state.samples`. See `mapSamples`.</td>
        </tr>

    
    </tbody>
</table>

            </td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.glsl</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    1
                
                </td>
            

            <td class="description last">The GLSL language version. See `getGLSLList`.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line634">line 634</a>
    </li></ul></dd>
    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li>macroTaps</li>
        
            <li>hasMacros</li>
        
            <li>getGLSLList</li>
        
            <li>mapFlow</li>
        
            <li>getState</li>
        </ul>
    </dd>
    

    
</dl>















<h5>Returns:</h5>

        
<div class="param-desc">
    The GLSL preprocessor macros defining the mappings for
    samples and reads, for each value.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>


    </dd>
</dl>

    




    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const values = [2, 4, 1];
    const derives = [2, , [[1, 0], true]];
    const maps = { values, derives, channelsMax: 4 };

    // No optimisations - values not packed, single texture output per pass.
    const state =
        { pre: '', maps: mapFlow({ ...maps, buffersMax: 1, packed: 0 }) };

    // USes the first pass by default.
    macroSamples(state); // =>
    '#define useSamples'+cr+
        'const int samples_l = 1;'+cr+
        'const ivec2 samples_0 = ivec2(0, 2);\n'+
    '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+
        'use name (e.g: `samples_0`) if possible.\n'+
    '#define samples_i(i) samples_0\n'+
    '\n'+
    '#define useReads_0'+cr+
        'const int reads_0_l = 1;'+cr+
        'const int reads_0_0 = int(0);\n'+
    '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+
        'use name (e.g: `reads_0_0`) if possible.\n'+
    '#define reads_0_i(i) reads_0_0\n'+
    '\n';

    // Next pass in this step - no derives, no samples nor reads.
    state.passNow = 1;
    macroSamples(state); // =>
    '';

    // Next pass in this step.
    ++state.passNow;
    macroSamples(state); // =>
    '#define useSamples'+cr+
        'const int samples_l = 4;'+cr+
        'const ivec2 samples_0 = ivec2(1, 0);'+cr+
        'const ivec2 samples_1 = ivec2(0, 0);'+cr+
        'const ivec2 samples_2 = ivec2(0, 1);'+cr+
        'const ivec2 samples_3 = ivec2(0, 2);\n'+
    '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+
        'use name (e.g: `samples_0`) if possible.\n'+
    '#define samples_i(i) ((i == 3)? samples_3 : ((i == 2)? samples_2 '+
        ': ((i == 1)? samples_1 : samples_0)))\n'+
    '\n'+
    '#define useReads_2'+cr+
        'const int reads_2_l = 4;'+cr+
        'const int reads_2_0 = int(0);'+cr+
        'const int reads_2_1 = int(1);'+cr+
        'const int reads_2_2 = int(2);'+cr+
        'const int reads_2_3 = int(3);\n'+
    '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+
        'use name (e.g: `reads_2_0`) if possible.\n'+
    '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+
        ': ((i == 1)? reads_2_1 : reads_2_0)))\n'+
    '\n';

    // Automatically packed values - values across fewer textures/passes.
    // Can bind more texture outputs per pass - values across fewer passes.
    // Also fewer samples where values share derives or textures.
    state.maps = mapGroups({ ...maps, buffersMax: 4 });
    state.passNow = 0;
    macroSamples(state); // =>
    '#define useSamples'+cr+
        'const int samples_l = 3;'+cr+
        'const ivec2 samples_0 = ivec2(0, 1);'+cr+
        'const ivec2 samples_1 = ivec2(1, 1);'+cr+
        'const ivec2 samples_2 = ivec2(0, 0);\n'+
    '// Index macro `samples_i` (e.g: `samples_i(0)`) may be slow, '+
        'use name (e.g: `samples_0`) if possible.\n'+
    '#define samples_i(i) '+
        '((i == 2)? samples_2 : ((i == 1)? samples_1 : samples_0))\n'+
    '\n'+
    '#define useReads_0'+cr+
        'const int reads_0_l = 1;'+cr+
        'const int reads_0_0 = int(0);\n'+
    '// Index macro `reads_0_i` (e.g: `reads_0_i(0)`) may be slow, '+
        'use name (e.g: `reads_0_0`) if possible.\n'+
    '#define reads_0_i(i) reads_0_0\n'+
    '\n'+
    '#define useReads_2'+cr+
        'const int reads_2_l = 4;'+cr+
        'const int reads_2_0 = int(1);'+cr+
        'const int reads_2_1 = int(0);'+cr+
        'const int reads_2_2 = int(2);'+cr+
        'const int reads_2_3 = int(0);\n'+
    '// Index macro `reads_2_i` (e.g: `reads_2_i(0)`) may be slow, '+
        'use name (e.g: `reads_2_0`) if possible.\n'+
    '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+
        ': ((i == 1)? reads_2_1 : reads_2_0)))\n'+
    '\n';</code></pre>



        
            

    

    
    <h4 class="name" id=".macroTaps"><span class="type-signature">(static) </span>macroTaps<span class="signature">(state, on<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {string}</span></h4>
    

    



<div class="description">
    Defines the samples of textures per-pass, as GLSL preprocessor macros.
The macros define the minimal sampling of textures for the data the active
pass's values derive from; creates a `data` list containing the samples; the
`samples` list names are required, as created by `macroSamples` or similar.
Handles sampling states in a flat array of textures, or merged in one texture
(in both `sampler2D`, and `sampler3D`/`sampler2DArray` where supported).
Merging allows shaders to access past steps by non-constant lookups; e.g:
attributes cause "sampler array index must be a literal expression" on GLSL3
spec and some platforms (e.g: D3D); note these need texture repeat wrapping.
They're set up as function-like macros that may be called from the shader to
initialise the mappings arrays with a given name.
Caches the result if `macros` generation is enabled, to help reuse shaders.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>state</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">Properties used to generate the macros. See `getState`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>on</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">Any further macro `hooks` specifier; if given, both
    the hook key and this specifier are checked (e.g: `key` and `key_on`).</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.macros</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>
|

<span class="param-type">function</span>
|

<span class="param-type">object</span>
|

<span class="param-type">false</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">How macros are handled.
    See `hasMacros`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.pre</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    preDef
                
                </td>
            

            <td class="description last">Macros prefix; `preDef` if not given.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.passNow</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    0
                
                </td>
            

            <td class="description last">The index of the currently active pass;
    uses the first pass if not given.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.maps</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">How `values` are grouped per-texture per-pass
    per-step. See `mapGroups`.
                <h6>Properties</h6>
                

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>samples</code></td>
            

            <td class="type">
            
                
<span class="param-type">array.&lt;array.&lt;array.&lt;number>>></span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">The minimal set of
    texture samples to use. See `mapSamples`.</td>
        </tr>

    
    </tbody>
</table>

            </td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.merge</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">Any merged state texture; uses separate state
    textures if not given. See `getState`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.glsl</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    1
                
                </td>
            

            <td class="description last">The GLSL language version. See `getGLSLList`.</td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line741">line 741</a>
    </li></ul></dd>
    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li><a href="https://stackoverflow.com/a/60110986/716898">https://stackoverflow.com/a/60110986/716898</a></li>
        
            <li><a href="https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_2d_array.html">https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_2d_array.html</a></li>
        
            <li><a href="https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_3d.html">https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_3d.html</a></li>
        
            <li>macroSamples</li>
        
            <li>hasMacros</li>
        
            <li>getGLSLList</li>
        
            <li>mapFlow</li>
        
            <li>getState</li>
        
            <li>getUniforms</li>
        </ul>
    </dd>
    

    
    <dt class="tag-todo">To Do:</dt>
    <dd class="tag-todo">
        <ul>
            <li>Combine texture steps into one map would work around it, avoiding
    sampler arrays entirely; maybe usage-specific/heavy; could have 1
    framebuffer, copy pixels into its offset in 1 big past states texture
    (merge the current sampler array); analogous to GLSL3
    `sampler3D`/`sampler2DArray`.</li>
        </ul>
    </dd>
    
</dl>















<h5>Returns:</h5>

        
<div class="param-desc">
    The GLSL preprocessor macros defining the minimal sampling
    of textures, to suit how states are stored (flat array of textures, or
    all merged into one texture) and supported GLSL language features.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>


    </dd>
</dl>

    




    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const values = [2, 4, 1];
    const derives = [2, , [[1, 0], true]];
    const maps = { values, derives, channelsMax: 4 };

    // No optimisations - values not packed, single texture output per pass.
    const state =
        { pre: '', maps: mapFlow({ ...maps, buffersMax: 1, packed: 0 }) };

    // Uses the first pass by default.
    macroTaps(state); // =>
    '@todo';

    // Next pass in this step - no derives, no samples nor reads.
    state.passNow = 1;
    macroTaps(state); // =>
    '';

    // Next pass in this step.
    ++state.passNow;
    macroTaps(state); // =>
    '@todo';

    // Automatically packed values - values across fewer textures/passes.
    // Can bind more texture outputs per pass - values across fewer passes.
    // Also fewer samples where values share derives or textures.
    state.maps = mapGroups({ ...maps, buffersMax: 4 });
    state.passNow = 0;
    macroTaps(state); // =>
    '@todo';</code></pre>



        
            

    

    
    <h4 class="name" id=".macroValues"><span class="type-signature">(static) </span>macroValues<span class="signature">(state, on<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {string}</span></h4>
    

    



<div class="description">
    Defines the values within textures per-step, as GLSL preprocessor macros.
These macros define mappings from values to their textures and channels.
Caches the result if `macros` generation is enabled, to help reuse shaders.
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>state</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">Properties used to generate the macros. See `getState`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>on</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">Any further macro `hooks` specifier; if given, both
    the hook key and this specifier are checked (e.g: `key` and `key_on`).</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.macros</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>
|

<span class="param-type">function</span>
|

<span class="param-type">object</span>
|

<span class="param-type">false</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">How macros are handled
    or prefixed. See `hasMacros`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.pre</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    preDef
                
                </td>
            

            <td class="description last">Macros prefix; `preDef` if not given.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.maps</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">How values are grouped per-texture per-pass
    per-step.
                <h6>Properties</h6>
                

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>values</code></td>
            

            <td class="type">
            
                
<span class="param-type">array.&lt;number></span>


            
            </td>

            

            

            <td class="description last">How values of each data item are
    grouped into textures. See `mapGroups`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>textures</code></td>
            

            <td class="type">
            
                
<span class="param-type">array.&lt;array.&lt;number>></span>


            
            </td>

            

            

            <td class="description last">The groupings of values
    into textures. See `mapGroups`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>passes</code></td>
            

            <td class="type">
            
                
<span class="param-type">array</span>


            
            </td>

            

            

            <td class="description last">Passes drawn per-step. See `mapGroups`.</td>
        </tr>

    
    </tbody>
</table>

            </td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.steps</code></td>
            

            <td class="type">
            
                
<span class="param-type">array</span>
|

<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">States drawn across frames. See `getState`.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.bound</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    boundDef
                
                </td>
            

            <td class="description last">How many steps are bound as outputs,
    unavailable as inputs.</td>
        </tr>

    

        <tr>
            
                <td class="name"><code>state.size</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last">Any size information about the GL resources.
                <h6>Properties</h6>
                

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>count</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last">The number of data entries per texture
    (the texture's area), if given. See `getState`.</td>
        </tr>

    
    </tbody>
</table>

            </td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="macros.js.html">macros.js</a>, <a href="macros.js.html#line369">line 369</a>
    </li></ul></dd>
    

    

    
    <dt class="tag-see">See:</dt>
    <dd class="tag-see">
        <ul>
            <li>hasMacros</li>
        
            <li>mapGroups</li>
        
            <li>getState</li>
        </ul>
    </dd>
    

    
</dl>















<h5>Returns:</h5>

        
<div class="param-desc">
    The GLSL preprocessor macros defining the mappings from
    values to textures/channels.
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">string</span>


    </dd>
</dl>

    




    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const maps = { values: [2, 4, 1], channelsMax: 4 };

    // No optimisations - values not packed, single texture output per pass.
    const state = {
         pre: '', steps: 2,
         maps: mapGroups({ ...maps, buffersMax: 1, packed: 0 })
    };

    macroValues(state); // =>
    '#define texture_0 0\n'+
    '#define channels_0 rg\n'+
    '\n'+
    '#define texture_1 1\n'+
    '#define channels_1 rgba\n'+
    '\n'+
    '#define texture_2 2\n'+
    '#define channels_2 r\n'+
    '\n'+
    '#define textures 3\n'+
    '#define passes 3\n'+
    '#define stepsPast 1\n'+
    '#define steps 2\n'+
    '\n';

    // Automatically packed values - values across fewer textures/passes.
    state.maps = mapGroups({ ...maps, buffersMax: 1 });
    state.size = { count: 2**5 };
    macroValues(state); // =>
    '#define texture_1 0\n'+
    '#define channels_1 rgba\n'+
    '\n'+
    '#define texture_0 1\n'+
    '#define channels_0 rg\n'+
    '\n'+
    '#define texture_2 1\n'+
    '#define channels_2 b\n'+
    '\n'+
    '#define count 32\n'+
    '#define textures 2\n'+
    '#define passes 2\n'+
    '#define stepsPast 1\n'+
    '#define steps 2\n'+
    '\n';

    // Can bind more texture outputs per pass - values across fewer passes.
    state.maps = mapGroups({ ...maps, buffersMax: 4 });
    macroValues(state); // =>
    '#define texture_1 0\n'+
    '#define channels_1 rgba\n'+
    '\n'+
    '#define texture_0 1\n'+
    '#define channels_0 rg\n'+
    '\n'+
    '#define texture_2 1\n'+
    '#define channels_2 b\n'+
    '\n'+
    '#define count 32\n'+
    '#define textures 2\n'+
    '#define passes 1\n'+
    '#define stepsPast 1\n'+
    '#define steps 2\n'+
    '\n';</code></pre>



        
    

    

    
</article>

</section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-const.html">const</a></li><li><a href="module-gl-gpgpu.html">gl-gpgpu</a></li><li><a href="module-index-forms.html">index-forms</a></li><li><a href="module-index-forms_index-entries.html">index-forms/index-entries</a></li><li><a href="module-index-forms_index-states.html">index-forms/index-states</a></li><li><a href="module-inputs.html">inputs</a></li><li><a href="module-lookup_index-uv.html">lookup/index-uv</a></li><li><a href="module-lookup_offset-uv.html">lookup/offset-uv</a></li><li><a href="module-macros.html">macros</a></li><li><a href="module-maps.html">maps</a></li><li><a href="module-size.html">size</a></li><li><a href="module-state.html">state</a></li><li><a href="module-step.html">step</a></li><li><a href="module-util_remain-div.html">util/remain-div</a></li><li><a href="module-vert.html">vert</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Wed Feb 23 2022 01:15:32 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>