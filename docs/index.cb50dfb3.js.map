{"mappings":"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","sources":["demo/particles/index.js","node_modules/@swc/helpers/src/_define_property.js","node_modules/@swc/helpers/src/_object_spread.js","node_modules/@swc/helpers/src/_sliced_to_array.js","node_modules/@swc/helpers/src/_array_with_holes.js","node_modules/@swc/helpers/src/_iterable_to_array.js","node_modules/@swc/helpers/src/_non_iterable_rest.js","node_modules/@swc/helpers/src/_to_consumable_array.js","node_modules/@swc/helpers/src/_array_without_holes.js","node_modules/@swc/helpers/src/_non_iterable_spread.js","node_modules/clamp/index.js","node_modules/@epok.tech/fn-time/dist/es/index.js","node_modules/@epok.tech/fn-lists/reduce.js","node_modules/@epok.tech/fn-lists/map.js","index.js","maps.js","node_modules/@epok.tech/fn-lists/each.js","const.js","node_modules/@epok.tech/gl-screen-triangle/index.js","node_modules/@epok.tech/gl-screen-triangle/uv-texture.vert.glsl","state.js","node_modules/@epok.tech/fn-lists/range.js","step.js","node_modules/@epok.tech/fn-lists/wrap-index.js","macros.js","node_modules/@epok.tech/is-type/type.js","inputs.js","node_modules/@thi.ng/vectors/setc.js","index-pairs/index.js","demo/particles/step.frag.glsl","demo/particles/draw.vert.glsl","demo/particles/draw.frag.glsl"],"sourcesContent":["/**\n * Demo implementation of 3D particle Verlet/Euler integration simulation.\n */\n\nimport getRegl from 'regl';\nimport clamp from 'clamp';\nimport timer from '@epok.tech/fn-time';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\n\nimport { gpgpu, extensionsFloat, optionalExtensions } from '../../index';\nimport { macroPass } from '../../macros';\nimport { getMaps } from '../../maps';\nimport { getUniforms, countDrawIndexes, getDrawIndexes } from '../../inputs';\nimport indexPairs from '../../index-pairs';\n\nimport stepFrag from './step.frag.glsl';\nimport drawVert from './draw.vert.glsl';\nimport drawFrag from './draw.frag.glsl';\n\nconst reglProps = {\n    pixelRatio: Math.max(Math.floor(devicePixelRatio), 1.5),\n    extensions: extensionsFloat(), optionalExtensions: optionalExtensions()\n};\n\nconst regl = self.regl = getRegl(reglProps);\n\nconsole.log('extensions',\n    reduce((o, e) => o+((o)? '; ' : '')+e+': '+regl.hasExtension(e),\n        reglProps.extensions, ''));\n\nconsole.log('optionalExtensions',\n    reduce((o, e) => o+((o)? '; ' : '')+e+': '+regl.hasExtension(e),\n        reglProps.optionalExtensions, ''));\n\nconst canvas = document.querySelector('canvas');\n\ncanvas.classList.add('view');\n\n// How many frame-buffers are bound at a given time.\nconst bound = 1;\n\n// How many values/channels each property independently tracks.\n// The order here corresponds to the order in the shaders and generated macros.\n\nconst valuesMap = (new Map())\n    .set('position', 3).set('life', 1).set('acceleration', 3);\n\nconst values = [...valuesMap.values()];\n\n// Limits of this device and these `values`.\nconst { maxTextureUnits, maxTextureSize } = regl.limits;\n\nconst limits = {\n    steps: [\n        1+bound,\n        Math.floor(maxTextureUnits*4/reduce((s, v) => s+v, values, 0))\n    ],\n    // Better stay farther under maximum texture size, or errors/crashes.\n    scale: [1, Math.log2(maxTextureSize)]\n};\n\nconsole.log('limits', limits, regl.limits);\n\n// Handle query parameters.\nconst query = new URLSearchParams(location.search);\n\n// 1 active state, as many others as can be bound; at least 2 past states needed\n// for Verlet integration, 1 for Euler integration.\nconst steps = Math.floor(clamp((parseInt(query.get('steps'), 10) || 2+bound),\n    ...limits.steps));\n\nconst stepsPast = steps-bound;\n\nconst scale = Math.floor(clamp((parseInt(query.get('scale'), 10) || 8),\n    ...limits.scale));\n\n// Fixed time-step if given; otherwise uses look-behind delta-time.\nconst hasTimestep = query.has('timestep');\nconst timestepDef = 1e3/60;\n\nconst timestep = (hasTimestep &&\n    (parseFloat(query.get('timestep'), 10) || timestepDef));\n\nconsole.log(location.search+':\\n', ...([...query.entries()].flat()), '\\n',\n    'steps:', steps, 'scale:', scale, 'timestep:', timestep);\n\n// Set up the links.\n\ndocument.querySelector('#points').href = `?steps=2&scale=${\n    Math.max(limits.scale[1]-5, 9)}${\n    ((hasTimestep)? '&timestep='+query.get('timestep') : '')}#points`;\n\ndocument.querySelector('#max').href = `?steps=${Math.max(limits.steps[1]-3, 1)\n    }&scale=${Math.max(limits.scale[1]-5, 9)}${\n    ((hasTimestep)? '&timestep='+query.get('timestep') : '')}#max`;\n\n// Override `query` here for convenience - not reused later.\n((timestep)? query.delete('timestep') : query.set('timestep', timestepDef));\ndocument.querySelector('#time').href = `?${query}#time`;\n\n// How values/channels map to their derivations.\n\nconst valuesIndex = reduce((o, k, i) => { o[k] = i; return o; },\n    [...valuesMap.keys()], {});\n\nconst derives = [];\n\nderives[valuesIndex.position] = [\n    // Position, 2 steps past.\n    [Math.min(1, stepsPast-1), valuesIndex.position],\n    // Position, 1 step past.\n    valuesIndex.position,\n    valuesIndex.acceleration,\n    valuesIndex.life\n];\n\nderives[valuesIndex.life] = [\n    // Life, oldest step.\n    [Math.max(stepsPast-1, 0), valuesIndex.life],\n    // Life, 1 step past.\n    valuesIndex.life\n];\n\nderives[valuesIndex.acceleration] = [\n    valuesIndex.acceleration,\n    valuesIndex.life\n];\n\n// Whether to allow Verlet integration.\nconst canVerlet = (stepsPast >= 2);\n\nconst cache = { source: [] };\n\n// The main GPGPU state.\nconst state = gpgpu(regl, {\n    props: {\n        // Set up the timer.\n        timer: timer((timestep)?\n                // Fixed-step, look-ahead add-time.\n                { step: timestep }\n                // Real-time, look-behind delta-time.\n            :   { step: '-', now: () => regl.now()*1e3 }),\n        // Speed up or slow down the passage of time.\n        rate: 1,\n        // Loop time over this period to avoid instability of parts of the demo.\n        loop: 3e3,\n        // Whether to use Verlet (midpoint) or Euler (forward) integration.\n        useVerlet: canVerlet,\n        // Range of how long a particle lives before respawning.\n        lifetime: [5e2, 3e3],\n        // Acceleration due to gravity.\n        g: [0, -9.80665, 0],\n        // The position particles respawn from.\n        source: [0, 0, 0.5],\n        // To help accuracy of very small numbers, pass force as `[X, Y] = XeY`.\n        // One of these options chosen depending on integration used.\n        force: [\n            // Euler.\n            [1, -4],\n            // Verlet.\n            [1, -7]\n        ],\n        // To help with accuracy of small numbers, uniformly scale space.\n        scale: 1e-3\n    },\n    bound, steps, scale,\n    maps: { values, derives },\n    // Per-shader macro hooks, no macros needed for the `vert` shader.\n    macros: { vert: false },\n    step: {\n        // Per-pass macros will prepend to `frag` shader and cache in `frags`.\n        frag: stepFrag, frags: [],\n        uniforms: {\n            dt: (_, { props: { timer: { dt }, rate } }) => dt*rate,\n            time: (_, { props: { timer: { time }, rate } }) => time*rate,\n            loop: (_, { props: { timer: { time }, loop } }) =>\n                Math.sin(time/loop*Math.PI)*loop,\n\n            lifetime: regl.prop('props.lifetime'),\n            g: regl.prop('props.g'),\n\n            source: (_, { props: { source, scale } }) =>\n                map((v, i) => v/scale, source, cache.source),\n\n            force: (_, { props: { useVerlet: u, force: f } }) => f[+u],\n            useVerlet: (_, { props: { useVerlet: u } }) => +u\n        }\n    }\n});\n\nconsole.log(self.state = state);\n\n// Set up rendering.\n\n// Particle count - note `countDrawIndexes` here equals `state.size.count`.\n// @todo Why doesn't `state.steps.length-state.bound` seem to make a difference?\nconst drawCount = countDrawIndexes(state.size)*indexPairs(state.steps.length);\nconst drawIndexes = getDrawIndexes(drawCount);\n\nconst drawState = {\n    ...state,\n    // Drawing, don't need to output anything to the data textures.\n    macros: { 'output': false },\n    // Set `derives[0]` to `true` - one derive can read all values efficiently.\n    maps: getMaps({ values, derives: [true], texturesMax: maxTextureUnits })\n};\n\nconst drawCommand = {\n    // Use GPGPU macro mappings by prepending macros from a single pass.\n    vert: macroPass(drawState)+drawVert,\n    frag: drawFrag,\n    attributes: { index: drawIndexes },\n    // Hook up GPGPU uniforms by adding them here.\n    uniforms: getUniforms(drawState, {\n        ...drawState.step.uniforms,\n        scale: regl.prop('props.scale'), pointSize: 2**3\n    }),\n    lineWidth: 1,\n    count: drawCount,\n    depth: { enable: true },\n    blend: { enable: true, func: { src: 'one', dst: 'one minus src alpha' } },\n    primitive: ((drawState.steps.length > 2)? 'lines' : 'points')\n};\n\nconsole.log((self.drawState = drawState), (self.drawCommand = drawCommand));\n\nconst draw = regl(drawCommand);\n\nconst clearView = { color: [0, 0, 0, 0], depth: 1 };\n\nregl.frame(() => {\n    timer(state.props.timer);\n    state.step.run();\n    drawState.stepNow = state.stepNow;\n    regl.clear(clearView);\n    draw(drawState);\n});\n\n// Toggle Verlet integration, if there are enough past steps.\ncanvas.addEventListener('click', () =>\n    console.log('useVerlet',\n        (state.props.useVerlet = (canVerlet && !state.props.useVerlet))));\n\ncanvas.addEventListener('touchmove', (e) => {\n    e.stopPropagation();\n    e.preventDefault();\n});\n\ncanvas.addEventListener((('onpointermove' in self)? 'pointermove'\n        :   (('ontouchmove' in self)? 'touchmove' : 'mousemove')),\n    (e) => {\n        const { clientX: x, clientY: y } = e;\n        const { source } = state.props;\n        const size = Math.min(innerWidth, innerHeight);\n\n        source[0] = ((((x-((innerWidth-size)*0.5))/size)*2)-1);\n        source[1] = -((((y-((innerHeight-size)*0.5))/size)*2)-1);\n\n        e.stopPropagation();\n        e.preventDefault();\n    });\n\nmodule?.hot?.accept?.(() => location.reload());\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n","import defineProperty from './_define_property';\n\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import arrayWithHoles from './_array_with_holes';\nimport iterableToArrayLimit from './_iterable_to_array';\nimport nonIterableRest from './_non_iterable_rest';\n\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n","import arrayWithoutHoles from './_array_without_holes';\nimport iterableToArray from './_iterable_to_array';\nimport nonIterableSpread from './_non_iterable_spread';\n\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n","module.exports = clamp\n\nfunction clamp(value, min, max) {\n  return min < max\n    ? (value < min ? min : value > max ? max : value)\n    : (value < max ? max : value > min ? min : value)\n}\n","/**\n * Simple time-stepping - frame, real-time, constant-step - via any API.\n */\n\nexport const steps = {\n    diff: '-', dt: '-', '⏳': '-',\n    pause: 0, '⏸': 0,\n    add: '+', '⏭': '+'\n};\n\nexport const stepDef = steps.diff;\nexport const startDef = 0;\nexport const nowDef = { [steps.diff]: Date.now, [steps.add]: 1e3/60 };\n\n/**\n * Sets up properties needed to track time, starts/steps time in various ways:\n * - Time-difference or time-advance stepping.\n * - Step forwards or backwards in time or pause it.\n * - Current time can be a number or function; or the object's fixed time-step.\n * - Override property, pass the result to new objects.\n *\n * @example\n *     // Initial call sets up properties.\n *     const diff0 = timer({ step: '-' }, 200);\n *     // => { step: '-', time: 200, dt: 200 };\n *     const add0 = timer({ step: 200 });\n *     // => { step: 200, time: 200, dt: 200 };\n *\n *     // Subsequent calls advance time and track difference.\n *\n *     // No time difference here.\n *     timer(diff0, 200); // => { step: '-', time: 200, dt: 0 };\n *     timer(add0, 0); // => { step: 200, time: 200, dt: 0 };\n *\n *     // Time-difference here with a change or step, into a new result target.\n *     const diff1 = timer(diff0, 300, {});\n *     // => { step: '-', time: 300, dt: 100 };\n *     const add1 = timer(add0, null, {});\n *     // => { step: 200, time: 400, dt: 200 };\n *\n *     diff1.time-diff0.time === diff1.dt; // => true;\n *     add1.time-add0.time === add1.dt; // => true;\n *\n * @param {object} state The state being tracked.\n * @param {number} [state.time=startDef] The initial time.\n * @param {string|number} [state.step=stepDef] How time advances:\n *     - Difference since last `time`: `'diff'`/`'dt'`/`'-'`/`'⏳'`.\n *     - Pause: `'pause'`/`'⏸'`, or number zero (`0`).\n *     - Add `time` step: `'add'`/`'+'`/`'⏭'`, or non-zero number (step size).\n * @param {number|function} [now] The time now (clock/frame/step/etc), or a\n *     function giving it; if not given, uses `state.step` if numeric or\n *     `nowDef[state.step]` otherwise.\n * @param {object|false} [out=state] The state to set up; modifies `state` if\n *     not given.\n *\n * @returns {object|number} The given `out` set up with its initial `time`; or\n *     if `out` is falsey, returns the relevant calculated unknown value:\n *     - The difference since last `time` for `diff` step.\n *     - The updated `time` for `add` or `pause` step.\n */\nexport function timer(state, now, out = state) {\n    // Get the initial time and step-step.\n    const { time: t0 = startDef, step = stepDef, now: n } = state;\n    // Get the step mode - from a key into `steps` or a numerical value.\n    const s = (steps[step] ?? step);\n    const diff = (s === steps.diff);\n    const t = (now ?? n ?? nowDef[s] ?? s);\n\n    // Step by `s`:\n    // - `0` or falsey to `pause`\n    // - `steps.diff` for difference since last `time`\n    // - `steps.add` or a number to add a `time` step\n    const t1 = ((!s)? t0 : ((diff)? 0 : t0)+((isNaN(t))? t() : t));\n    const dt = t1-t0;\n\n    // If only returning a value, return the relevant calculated unknown.\n    if(!out) { return ((diff)? dt : t1); }\n\n    out.time = t1;\n    out.dt = dt;\n    out.step = step;\n\n    return out;\n}\n\nexport default timer;\n","const r = Array.prototype.reduce;\n\n/**\n * Reduce an array-like object.\n * Similar to native, but with iteratee-first arguments.\n * Supports the native single-argument behaviour.\n *\n * @param {function} f The iteratee function, given standard arguments, plus the\n *     `out` argument.\n * @param {array} a The list to reduce over (array or array-like object).\n * @param {*} [out] The initial accumulator, if given; otherwise, uses standard\n *     `Array.reduce` behaviour.\n *\n * @returns {*} The result of running the reducer iteratee function over all\n *     elements of the list.\n */\nexport const reduce = (f, a, out) =>\n    // Needs separate `call` because native detects even `undefined` parameter.\n    ((out === undefined)? r.call(a, f) : r.call(a, f, out));\n\nexport default reduce;\n","import { reduce } from './reduce';\n\n/**\n * Map an array-like object.\n * Similar to native, but with iteratee-first arguments; and allows the object\n * into which properties will be mapped to be defined (a new array, by default),\n * avoiding always creating new arrays.\n *\n * @param {function} f The iteratee function, given standard `Array.map`\n *     arguments, plus the output object.\n * @param {array} a The list to map over (array or array-like object).\n * @param {*} [out=[]] The initial accumulator, if given; `a` if falsey given;\n *     or a new array if not given.\n *\n * @returns {*} The result of mapping `out` through the iteratee function over\n *     the `a` list.\n */\nexport const map = (f, a, out = []) => reduce((out, v, i) => {\n        out[i] = f(v, i, a, out);\n\n        return out;\n    },\n    a, (out || a));\n\nexport default map;\n","/**\n * GPGPU state-stepping: maps minimal draw passes, shaders, GL resources,\n * inputs, outputs. BYORenderer.\n *\n * Rendering approach/engine specific, decoupled from the physics code.\n * The modules and many hooks may be used as given, or piecemeal, or overridden.\n */\n\nimport { getMaps } from './maps';\nimport { getState } from './state';\nimport { getStep } from './step';\n\nexport * from './const';\n\n/**\n * Sets up all the maps, inputs, resources, etc for a GPGPU process.\n *\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [mapSamples]{@link ./maps.js#mapSamples}\n * @see [getState]{@link ./step.js#getState}\n * @see [getUniforms]{@link ./step.js#getUniforms}\n * @see [getStep]{@link ./step.js#getStep}\n * @see [macroPass]{@link ./macros.js#macroPass}\n *\n * @param {object} api An API for GL resources. See `getState` and `getStep`.\n * @param {object} [api.limits=api] A map of GL resource limits.\n * @param {number} [api.limits.maxDrawbuffers] The maximum number of GL textures\n *     a framebuffer can bind in a single draw call.\n * @param {object} [state={}] State properties to set up; a new object by\n *     default. See `getState`, `getUniforms`, and `getStep`.\n * @param {object} [state.maps] How values are grouped per-texture per-pass\n *     per-step. Sets up new maps if not given or missing its mapped properties.\n *     See `mapGroups`.\n * @param {number} [state.maps.texturesMax=api.limits.maxDrawbuffers] The\n *     maximum number of textures to use per draw pass. Uses more passes above\n *     this limit.\n * @param {object} [to=state] The state object to set up. Modifies the given\n *     `state` object by default.\n */\nexport function gpgpu(api, state = {}, to = state) {\n    const { maxDrawbuffers: texturesMax, glsl } = (api.limits ?? api);\n    const { maps = {} } = state;\n\n    to.glsl = parseFloat(glsl.match(/[0-9\\.]+/)[0]);\n    maps.texturesMax ??= texturesMax;\n    to.maps = getMaps(maps);\n    getState(api, state, to).step = getStep(api, state);\n\n    return to;\n}\n\nexport default gpgpu;\n","/**\n * GPGPU mappings for step/draw shaders input/output.\n *\n * These maps show shaders how to make use of a system's supported features, how\n * to pack/unpack their data with framebuffers/textures, perform only the needed\n * texture samples to retrieve any past values they must derive from, etc.\n * Shaders may declare values they output, values they derive from, groupings of\n * in/dependent values - without handling how these concerns map to the\n * particular system resources they're using.\n * System limits/features/extensions are accounted for, to produce the most\n * efficient mappings available with the least I/O when it comes to drawing\n * (draw passes, texture samples, etc).\n *\n * @todo Check `packValues` optional and/or based on the given `derives` work.\n * @todo Check examples are correct.\n */\n\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport each from '@epok.tech/fn-lists/each';\n\nimport { valuesDef, channelsMaxDef, texturesMaxDef } from './const';\n\nexport const cache = { packed: [] };\n\nexport const validValue = (value, channelsMax = channelsMaxDef) =>\n    (((1 <= value) && (value <= channelsMax)) ||\n        !!console.error(`\\`gl-gpgpu\\`: the given value (${value}) exceeds the `+\n            `range of channels available (1 to ${channelsMax}).`,\n            value, channelsMax));\n\n/**\n * Minimise resource usage, order `values` to pack into blocks of `channelsMax`.\n *\n * @see mapGroups\n *\n * @param {array<number>} values Each entry is how many co-dependent channels\n *     are grouped into one texture in one pass, separate entries may be in one\n *     or more textures/passes. See `mapGroups`.\n * @param {number} [channelsMax=channelsMaxDef] The maximum number of channels\n *     per texture. See `mapGroups`.\n * @param {array} [to=[]] An array to store the result; a new array by default.\n *\n * @returns {array<number>} `to` The indexes of the given `values`, reordered\n *     to pack into the fewest buckets of `channelsMax` size or less; stored in\n *     the given `to` array.\n */\nexport function packValues(values, channelsMax = channelsMaxDef, to = []) {\n    map((_, i) => i, values, to).length = values.length;\n\n    // Counts the number of empty channels in the current group.\n    let channels = channelsMax;\n    // How many values have already been packed.\n    let packed = 0;\n    // Tracks the value that best fits the free channels (fills it tightest).\n    let fitIndex = 0;\n    let fitSize = Infinity;\n\n    for(let i = 0; packed < values.length;) {\n        const v = packed+i;\n        const value = values[to[v]];\n\n        if(!validValue(value, channelsMax)) { return to; }\n\n        // Check how value fits the channels - valid is >= 0, perfect is 0.\n        const fit = channels-value;\n\n        if((fit >= 0) && (fit < fitSize)) {\n            fitSize = fit;\n            fitIndex = v;\n        }\n\n        if((fitSize !== 0) && (v < values.length-1)) { ++i; }\n        else {\n            // Got a perfect fit or the search ended - swap in best fit value.\n            const pack = to[fitIndex];\n\n            to[fitIndex] = to[packed];\n            to[packed] = pack;\n\n            // Reduce the free channels by the best value, reset if needed.\n            (((channels -= values[pack]) > 0) || (channels = channelsMax));\n            // Start the search again over the remaining unpacked entries.\n            fitIndex = ++packed;\n            fitSize = Infinity;\n            i = 0;\n        }\n    }\n\n    return to;\n}\n\n/**\n * Groups the `values` of GPGPU data items across draw passes and data textures.\n *\n * @todo Now `values` may be packed first into buckets of `channelsMax` tightly\n *     before mapping, check whether the examples are correct.\n *\n * @example\n *     mapGroups({ values: [2, 4, 1], channelsMax: 4, texturesMax: 1 }); // =>\n *     {\n *         values: [2, 4, 1],\n *         textures: [[0], [1], [2]], // length === 3\n *         passes: [[0], [1], [2]], // length === 3\n *         texturesMax: 1,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 2],\n *         valueToPass: [0, 1, 2],\n *         textureToPass: [0, 1, 2]\n *     };\n *\n *     mapGroups({ values: [4, 2, 1], texturesMax: 1 }); // =>\n *     {\n *         values: [4, 2, 1],\n *         textures: [[0], [1, 2]], // length === 2\n *         passes: [[0], [1]], // length === 2\n *         texturesMax: 1,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 1],\n *         valueToPass: [0, 1, 1],\n *         textureToPass: [0, 1]\n *     };\n *\n *     mapGroups({ values: [4, 2, 1], texturesMax: 4 }); // =>\n *     {\n *         values: [4, 2, 1],\n *         textures: [[0], [1, 2]], // length === 2\n *         passes: [[0, 1]], // length === 1\n *         texturesMax: 4,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 1],\n *         valueToPass: [0, 0, 0],\n *         textureToPass: [0, 0]\n *     };\n *\n *     mapGroups({ values: [2, 4, 1], texturesMax: 4 }); // =>\n *     {\n *         values: [2, 4, 1],\n *         textures: [[0], [1], [2]], // length === 3\n *         passes: [[0, 1, 2]], // length === 1\n *         texturesMax: 4,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 2],\n *         valueToPass: [0, 0, 0],\n *         textureToPass: [0, 0, 0]\n *     };\n *\n *     mapGroups({ values: [2, 4, 1, 2], texturesMax: 2 }); // =>\n *     {\n *         values: [2, 4, 1, 2],\n *         textures: [[0], [1], [2, 3]], // length === 3\n *         passes: [[0, 1], [2]], // length === 2\n *         texturesMax: 2,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 2, 2],\n *         valueToPass: [0, 0, 1, 1],\n *         textureToPass: [0, 0, 1]\n *     };\n *\n * @see packValues\n *\n * @export\n * @param {object} [maps={}] The maps. A new object if not given.\n * @param {array<number>} [maps.values=valuesDef()] An array where each number\n *     denotes how many value channels are grouped into one data texture in one\n *     draw pass; each separate number may be drawn across one or more data\n *     textures/passes. Each value denotes the number of dependent channels to\n *     be drawn together; separate values denote channels that aren't dependent,\n *     and may be drawn in the same or a separate pass, depending on device\n *     support. The given order is (currently) maintained, and may affect the\n *     number of passes/textures used. Where the next state depends on previous\n *     states, these should ideally be an entry of `channels` or less, for\n *     fewest texture reads to retrieve previous states.\n * @param {number} [maps.channelsMax=channelsMaxDef] Maximum channels per\n *     texture.\n * @param {number} [maps.texturesMax=texturesMaxDef] Maximum textures bound per\n *     pass.\n * @param {array<number>|falsey} [maps.packed] An array of indexes into `values`\n *     packed into an order that best fits into blocks of `channelsMax` to\n *     minimise resources; or `falsey` to use `values` in their given order;\n *     uses `packValues` if not given.\n * @param {object} [to=maps] An object to contain the results; modifies `maps`\n *     if not given.\n *\n * @returns {object} `to` The given `to` object; how `values` are grouped\n *     per-texture per-pass per-step, meta information, and given parameters.\n * @returns {array<array<number>>} `to.passes` Textures grouped into passes;\n *     arrays corresponding to framebuffers in separate draw passes; whose\n *     values are indexes into `to.textures`.\n * @returns {array<array<number>>} `to.textures` Values grouped into\n *     textures; arrays corresponding to framebuffer attachments, into which\n *     `values` are drawn; whose values are indexes into `to.values`.\n * @returns {array<number>} `to.values` The `values`, as given.\n * @returns {number} `to.texturesMax` The max textures per pass, as given.\n * @returns {number} `to.channelsMax` The max channels per texture, as given.\n * @returns {array<number>} `to.valueToTexture` Inverse map from each index of\n *     `to.values` to the index of the data texture containing it.\n * @returns {array<number>} `to.valueToPass` Inverse map from each index of\n *     `to.values` to the index of the pass containing it.\n * @returns {array<number>} `to.textureToPass` Inverse map from each index of\n *     `to.textures` to the index of the pass containing it.\n */\nexport function mapGroups(maps = {}, to = maps) {\n    if(!maps) { return to; }\n\n    const {\n            values = valuesDef(),\n            channelsMax = channelsMaxDef, texturesMax = texturesMaxDef,\n            // Pack `values` into blocks of `channelsMax` to minimise resources.\n            packed = packValues(values, channelsMax, cache.packed)\n        } = maps;\n\n    to.values = values;\n    to.texturesMax = texturesMax;\n    to.channelsMax = channelsMax;\n\n    const passes = to.passes = [[]];\n    const textures = to.textures = [[]];\n    const valueToTexture = to.valueToTexture = [];\n    const valueToPass = to.valueToPass = [];\n    const textureToPass = to.textureToPass = [];\n\n    // Counts the number of channels written in a single draw pass.\n    let channels = 0;\n    // Get the value, via `packed` if valid, or directly as given in `values`.\n    const getValue = ((packed)? (v) => values[v] : (v) => v);\n\n    return reduce((to, v) => {\n            const value = getValue(v);\n\n            if(!validValue(value, channelsMax)) { return to; }\n\n            let p = passes.length-1;\n            let pass = passes[p];\n            let t = textures.length-1;\n            let texture = textures[t];\n\n            if((channels += value) > channelsMax) {\n                channels = value;\n                t = textures.push(texture = [])-1;\n\n                ((pass.length >= texturesMax) &&\n                    (p = passes.push(pass = [])-1));\n\n                pass.push(t);\n                textureToPass.push(p);\n            }\n            else if(pass.length === 0) {\n                pass.push(t);\n                textureToPass.push(p);\n            }\n\n            texture.push(v);\n            valueToTexture.push(t);\n            valueToPass.push(p);\n\n            return to;\n        },\n        (packed || values), to);\n}\n\n/**\n * Maps the minimal set of texture reads to derive the next state of values from\n * a past state of values they depend upon.\n *\n * @example\n *     const maps = mapGroups({\n *         values: [2, 4, 1, 2], channelsMax: 4, texturesMax: 2,\n *         // Entries per-value of derived step/value indexes, entries include:\n *         // empty, single, multiple, and defined step samples.\n *         derives: [[1, 0], , [3, [1, 0]], 2]\n *     });\n *\n *     mapSamples(maps); // =>\n *     {\n *         ...maps,\n *         // Per-pass, minimum texture samples for values.\n *         samples: [\n *             // Per-value - step/texture index pairs into `maps.textures`.\n *             [[0, 1], [0, 0]],\n *             [[0, 2], [1, 0]]\n *         ],\n *         // Per-pass, value indexes to texture samples.\n *         reads: [\n *             // Per-value - indexes into `to.samples`.\n *             [[0, 1], , , ],\n *             [, , [0, 1], [0]]\n *         ]\n *     };\n *\n * @see mapGroups\n *\n * @export\n * @param {object} maps How values are grouped per-texture per-pass per-step.\n *     See `mapGroups`.\n * @param {true|array<null,true,number,array<true,number,array<true,number>>>}\n *     [maps.derives] How values derive from others.\n *     If given as an array, each entry relates the corresponding value to\n *     any past value steps/indexes it derives from - a value not derived from\n *     past values may have an empty/null entry; a value derives from past\n *     values where its entry has:\n *     - Numbers; deriving from the most recent state at the given value index.\n *     - Lists of numbers; deriving from the given past state index (1st number\n *         denotes how many steps ago), at the given value index (2nd number).\n *     If any level is given as `true`, maps to sample all values, at the given\n *     or most recent step.\n *     If not given, no samples are mapped and `to` is returned unchanged.\n * @param {array<array<number>>} maps.passes Textures grouped into passes. See\n *     `mapGroups`.\n * @param {array<array<number>>} maps.textures Values grouped into textures. See\n *     `mapGroups`.\n * @param {array<number>} maps.valueToTexture Inverse map from each value index\n *     to the data texture index containing it.\n * @param {object} [to=maps] The object to store the result in; `maps` if not\n *     given.\n *\n * @returns {object} `to` The given `to` object, with resulting maps added if\n *     `maps.derives` were provided.\n * @returns {array<array<array<number>>>} `[to.samples]` Map of the minimum\n *     set of indexes into `maps.textures` that need to be sampled per-pass,\n *     to get all `derives` needed for each value of `maps.values` of each\n *     pass of `maps.passes`.\n * @returns {array<array<null,array<number>>>} `[to.reads]` Sparse map from\n *     each value of `derives` to its step and texture indexes in `to.samples`.\n * @returns {true|array<null,true,number,array<true,number,array<true,number>>>}\n *     `[to.derives]` How values are derived, as given.\n */\nexport function mapSamples(maps, to = maps) {\n    const derives = maps?.derives;\n\n    if(!derives) { return to; }\n\n    const { passes, textures, valueToTexture } = maps;\n    const reads = to.reads = [];\n    const cache = {};\n\n    to.derives = derives;\n\n    const all = (step = 0) =>\n        cache[step] ??= map((t, v) => [step, v], valueToTexture);\n\n    const getAddSample = (pass, value) => function add(set, derive, d) {\n        let step = 0;\n        let texture;\n\n        if(derive === true) { return reduce(add, all(step), set); }\n        else if(Number.isFinite(derive)) { texture = valueToTexture[derive]; }\n        else if(derive[1] === true) { return reduce(add, all(derive[0]), set); }\n        else {\n            step = derive[0];\n            texture = valueToTexture[derive[1]];\n        }\n\n        if(!Number.isFinite(step) || !Number.isFinite(texture)) {\n            return console.error('`mapSamples`: invalid map for sample',\n                derives, maps, pass, value, derive, d, step, texture);\n        }\n\n        let i = set.findIndex(([s, t]) => (s === step) && (t === texture));\n\n        ((i < 0) && (i = set.push([step, texture])-1));\n\n        const passReads = reads[pass] ??= [];\n        const valueReads = passReads[value] ??= [];\n\n        valueReads[d ?? 0] = i;\n\n        return set;\n    };\n\n    const getAddSamples = (pass) => (set, value) => {\n        const valueDerives = ((derives === true)? derives : derives[value]);\n\n        ((valueDerives || (valueDerives === 0)) &&\n            (((valueDerives === true) || Number.isFinite(valueDerives))?\n                getAddSample(pass, value)(set, valueDerives)\n            :   reduce(getAddSample(pass, value), valueDerives, set)));\n\n        return set;\n    }\n\n    to.samples = map((pass, p) => reduce((set, texture) =>\n                reduce(getAddSamples(p), textures[texture], set),\n            pass, []),\n        passes, []);\n\n    return to;\n}\n\nexport const getMaps = (maps, to = maps) =>\n    mapSamples(maps, mapGroups(maps, to));\n\nexport default getMaps;\n","const e = Array.prototype.forEach;\n\n/**\n * Iterates a function over every element of a list, returning the list.\n *\n * @param {function} f The iteratee function.\n * @param {array} a A list to iterate over (array or array-like object).\n *\n * @returns {array} The given list.\n */\nexport const each = (f, a) => {\n    e.call(a, f);\n\n    return a;\n}\n\nexport default each;\n","/**\n * GPGPU defaults and constants.\n */\n\nimport { positions } from '@epok.tech/gl-screen-triangle';\n\nexport { default as vertDef }\n    from '@epok.tech/gl-screen-triangle/uv-texture.vert.glsl';\n\n// The required and optional GL extensions for a GPGPU state.\n\nexport const extensions = () => [];\n\n// To draw to `float` buffers.\nexport const extensionsFloat = () =>\n    ['oes_texture_float', 'webgl_color_buffer_float'];\n\n// To draw to `half float` buffers.\nexport const extensionsHalfFloat = () =>\n    ['oes_texture_half_float', 'ext_color_buffer_half_float'];\n\nexport const optionalExtensions = () => ['webgl_draw_buffers'];\n\n/**\n * Default properties for GPGPU and GL capabilities and resources.\n */\n\n// Prefix namespace to avoid naming clashes.\nexport const preDef = '';\n\n// The allowable range of channels for framebuffer attachments.\n// Default avoids `RGB32F` framebuffer attachments, which errors on\n// Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1448632\nexport const channelsMinDef = 4;\nexport const channelsMaxDef = 4;\n\nexport const texturesMaxDef = 1;\nexport const boundDef = 1;\nexport const scaleDef = 10;\nexport const stepsDef = 2;\nexport const typeDef = 'float';\nexport const valuesDef = () => [channelsMaxDef];\nexport const positionsDef = () => [...positions];\n","/**\n * The 3 vertices of a 2D triangle covering the viewport in NDC coordinates ([-1, 1]).\n *\n * @export\n * @type {array.<array.<number>>}\n */\nexport const vertices = [[-1, -1], [-1, 4], [4, -1]];\n\nexport const count = vertices.length;\nexport const dim = 2;\n\n/**\n * The flat array of the above triangle, to be bound as a WebGL attribute buffer for\n * rendering the triangle in the vertex shader.\n * These positions will result in clipped NDC coordinates ([-1, 1]) over the\n * viewport's width and height.\n *\n * @export\n * @type {array.<number>}\n */\nexport const positions = vertices.flat();\n\nexport default positions;\n","precision highp float;\n\nattribute vec2 position;\n\nvarying vec2 uv;\n\n// Translation for UV NDC to texture coordinates.\nconst vec2 offset = vec2(0.5);\n\nvoid main() {\n    uv = (position*0.5)+offset;\n    gl_Position = vec4(position, 0, 1);\n}\n","/**\n * GPGPU state and GL resources.\n *\n * @todo In-place updates of complex resources and meta info.\n * @todo Use transform feedback instead of data textures, if supported (WebGL2)?\n * @todo Consider class/object/data/function structure further.\n */\n\nimport range from '@epok.tech/fn-lists/range';\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\n\nimport { scaleDef, stepsDef, valuesDef, channelsMinDef, typeDef }\n    from './const';\n\n/**\n * Set up the GPGPU resources and meta information for a state of a number data.\n *\n * @todo Transform feedback.\n * @todo Validate, check examples.\n * @todo Reorder the given `values` into the most efficient `maps`?\n *\n * @example\n *     const state = {\n *         steps: 2, maps: mapGroups({ values: [4, 2, 3], texturesMax: 4 })\n *     };\n *\n *     getState(api, state); // =>\n *     {\n *         ...state, passNow: undefined, stepNow: undefined,\n *         size: {\n *             type: 'float', steps: 2, passes: 2, textures: 6,\n *             width: 1024, height: 1024, shape: [1024, 1024], count: 1048576\n *         },\n *         steps: [[api.framebuffer], [api.framebuffer]],\n *         passes: [\n *             [\n *                 {\n *                     step: 0, index: 0, count: 0, map: [0, 1, 2],\n *                     framebuffer: api.framebuffer,\n *                     textures: [api.texture, api.texture, api.texture]\n *                 }\n *             ],\n *             [\n *                 {\n *                     step: 1, index: 0, count: 1, map: [0, 1, 2],\n *                     framebuffer: api.framebuffer,\n *                     textures: [api.texture, api.texture, api.texture]\n *                 }\n *             ]\n *         ],\n *         textures: [\n *             [\n *                 {\n *                     step: 0, pass: 0, index: 0, count: 0, map: [0],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 0, pass: 0, index: 1, count: 1, map: [1],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 0, pass: 0, index: 2, count: 2, map: [2],\n *                     texture: api.texture\n *                 }\n *             ],\n *             [\n *                 {\n *                     step: 1, pass: 0, index: 0, count: 3, map: [0],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 1, pass: 0, index: 1, count: 4, map: [1],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 1, pass: 0, index: 2, count: 5, map: [2],\n *                     texture: api.texture\n *                 }\n *             ]\n *         ]\n *     };\n *\n *     Object.assign(state, {\n *         type: 'uint8', stepNow: 2,\n *         maps: mapGroups({ values: [4, 2, 3], texturesMax: 1 })\n *     });\n *\n *     getState(api, state); // =>\n *     {\n *        ...state, passNow: undefined, stepNow: 2,\n *        size: {\n *            type: 'uint8', steps: 2, passes: 6, textures: 6,\n *            width: 1024, height: 1024, shape: [1024, 1024], count: 1048576\n *        },\n *        steps: [\n *            [api.framebuffer, api.framebuffer, api.framebuffer],\n *            [api.framebuffer, api.framebuffer, api.framebuffer]\n *        ],\n *        passes: [\n *            [\n *                {\n *                    step: 0, index: 0, count: 0, map: [0],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 0, index: 1, count: 1, map: [1],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 0, index: 2, count: 2, map: [2],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                }\n *            ],\n *            [\n *                {\n *                    step: 1, index: 0, count: 3, map: [0],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 1, index: 1, count: 4, map: [1],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 1, index: 2, count: 5, map: [2],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                }\n *            ]\n *        ],\n *        textures: [\n *            [\n *                {\n *                    step: 0, pass: 0, index: 0, count: 0, map: [0],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 0, pass: 1, index: 1, count: 1, map: [1],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 0, pass: 2, index: 2, count: 2, map: [2],\n *                    texture: api.texture\n *                }\n *            ],\n *            [\n *                {\n *                    step: 1, pass: 0, index: 0, count: 3, map: [0],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 1, pass: 1, index: 1, count: 4, map: [1],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 1, pass: 2, index: 2, count: 5, map: [2],\n *                    texture: api.texture\n *                }\n *            ]\n *        ]\n *    };\n *\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [mapSamples]{@link ./maps.js#mapSamples}\n * @see [getStep]{@link ./step.js#getStep}\n * @see [macroPass]{@link ./macros.js#macroPass}\n *\n * @export\n * @param {object} api The API for GL resources.\n * @param {function} api.texture A function to create a GL texture.\n * @param {function} api.framebuffer A function to create a GL framebuffer.\n * @param {object} [state={}] The state parameters.\n * @param {number} [state.radius] The length of the sides of the data textures\n *     to allocate. If given, supersedes the `state` `width`/`height`/`scale`.\n * @param {number} [state.width] The width of the data textures to allocate.\n *     If given, supersedes `state.scale`.\n * @param {number} [state.height] The height of the data textures to allocate.\n *     If given, supersedes `state.scale`.\n * @param {number} [state.scale=scaleDef] The length of the data textures sides\n *     to allocate; gives a square power-of-two texture raising 2 to this power.\n * @param {number|array} [state.steps=stepsDef] How many steps of state to\n *     track, or the list of states if already set up.\n * @param {object} [state.maps] How `state.maps.values` are grouped per-texture\n *     per-pass per-step. See `mapGroups`.\n * @param {array<number>} [state.maps.values=valuesDef()] How values of each\n *     data item may be grouped into textures across passes. Set up here if not\n *     given. See `mapGroups`.\n * @param {number} [state.maps.channelsMin=channelsMinDef] The minimum allowed\n *     channels for framebuffer attachments. Sets up unused channels as needed\n *     to reach this limit.\n * @param {number} [state.maps.textures] How values are grouped into textures.\n *     See `mapGroups`.\n * @param {string} [state.type=typeDef] The data type of the textures.\n * @param {number} [state.stepNow] The currently active state step, if any.\n * @param {number} [state.passNow] The currently active draw pass, if any.\n * @param {object} [to=state] The state object to set up. Modifies the given\n *     `state` object by default.\n *\n * @returns {object} `to` The state object, set up with the data resources and\n *     meta information, for step/draw later:\n * @returns {object<number,array<number,array<number>>>} `to.maps` Any given\n *     `state.maps`. See `mapGroups`.\n * @returns {array<array<object<api.texture,number,array<number>>>>}\n *     `to.textures` Textures per step, as arrays of objects of `api.texture`,\n *     and meta info. See `to.maps.textures`.\n * @returns {array<array<object<api.framebuffer,number,array<number>>>>}\n *     `to.passes` Passes per step, as arrays of objects of `api.framebuffer`,\n *     referencing `to.textures`, and meta info. See `to.maps.passes`.\n * @returns {array<api.framebuffer<array<api.texture>>>} `to.steps`\n *     Hierarchy of steps of state, as an array of `api.framebuffer` from\n *     `to.passes`, with arrays of `api.texture` from `to.textures`, and meta\n *     information; set up here, or the given `state.steps` if it was an array.\n *     State data may be drawn into the framebuffers accordingly.\n *     See `mapGroups` and `getStep`.\n * @returns {object<number,string,array<number>>} `to.size` Size/type\n *     information on data resources.\n * @returns {number} `to.stepNow` The currently active state step, as given.\n * @returns {number} `to.passNow` The currently active draw pass, as given.\n */\nexport function getState(api, state = {}, to = state) {\n    // See usage here for what the API must implement.\n    const { texture, framebuffer } = api;\n\n    const {\n            radius, width, height, scale = scaleDef, type = typeDef,\n            steps = stepsDef, stepNow, passNow, maps\n        } = state;\n\n    to.maps = maps;\n    to.stepNow = stepNow;\n    to.passNow = passNow;\n\n    const {\n            values = valuesDef(),\n            channelsMin = channelsMinDef, textures: texturesMap\n        } = maps;\n\n    maps.channelsMin = channelsMin;\n    maps.values = values;\n\n    const textureProps = {\n        type, min: 'nearest', mag: 'nearest', wrap: 'clamp',\n        // Passing `state.scale` ensures a power-of-two square texture size.\n        width: (radius ?? width ?? 2**scale),\n        height: (radius ?? height ?? 2**scale)\n    };\n\n    const { width: w, height: h } = textureProps;\n\n    // Size of the created resources.\n    const size = to.size = {\n        steps: (steps.length ?? steps), textures: 0, passes: 0,\n        width: w, height: h, shape: [w, h], count: w*h\n    };\n\n    const textures = to.textures = [];\n    const passes = to.passes = [];\n\n    const addTexture = (step, pass, textureProps) => (index) =>\n        ((textures[step] ??= [])[index] = {\n            // Meta info.\n            ...textureProps,\n            count: size.textures++, step, pass, index, map: texturesMap[index],\n            // Resources.\n            texture: texture(textureProps)\n        })\n        .texture;\n\n    const addPass = (step) => (pass, index) => {\n        // All framebuffer color attachments need the same number of channels.\n        const passProps = {\n            ...textureProps,\n            channels: reduce((max, t) =>\n                    reduce((max, v) => Math.max(max, values[v]),\n                        texturesMap[t], max),\n                pass, channelsMin)\n        };\n\n        const textures = map(addTexture(step, index, passProps), pass);\n\n        return ((passes[step] ??= [])[index] = {\n                // Meta info.\n                ...passProps, step, index, count: size.passes++, map: pass,\n                // Resources.\n                textures,\n                framebuffer: framebuffer({\n                    width: w, height: h, color: textures,\n                    depth: false, stencil: false\n                })\n            })\n            .framebuffer;\n    };\n\n    // Set up resources we'll need to store data per-texture per-pass per-step.\n    to.steps = map((passes, step) =>\n            // Use any given passes or create a new list of them.\n            (passes || map(addPass(step), maps.passes)),\n        // Use any given steps or create a new list of them.\n        ((Number.isFinite(steps))? range(steps) : steps), 0);\n\n    return to;\n}\n\nexport default getState;\n","/**\n * Creates an iterable array of the given length of empty entries, or\n * those given by optional arguments to `Array.fill`.\n *\n * @see Array.fill\n *\n * @param {number} n The number of elements to create.\n * @param {*} [value] A value to fill the array with; for `Array.fill`.\n * @param {number} [start=0] Start index, inclusive; for `Array.fill`.\n * @param {number} [end=n] End index, exclusive; for `Array.fill`.\n *\n * @returns {array} An array of the given number of empty elements.\n */\nexport const range = (n, value, start, end) => Array(n).fill(value, start, end);\n\nexport default range;\n","/**\n * GPGPU update step.\n */\n\nimport each from '@epok.tech/fn-lists/each';\nimport { wrapGet } from '@epok.tech/fn-lists/wrap-index';\n\nimport { macroPass } from './macros';\nimport { getUniforms } from './inputs';\nimport { vertDef, positionsDef, preDef } from './const';\n\nconst scale = { vec2: 0.5 };\n\n/**\n * Creates a GPGPU update step function, for use with a GPGPU state object.\n *\n * @todo Optional transform feedback instead of GPGPU textures, where available\n *     (needs vertex draw, instead of texture draw).\n * @todo Make this fully extensible in state.\n *\n * @see [getState]{@link ./state.js#getState}\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [macroPass]{@link ./macros.js#macroPass}\n * @see [getUniforms]{@link ./inputs.js#getUniforms}\n *\n * @export\n * @param {object} api An API for GL resources.\n * @param {function} api.buffer A function to set up a GL buffer.\n * @param {function} api.command A function to call a GL draw, with all options.\n * @param {object} state The GPGPU state to use. See `getState` and `mapGroups`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @returns {array<array<number>>} `to.passes` How textures are grouped into\n *     passes. See `mapGroups`.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n * @param {object} [state.step=to] The properties for the step GL command.\n * @param {string} [state.step.vert=vertDef] The step vertex shader GLSL; a\n *     simple flat screen shader if not given.\n * @param {string} state.step.frag The step fragment shader GLSL.\n * @param {object} [state.step.uniforms=getUniforms(state)] The step uniforms;\n *     modifies any given. See `getUniforms`.\n * @param {array|api.buffer} [state.step.positions=positionsDef()] The step\n *     position attributes; 3 points of a large flat triangle if not given.\n * @param {number} [state.step.count=state.step.positions.length*scale.vec2] The\n *     number of elements/attributes to draw.\n * @param {array} [state.step.verts] Preprocesses and caches vertex GLSL code\n *     per-pass if given, otherwise processes it just-in-time before each pass.\n * @param {array} [state.step.frags] Preprocesses and caches fragment GLSL code\n *     per-pass, otherwise processes it just-in-time before each pass.\n * @param {object} [to=(state.step ?? {})] The results object; `state.step` or\n *     a new object if not given.\n *\n * @returns {object} `to` The given `to` object; containing a GPGPU update\n *     step function and related properties, to be passed a GPGPU state.\n * @returns {string} `to.vert` The given/new `state.vert` vertex shader GLSL.\n * @returns {string} `to.frag` The given `state.frag` fragment shader GLSL.\n * @returns {array.string} `[to.verts]` Any cached pre-processed vertex shaders\n *     GLSL, if `state.step.verts` was given.\n * @returns {array.string} `[to.frags]` Any cached pre-processed fragment\n *     shaders GLSL, if `state.step.verts` was enabled.\n * @returns {object} `to.uniforms` The given `state.uniforms`.\n * @returns {number} `to.count` The given/new `state.count`.\n * @returns {api.buffer} `to.positions` The given/new `state.positions`; passed\n *     through `api.buffer`.\n * @returns {api.command} `to.pass` A GL command function to draw a given pass.\n * @returns {function} `to.run` The main step function, which performs all the\n *     draw pass GL commands for a given state step.\n */\nexport function getStep(api, state, to = (state.step ?? {})) {\n    const { buffer, command = api } = api;\n    const { maps: { passes }, pre = preDef, step = to } = state;\n    let { positions = positionsDef() } = step;\n\n    const {\n            vert = vertDef, verts, frag, frags, uniforms,\n            count = positions.length*scale.vec2\n        } = step;\n\n    to.vert = vert;\n    to.frag = frag;\n    to.uniforms = getUniforms(state, uniforms);\n    to.count = count;\n    positions = to.positions = buffer(positions);\n\n    if(verts || frags) {\n        // Pre-process the shaders needed for all the passes.\n        const stateCache = { ...state };\n\n        (verts && (to.verts = verts));\n        (frags && (to.frags = frags));\n\n        each((pass, p) => {\n                stateCache.passNow = p;\n                (verts && (verts[p] = macroPass(stateCache, 'vert')+vert));\n                (frags && (frags[p] = macroPass(stateCache, 'frag')+frag));\n            },\n            passes);\n    }\n\n    to.pass = command(to.passCommand = {\n        // Uses the full-screen vertex shader state by default.\n        vert(_, props) {\n            const { passNow: p, step } = props;\n            const { vert: v = vert, verts: vs = verts } = step;\n\n            // Specify the shader type, for per-shader macro hooks.\n            return vs?.[p] ?? macroPass(props, 'vert')+v;\n        },\n        frag(_, props) {\n            const { passNow: p, step } = props;\n            const { frag: f = frag, frags: fs = frags } = step;\n\n            // Specify the shader type, for per-shader macro hooks.\n            return fs?.[p] ?? macroPass(props, 'frag')+f;\n        },\n        attributes: {\n            [pre+'position']: (_, { step: { positions: p = positions } }) => p\n        },\n        uniforms,\n        count,\n        depth: { enable: false },\n        framebuffer: (_, { steps: ss, stepNow: s, passNow: p }) =>\n            wrapGet(s, ss)[p]\n    });\n\n    to.run = (props = state) => {\n        const { steps, step, maps: { passes } } = props;\n        const stepNow = props.stepNow = (props.stepNow+1 || 0);\n        const { pass, onPass, onStep } = step;\n\n        onStep?.(props, wrapGet(stepNow, steps));\n\n        each((passProps, p) => {\n                props.passNow = p;\n                pass(onPass?.(props, passProps) ?? props);\n            },\n            passes);\n\n        return props;\n    };\n\n    return to;\n}\n\nexport default getStep;\n","/**\n * Wraps an index within a given length, so that indexes greater than the length\n * loop back past 0, and indexes less than 0 loop backward from the length.\n * Similar to the indexing behaviour of `Array.slice`.\n *\n * @param {number} i The index to wrap.\n * @param {number} l The length to wrap the index within.\n *\n * @returns {number} The index wrapped within the length.\n */\nexport const wrapIndex = (i, l) => ((i%l)+l)%l;\n\n/**\n * Gives the entry at a wrapped index of a given list, never exceeds its bounds.\n *\n * @see wrapIndex\n *\n * @param {number} i The index to wrap.\n * @param {array} a A list to index (array or array-like object).\n * @param {number} a.length The length property of the given list.\n *\n * @returns {*} The entry at the wrapped index of the given list.\n */\nexport const wrapGet = (i, a) => a[wrapIndex(i, a.length)];\n\nexport const wrap = { index: wrapIndex, get: wrapGet };\n\nexport default wrap;\n","/**\n * GPGPU GLSL preprocessor macros for each part of the state.\n *\n * Careful defining these, as each set of different macros will result in new\n * shaders and compilations, missing the cache here and in the rendering system.\n * So, as few unique macros as possible should be created for a given set of\n * inputs, for efficiency.\n *\n * @todo Check examples are correct.\n * @todo Consider doing something better with indentation.\n */\n\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\nimport { type } from '@epok.tech/is-type/type';\n\nimport { preDef, boundDef } from './const';\n\nexport const rgba = 'rgba';\nexport const cache = {};\n\n// Keys for each part of the macro handling process available to hooks.\nexport const hooks = {\n    // The full set of macros.\n    macroPass: '',\n    // Each part of the set of macros.\n    macroValues: 'values', macroOutput: 'output',\n    macroSamples: 'samples', macroSamplesTap: 'tap'\n};\n\n/**\n * Whether macros should be handled here; or the result of handling them by a\n * given named hook.\n * Allows macros of the given key to be handled by external named hooks, to\n * replace any part of the functionality here.\n *\n * @example\n *     // Macros to be handled here, the default.\n *     hasMacros() === hasMacros({}) === hasMacros({ macros: true }) === null;\n *     // Macros to be handled here, with prefix `'pre_'` instead of `'preDef'`.\n *     hasMacros({ pre: 'pre_' }) === null;\n *     // Macros not created.\n *     hasMacros({ macros: false }) === hasMacros({ macros: 0 }) === '';\n *     // Macros for 'a' handled by external static hook, not here.\n *     hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'a') === '//A\\n';\n *     // Macros for 'b' handled by external function hook, not here.\n *     hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'b') === '//B\\n';\n *     // Macros specified `on` a 'frag' not created.\n *     hasMacros({ macros: { frag: 0 } }, '', 'frag') === '';\n *     // Macros specified `on` a 'vert' handled here.\n *     hasMacros({ macros: { frag: 0, a_vert: 0 } }, '', 'vert') === null;\n *     // Macros for hook `'a'` specified `on` a 'vert' not created.\n *     hasMacros({ macros: { frag: 0, a_vert: 0 } }, 'a', 'vert') === '';\n *\n * @param {object} [props] The properties handling macros.\n * @param {string} [key] The name for which macros should be handled.\n * @param {string} [on=''] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [macros=props.macros] Whether and how\n *     GLSL preprocessor macros should be handled:\n *     - If it's falsey and non-nullish, no macros are handled here.\n *     - If it's a string, no macros are handled here as it's used instead.\n *     - If it's a function, it's passed the given `props`, `key`, `macros`, and\n *         the returned result is interpreted in the same way as described.\n *     - If it's an object, any value at the given `key` is entered recursively,\n *         with the given `props`, `key`, and `macros[key]`.\n *     - Otherwise, returns `null` to indicate macros should be handled here.\n *\n * @returns {string|null|*} Either the result of the macros handled elsewhere,\n *     or `null` if macros should be handled here.\n */\nexport function hasMacros(props, key, on = '', macros = props?.macros) {\n    if((macros ?? true) === true) { return null; }\n    else if(!macros) { return ''; }\n\n    const t = type(macros);\n\n    return ((t === 'Function')? macros(props, key, on, macros)\n        : ((t === 'String')? macros\n        : (((macros instanceof Object) && (key in macros))?\n            hasMacros(props, key, on, macros[key])\n        : ((on)? hasMacros(props, (key || '')+(key && on && '_')+on, '', macros)\n        :   null))));\n}\n\n/**\n * Generates an array-like declaration, as a GLSL syntax string compatible with\n * all versions.\n * Workaround for lack of `const` arrays in GLSL < 3.\n * Used as the base for the other GLSL version list types, ensuring a standard\n * basis while offering further language features where available.\n *\n * @export\n * @example\n *     getGLSLListBase('float', 'list', [0, 1, 2], 'const'); // =>\n *     'const int list_l = 3; '+\n *     'const int list_0 = float(0); '+\n *     'const int list_1 = float(1); '+\n *     'const int list_2 = float(2);';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array-like declaration string.\n */\nexport const getGLSLListBase = (type, name, a, qualify = '', init = type) =>\n    `const int ${name}_l = ${a.length};`+\n    reduce((s, v, i) =>\n            `${s} ${(qualify && qualify+' ')+type} ${name}_${i} = ${\n                init}(${v.join?.(', ') ?? v});`,\n        a, '');\n\n/**\n * Generates an array-like declaration, as a GLSL 1 syntax string.\n * Workaround for lack of `const` arrays in GLSL < 3.\n * Adds a lookup macro function; slow here, but standard.\n *\n * @export\n * @example\n *     getGLSL1ListLike('float', 'list', [0, 1, 2], 'const'); // =>\n *     'const int list_l = 3; '+\n *     'const int list_0 = float(0); '+\n *     'const int list_1 = float(1); '+\n *     'const int list_2 = float(2);\\n'+\n *     '// `list_i` index macro (e.g: `list_i(0)`) may be slow, `+\n *         'prefer direct reference (e.g: `list_0`) where possible.\\n'+\n *     '#define list_i(i) ((i == 2)? list_2 : ((i == 1)? list_1 : list_0))\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array-like declaration string.\n */\nexport const getGLSL1ListLike = (type, name, a, qualify = '', init = type) =>\n    getGLSLListBase(type, name, a, qualify, init)+'\\n'+\n    // `#define ${name}_i(i) ${name}_##i`;\n    `// \\`${name}_i\\` index macro (e.g: \\`${name}_i(0)\\`) may be slow, `+\n        `prefer direct reference (e.g: \\`${name}_0\\`) where possible.\\n`+\n    `#define ${name}_i(i) ${reduce((s, v, i) =>\n            ((i)? `((i == ${i})? ${name}_${i} : ${s})` : `${name}_${i}`),\n        a, '')}\\n`;\n\n/**\n * Generates an array declaration, as a GLSL 1 syntax string.\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @export\n * @example\n *     getGLSL1ListArray('vec3', 'list', [[1, 0, 0], [0, 2, 0], [0, 0, 3]]);\n *     // =>\n *     'const int list_l = 3; '+\n *     'vec3 list_0 = vec3(1, 0, 0); '+\n *     'vec3 list_1 = vec3(0, 2, 0); '+\n *     'vec3 list_2 = vec3(0, 0, 3); '+\n *     'vec3 list[list_l]; '+\n *     'list[0] = list_0; '+\n *     'list[1] = list_1; '+\n *     'list[2] = list_2;\\n'+\n *     '#define list_i(i) list[i]\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array declaration string.\n */\nexport const getGLSL1ListArray = (type, name, a, qualify = '', init = type) =>\n    getGLSLListBase(type, name, a, qualify, init)+' '+\n    (qualify && qualify+' ')+`${type} ${name}[${name}_l];`+\n    reduce((s, _, i) => `${s} ${name}[${i}] = ${name}_${i};`, a, '')+'\\n'+\n    `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Generates an array declaration, as a GLSL 3 syntax string.\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @export\n * @example\n *     getGLSL3List('int', 'list', [0, 1, 2], 'const'); // =>\n *     'const int list_l = 3; '+\n *     'const int list_0 = int(0); '+\n *     'const int list_1 = int(1); '+\n *     'const int list_2 = int(2); '+\n *     'const int list[list_l] = int[list_l](list_0, list_1, list_2);\\n'+\n *     '#define list_i(i) list[i]\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 3 array declaration string.\n */\nexport const getGLSL3List = (type, name, a, qualify = '', init = type) =>\n    getGLSLListBase(type, name, a, qualify, init)+' '+\n    `${(qualify && qualify+' ')+type} ${name}[${name}_l] = ${init}[${name}_l](${\n        reduce((s, _, i) => (s && s+', ')+name+'_'+i, a, '')});\\n`+\n    `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Creates a GLSL definition of an array, and initialises it with the given\n * values, type, and variable name.\n * The initialisation is valid GLSL 1.0 or greater syntax; but is written with\n * escaped new-lines so it may be used in a single-line - e.g: for preprocessor\n * macros.\n * For a `qualify` of `const` on any `glsl` less than `3`, falls back to using\n * non-array variables with the index appended to `name`, since `const` arrays\n * aren't supported before GLSL 3.0.\n *\n * @example\n *     getGLSLList('int', 'test', [0, 1]); // =>\n *     'const int test_l = 2; '+\n *     'int test_0 = int(0); '+\n *     'int test_1 = int(1); '+\n *     'int test[test_l]; '+\n *     'test[0] = test_0; '+\n *     'test[1] = test_1;\\n'+\n *     '#define test_i(i) test[i]\\n';\n *\n *     getGLSLList('ivec2', 'vecs', [[1, 0], [0, 1]], 'const', 3); // =>\n *     'const int vecs_l = 2; '+\n *     'ivec2 vecs_0 = ivec2(1, 0); '+\n *     'ivec2 vecs_1 = ivec2(0, 1); '+\n *     'const ivec2 vecs[vecs_l] = ivec2[vecs_l](vecs_0, vecs_1);\\n'+\n *     '#define vecs_i(i) vecs[i]\\n';\n *\n *     getGLSLList('int', 'listLike', [0, 1], 'const', 1); // =>\n *     'const int listLike_l = 2; '+\n *     'const int listLike_0 = int(0); '+\n *     'const int listLike_1 = int(1);\\n'+\n *     '// `listLike_i` index macro (e.g: `listLike_i(0)`) may be slow, `+\n *         'prefer direct reference (e.g: `listLike_0`) where possible.\\n'+\n *     '#define listLike_i(i) ((i == 1)? listLike_1 : listLike_0)\\n';\n *\n * @export\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed (e.g: `const`).\n * @param {number} [glsl=1] The GLSL version to target, if specified.\n * @param {string} [init] A data-type initialiser.\n *\n * @returns {string} The GLSL (1 or 3) array or array-like declaration string.\n */\nexport const getGLSLList = (type, name, a, qualify = '', glsl = 1, init) =>\n    ((glsl >= 3)? getGLSL3List\n    : ((qualify.trim() === 'const')? getGLSL1ListLike\n    :   getGLSL1ListArray))(type, name, a, qualify, init);\n\n/**\n * Defines the values within textures per-step, as GLSL preprocessor macros.\n * These macros define mappings from values to their textures and channels.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     macroValues({\n *         steps: Array(2),\n *         maps: mapGroups({ values: [4, 2, 1], texturesMax: 1 })\n *     }); // =>\n *     '#define texture_0 0\\n'+ // Value 0's texture.\n *     '#define channels_0 rgba\\n'+ // Value 0's channels.\n *     '\\n'+\n *     '#define texture_1 1\\n'+ // Value 1's texture.\n *     '#define channels_1 rg\\n'+ // Value 1's channels.\n *     '\\n'+\n *     '#define texture_2 1\\n'+ // Value 2's texture.\n *     '#define channels_2 b\\n'+ // Value 2's channels.\n *     '\\n'+\n *     // General metadata.\n *     '#define textures 2\\n'+\n *     '#define passes 2\\n'+\n *     '#define stepsPast 1\\n'+\n *     '#define steps 2\\n';\n *\n * @export\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled\n *     or prefixed. See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step.\n * @param {array<number>} state.maps.values How values of each data item are\n *     grouped into textures. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures The groupings of values\n *     into textures. See `mapGroups`.\n * @param {array} state.maps.passes The passes drawn per-step. See `mapGroups`.\n * @param {array} state.steps The states drawn across frames. See `getState`.\n * @param {number} [state.bound=boundDef] How many steps are bound as outputs,\n *     unavailable as inputs.\n * @param {object} [state.size] Any size information about the GL resources.\n * @param {number} [state.size.count] The number of data entries per texture\n *     (the texture's area), if given. See `getState`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings from\n *     values to textures/channels.\n */\nexport function macroValues(state, on) {\n    const key = hooks.macroValues;\n    const hook = hasMacros(state, key, on);\n\n    if(hook !== null) { return hook; }\n\n    const { maps, steps, bound = boundDef, size, pre: n = preDef } = state;\n    const { values, textures, passes: { length: passesL } } = maps;\n    const stepsL = steps.length;\n    const count = size?.count;\n\n    const c = key+':'+\n        JSON.stringify({ n, bound, values, textures, stepsL, passesL, count });\n\n    return (cache[c] ??=\n        reduce((s, texture, t, _, i = 0) => reduce((s, v) => s+\n                    `#define ${n}texture_${v} ${t}\\n`+\n                    `#define ${n}channels_${v} ${\n                        rgba.slice(i, (i += values[v]))}\\n\\n`,\n                texture, s),\n            textures, '')+\n        ((count)? `#define count ${count}\\n` : '')+\n        `#define ${n}textures ${textures.length}\\n`+\n        `#define ${n}passes ${passesL}\\n`+\n        `#define ${n}stepsPast ${stepsL-bound}\\n`+\n        `#define ${n}steps ${stepsL}\\n`);\n}\n\n/**\n * Defines the outputs being drawn to per-pass, as GLSL preprocessor macros.\n * These macros define mappings from values to their outputs, if bound.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const state = {\n *         passNow: 0, maps: mapGroups({ values: [4, 2, 1], texturesMax: 1 })\n *     };\n *\n *     macroOutput(state); // =>\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_0 0\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rgba\\n';\n *\n *     ++state.passNow;\n *\n *     macroOutput(state); // =>\n *     '#define passNow 1\\n'+\n *     '\\n'+\n *     '#define bound_1 1\\n'+\n *     '#define attach_1 0\\n'+\n *     '#define output_1 gl_FragData[attach_1].rg\\n'+\n *     '\\n'+\n *     '#define bound_2 1\\n'+\n *     '#define attach_2 0\\n'+\n *     '#define output_2 gl_FragData[attach_2].b\\n';\n *\n * @export\n * @param {object} state Properties for generating the macros. See `getState`:\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *     See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `pre` if not given.\n * @param {number} state.passNow The index of the currently active pass.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<number>} state.maps.values How values of each data item may be\n *     grouped into textures across passes. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures The groupings of values\n *     into textures. See `mapGroups`.\n * @param {array<array<number>>} state.maps.passes The groupings of textures\n *     into passes. See `mapGroups`.\n *\n * @returns {string} The GLSL preprocessor macros defining the bound outputs.\n */\nexport function macroOutput(state, on) {\n    const key = hooks.macroOutput;\n    const hook = hasMacros(state, key, on);\n\n    if(hook !== null) { return hook; }\n\n    const { passNow: p, maps, pre: n = preDef } = state;\n    const { values, textures, passes } = maps;\n    const pass = passes[p];\n    const c = key+':'+JSON.stringify({ n, p, values, textures, passes });\n\n    return (cache[c] ??=\n        `#define ${n}passNow ${p}\\n`+\n        reduce((s, texture, bound, _, i = 0) => reduce((s, v) => `${s}\\n`+\n                    `#define ${n}bound_${v} ${texture}\\n`+\n                    `#define ${n}attach_${v} ${bound}\\n`+\n                    `#define ${n}output_${v} gl_FragData[${n}attach_${v}].${\n                        rgba.slice(i, (i += values[v]))}\\n`,\n                textures[texture], s),\n            pass, ''));\n}\n\n/**\n * Defines the texture samples/reads per-pass, as GLSL preprocessor macros.\n * The macros define the mapping between the values and the minimum texture\n * samples for the data they derive from. They're set up as function-like macros\n * that may be called from the shader to initialise the mappings arrays with a\n * given name.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see getGLSLList\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [mapSamples]{@link ./maps.js#mapSamples}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     macroSamples({\n *         passNow: 0,\n *         maps: mapSamples(mapGroups({\n *             values: [4, 2, 1], channelsMax: 4, texturesMax: 1,\n *             derives: [[1, 0], , [3, [1, 0]]]\n *         }))\n *     }); // =>\n *     '#define useSamples '+\n *         'const int samples_l = 2; '+\n *         'const ivec2 samples_0 = ivec2(0, 1); '+\n *         'const ivec2 samples_1 = ivec2(0, 0);\\n'+\n *     '// `samples_i` index macro (e.g: `samples_i(0)`) may be slow, `+\n *         'prefer direct reference (e.g: `samples_0`) where possible.\\n'+\n *     '#define samples_i(i) ((i == 1)? samples_1 : samples_0)\\n'+\n *     '\\n'+\n *     '#define tapSamples(states, uv, textures, by) '+\n *         'const int data_l = 2; '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = texture2D('+\n *             'states[((samples_0.s+by.s)*textures)+samples_0.t+by.t], uv); '+\n *         'data[1] = texture2D('+\n *             'states[((samples_1.s+by.s)*textures)+samples_1.t+by.t], uv); '+\n *         '// `data_i` index macro (e.g: `data_i(0)`) may be slow, `+\n *             'prefer direct reference (e.g: `data_0`) where possible.\\n'+\n *         '#define data_i(i) data[i]\\n'+\n *     '#define tapSamples(states, uv, textures) '+\n *         'tapSamplesShift(states, uv, textures, ivec2(0))\\n'+\n *     '\\n'+\n *     '#define useReads_0 '+\n *         'const int reads_0_l = 2; '+\n *         'const int reads_0_0 = int(0); '+\n *         'const int reads_0_1 = int(1);\\n'+\n *     '// `reads_0_i` index macro (e.g: `reads_0_i(0)`) may be slow, `+\n *         'prefer direct reference (e.g: `reads_0_0`) where possible.\\n'+\n *     '#define reads_0_i(i) ((i == 1)? reads_0_1 : reads_0_0)\\n';\n *\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *     See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {number} state.passNow The index of the currently active pass.\n * @param {object} state.maps  How `values` are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<array<number>>>} [state.maps.samples] The minimal set of\n *     texture samples to use. See `mapSamples`.\n * @param {array<array<array<number>>>} [state.maps.reads] The mappings from\n *     values to the corresponding `state.samples`. See `mapSamples`.\n * @param {number} [state.glsl=1] The GLSL language version. See `getGLSLList`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings for\n *     samples and reads, for each value.\n */\nexport function macroSamples(state, on) {\n    const key = hooks.macroSamples;\n    const hook = hasMacros(state, key, on);\n\n    if(hook !== null) { return hook; }\n\n    const { passNow: p = 0, maps, glsl, pre: n = preDef } = state;\n    const { samples, reads } = maps;\n    const passSamples = samples?.[p];\n    const passReads = reads?.[p];\n    // Whether to generate GLSL preprocessor macros for the lookup logic.\n    const tap = hasMacros(state, hooks.macroSamplesTap, on);\n\n    const c = key+':'+\n        JSON.stringify({ n, p, passSamples, passReads, glsl, tap });\n\n    return (cache[c] ??=\n        ((!passSamples)? ''\n        :   `#define ${n}useSamples ${\n                getGLSLList('ivec2', n+'samples', passSamples, 'const', glsl)\n            }\\n`+\n            // The texture-sampling logic.\n            (tap ??\n                // Data may be sampled by adding step/texture lookup shifts.\n                `#define ${n}tapSamplesShift(states, uv, textures, by) ${\n                    // 2D-to-1D indexing, as textures are a flat array.\n                    getGLSLList('vec4', n+'data',\n                        map((_, s) =>\n                                'texture2D(states['+\n                                        `((${n}samples_${s}.s+by.s)*textures)+`+\n                                        `${n}samples_${s}.t+by.t`+\n                                    '], uv)',\n                            passSamples),\n                        '', glsl)}\\n`+\n                // Data is usually sampled without step/texture lookup shifts.\n                `#define ${n}tapSamples(states, uv, textures) `+\n                    n+'tapSamplesShift(states, uv, textures, ivec2(0))\\n\\n'))+\n        ((!passReads)? ''\n        :   reduce((s, reads, v) =>\n                    `${s}#define ${n}useReads_${v} ${\n                        getGLSLList('int', n+'reads_'+v, reads, 'const', glsl)\n                    }\\n`,\n                passReads, '')));\n}\n\n/**\n * Defines all GLSL preprocessor macro values, texture samples, and outputs for\n * the active pass.\n * The macros define the mapping between the active values, their textures and\n * channels, bound outputs, and other macros useful for a draw pass.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see macroValues\n * @see macroOutput\n * @see macroSamples\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const state = {\n *         steps: Array(2), passNow: 0,\n *         maps: mapSamples(mapGroups({\n *             values: [4, 2, 3], channelsMax: 4, texturesMax: 1,\n *             derives: [[1, 0], [2, [1, 0]]]\n *         }))\n *     };\n *\n *     macroPass(state); // =>\n *     '#define texture_0 0\\n'+\n *     '#define channels_0 rgba\\n'+\n *     '\\n'+\n *     '#define texture_1 1\\n'+\n *     '#define channels_1 rg\\n'+\n *     '\\n'+\n *     '#define texture_2 2\\n'+\n *     '#define channels_2 rgb\\n'+\n *     '\\n'+\n *     '#define textures 3\\n'+\n *     '#define passes 3\\n'+\n *     '#define steps 2\\n'+\n *     '\\n'+\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_0 0\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rgba\\n'+\n *     '\\n'+\n *     '#define useSamples '+\n *         'const int samples_l = 2; '+\n *         'const ivec2 samples_0 = ivec2(0, 1); '+\n *         'const ivec2 samples_1 = ivec2(0, 0);\\n'+\n *     '#define samples_i(i) ((i == 1)? samples_1 : samples_0)\\n'+\n *     '\\n'+\n *     '#define tapSamples(states, uv, textures) '+\n *         'const int data_l = 2; '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = texture2D(states[(0*textures)+1], uv); '+\n *         'data[1] = texture2D(states[(0*textures)+0], uv);\\n'+\n *         '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define useReads_0 '+\n *         'const int reads_0_l = 2; '+\n *         'const int reads_0_0 = int(0); '+\n *         'const int reads_0_1 = int(1);\\n'+\n *     '#define reads_0_i(i) ((i == 1)? reads_0_1 : reads_0_0)\\n';\n *\n *     ++state.passNow;\n *     state.pre = 'draw_';\n *     state.steps.push(null);\n *     Object.assign(state.maps, mapSamples(mapGroups({\n *         values: [4, 2, 3, 1], channelsMax: 4, texturesMax: 2,\n *         derives: [[1, 0], , [2, [1, 0]]]\n *     })));\n *\n *     macroPass(state); // =>\n *     '#define draw_texture_0 0\\n'+\n *     '#define draw_channels_0 rgba\\n'+\n *     '\\n'+\n *     '#define draw_texture_1 1\\n'+\n *     '#define draw_channels_1 rg\\n'+\n *     '\\n'+\n *     '#define draw_texture_2 2\\n'+\n *     '#define draw_channels_2 rgb\\n'+\n *     '\\n'+\n *     '#define draw_texture_3 2\\n'+\n *     '#define draw_channels_3 a\\n'+\n *     '\\n'+\n *     '#define draw_textures 3\\n'+\n *     '#define draw_passes 2\\n'+\n *     '#define draw_steps 3\\n'+\n *     '\\n'+\n *     '#define draw_passNow 1\\n'+\n *     '\\n'+\n *     '#define draw_bound_2 2\\n'+\n *     '#define draw_attach_2 0\\n'+\n *     '#define draw_output_2 gl_FragData[draw_attach_2].rgb\\n'+\n *     '\\n'+\n *     '#define draw_bound_3 2\\n'+\n *     '#define draw_attach_3 0\\n'+\n *     '#define draw_output_3 gl_FragData[draw_attach_3].a\\n'+\n *     '\\n'+\n *     '#define draw_useSamples '+\n *         'const ivec2 draw_samples_0 = ivec2(0, 2); '+\n *         'const ivec2 draw_samples_1 = ivec2(1, 0); '+\n *         'const int draw_samples_l = 2;\\n'+\n *     '#define draw_samples_i(i) '+\n *         '((i == 1)? draw_samples_1 : draw_samples_0)\\n'+\n *     '\\n'+\n *     '#define draw_tapSamples(states, uv, textures) '+\n *         'const int data_l = 2; '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = texture2D(states[(0*textures)+2], uv); '+\n *         'data[1] = texture2D(states[(1*textures)+0], uv);\\n'+\n *         '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define draw_useReads_2 '+\n *         'const int draw_reads_2_l = 2; '+\n *         'const int draw_reads_2_0 = int(0); '+\n *         'const int draw_reads_2_1 = int(1);\\n'+\n *     '#define draw_reads_2_i(i) '+\n *         '((i == 1)? draw_reads_2_1 : draw_reads_2_0)\\n';\n *\n * @export\n * @param {object} state Properties for generating the macros. See `getState`\n *     and `mapGroups`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings for\n *     values, textures, channels, bound outputs of the active pass, etc. See\n *     `macroValues`, `macroOutput`, and `macroSamples`.\n */\nexport const macroPass = (state, on) =>\n    (hasMacros(state, hooks.macroPass, on) ??\n        macroValues(state)+'\\n'+macroOutput(state)+'\\n'+macroSamples(state));\n\nexport default macroPass;\n","const [{ length: start}, { length: end }] = '[object {type}]'.split('{type}');\n\n/**\n * Gives the type of a given input.\n *\n * @see https://stackoverflow.com/a/17772086/716898\n *\n * @param {*} x Any input to test.\n *\n * @returns {string} The type of `x`.\n */\nexport const type = (x) => toString.call(x).slice(start, -end);\n\nexport default type;\n","/**\n * GPGPU inputs (uniforms, attributes, indexes, etc).\n */\n\nimport { setC2 } from '@thi.ng/vectors/setc';\nimport map from '@epok.tech/fn-lists/map';\nimport range from '@epok.tech/fn-lists/range';\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap-index';\n\nimport { boundDef, preDef } from './const';\n\n/**\n * Common uniform inputs for GPGPU `step` and `draw`.\n * Uniforms are defined as callback hooks pulling from given `context` and\n * `props` properties, allowing different APIs or author-defined hooks.\n *\n * @see [getState]{@link ./state.js#getState}\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n *\n * @export\n * @param {object} state The GPGPU state to use. See `getState` and `mapGroups`.\n * @param {array} state.steps The steps of state. See `getState`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures How values are grouped into\n *     textures. See `mapGroups`.\n * @param {number} [state.bound=boundDef] How many steps are bound as outputs,\n *     unavailable as inputs.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n * @param {object} [to=(state.uniforms ?? {})] The object to contain the\n *     uniforms; `state.uniforms` or a new object if not given.\n *\n * @returns {object<function>} `to` The uniform hooks for the given `state`.\n *     Each is a function taking 2 arguments: a `context` object of general\n *     or global properties, and a `props` object of local properties (such as\n *     the given `state`).\n */\nexport function getUniforms(state, to = (state.uniforms ?? {})) {\n    const {\n            steps: { length: stepsL }, maps: { textures: textureMap },\n            bound = boundDef, pre: n = preDef\n        } = state;\n\n    const texturesL = textureMap.length;\n    const cache = { viewShape: [] };\n\n    to[n+'stepNow'] = (_, { stepNow: s }) => s;\n    to[n+'dataShape'] = (_, { size: { shape: s } }) => s;\n    to[n+'viewShape'] = ({ viewportWidth: w, viewportHeight: h }) =>\n        setC2(cache.viewShape, w, h);\n\n    // Set up the past steps, as the number of steps into the past from the\n    // currently bound step ([1...(steps-1)]).\n\n    const addTexture = (past, texture) =>\n        // Hook to pull a given texture from the latest `props`.\n        to[`${n}states[${(past*texturesL)+texture}]`] =\n            (_, { stepNow: s, bound: b = bound, textures }) =>\n                wrap.get(s-b-past, textures)[texture].texture;\n\n    // Flatten all input textures, as uniforms are stored in flat arrays.\n    for(let past = 0, pl = stepsL-bound; past < pl; ++past) {\n        each((v, texture) => addTexture(past, texture), textureMap);\n    }\n\n    return to;\n}\n\n/**\n * Gives the number of indexes to draw a full state, for various parameters.\n *\n * @see [getState]{@link ./state.js#getState}\n *\n * @param {object|array<number>|number} size Size/type information of data\n *     resources, or a shape array of width and height numbers, or width if\n *     height is given as a second parameter.\n * @param {number} [size.count] The number of entries of each data-texture.\n * @param {number} [size[0]] The width of each data-texture.\n * @param {number} [size[1]] The height of each data-texture.\n * @param {number} [size.width] The width of each data-texture.\n * @param {number} [size.height] The height of each data-texture.\n * @param {number} [size.x] The width of each data-texture.\n * @param {number} [size.y] The height of each data-texture.\n * @param {number} [size.shape] The shape of each data-texture.\n * @param {number} [size.shape[0]] The width of each data-texture.\n * @param {number} [size.shape[1]] The height of each data-texture.\n *\n * @param {number} [height] The height of each data-texture.\n *\n * @returns {number} The number of indexes needed to draw a full state; each\n *     entry of a data-texture (its area, equivalent to `state.size.count`).\n */\nexport const countDrawIndexes = (size, height) => (size.count ??\n    ((size[0] ?? size.width ?? size.x ?? size.shape?.[0] ?? size)*\n        (size[1] ?? size.height ?? size.y ?? size.shape?.[1] ?? height)));\n\n/**\n * Gives the array of indexes needed to draw a full state.\n *\n * @param {number|object<number>} size The number of entries in each\n *     data-texture; or an object of size/type information on data resources.\n *\n * @returns {array<number>} An array of indexes for drawing all data-texture\n *     entries.\n */\nexport const getDrawIndexes = (size) => map((v, i) => i,\n    range(Number.isInteger(size)? size : countDrawIndexes(size)), 0);\n","export const setC2 = (out, x, y) => (!out && (out = []), (out[0] = x), (out[1] = y), out);\nexport const setC3 = (out, x, y, z) => (!out && (out = []), (out[0] = x), (out[1] = y), (out[2] = z), out);\nexport const setC4 = (out, x, y, z, w) => (!out && (out = []),\n    (out[0] = x),\n    (out[1] = y),\n    (out[2] = z),\n    (out[3] = w),\n    out);\nexport const setC6 = (out, a, b, c, d, e, f) => (!out && (out = []),\n    (out[0] = a),\n    (out[1] = b),\n    (out[2] = c),\n    (out[3] = d),\n    (out[4] = e),\n    (out[5] = f),\n    out);\nexport const setC = (out, ...xs) => {\n    !out && (out = []);\n    for (let i = 0, n = xs.length; i < n; i++) {\n        out[i] = xs[i];\n    }\n    return out;\n};\n","/**\n * How many vertexes for pairs of line segments linking each entry's states,\n * using `gl.LINES`.\n * If fewer than 2 states are given, lines can't be drawn, assumes `gl.POINTS`.\n * Every pair of indexes is a line-segment connecting each state to its past\n * state, making one continuous line back through steps using `gl.LINES`;\n * iterating each start index and its past index.\n * Corresponds to the indexing logic in the `indexPairs` GLSL function.\n *\n * @see [readme]{@link ./readme.md}\n * @see `gl.LINES` at https://webglfundamentals.org/webgl/lessons/webgl-points-lines-triangles.html\n * @see [indexPairs]{@link ./index.glsl#indexPairs}\n *\n * @param {number} states The number of steps of state to link by pairs of line\n *     segments.\n *\n * @returns {number} The number of points needed to link all steps of state\n *     by pairs of line segments. May be multiplied with the number of entries\n *     in each step.\n */\nexport const indexPairs = (states) => Math.max(1, (states-1)*2);\n\nexport default indexPairs;\n","/**\n * The update step for a GPGPU particle simulation.\n * Requires setup with preprocessor macros - see `macroPass`.\n *\n * @see [getStep]{@link ../../step.js#getStep}\n * @see [macroPass]{@link ../../macros.js#macroPass}\n */\n\n#ifdef GL_EXT_draw_buffers\n    #extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\n\n// Setting up the macros and aliases.\n// Note that these `texture_i`/`channels_i`/`reads_i_j` indexes correspond to\n// the value at that index in the `values`/`derives` arrays provided to `gpgpu`;\n// they are defined here to match the arrangement in `./index.js`.\n\n#define posChannels channels_0\n#define lifeChannels channels_1\n#define accChannels channels_2\n\nuseSamples\n\n#ifdef output_0\n    #define posOutput output_0\n    useReads_0\n    #define posReadPos0 reads_0_0\n    #define posReadPos1 reads_0_1\n    #define posReadAcc reads_0_2\n    #define posReadLife reads_0_3\n#endif\n#ifdef output_1\n    #define lifeOutput output_1\n    useReads_1\n    #define lifeReadLifeOldest reads_1_0\n    #define lifeReadLife1 reads_1_1\n#endif\n#ifdef output_2\n    #define accOutput output_2\n    useReads_2\n    #define accReadAcc reads_2_0\n    #define accReadLife reads_2_1\n#endif\n\n// The main shader.\n\n// States from `gl-gpgpu`.\nuniform sampler2D states[stepsPast*textures];\nuniform vec2 dataShape;\n// Custom inputs for this demo.\nuniform float dt;\nuniform float time;\nuniform float loop;\nuniform vec2 lifetime;\nuniform vec2 force;\nuniform float useVerlet;\nuniform vec3 g;\nuniform vec3 source;\n\nvarying vec2 uv;\n\n#pragma glslify: map = require(glsl-map);\n\n#ifdef posOutput\n    #pragma glslify: verlet = require(@epok.tech/glsl-verlet);\n#endif\n\n#if defined(lifeOutput) || defined(accOutput)\n    #pragma glslify: random = require(glsl-random);\n#endif\n\n#ifdef accOutput\n    #pragma glslify: tau = require(glsl-constants/TWO_PI);\n\n    // @see https://observablehq.com/@rreusser/equally-distributing-points-on-a-sphere\n    vec3 randomOnSphere(vec2 randoms) {\n        float a = randoms[0]*tau;\n        float u = (randoms[1]*2.0)-1.0;\n\n        return vec3(sqrt(1.0-(u*u))*vec2(cos(a), sin(a)), u);\n    }\n#endif\n\n#pragma glslify: le = require(glsl-conditionals/when_le);\n\nvoid main() {\n    // Sample textures.\n    // Add pixel offset to sample from the pixel's center and avoid errors.\n    vec2 st = uv+(vec2(0.25)/dataShape);\n\n    // Sample the desired state values - creates the `data` array.\n    tapSamples(states, st, textures)\n\n    // Read values.\n\n    #ifdef posOutput\n        vec3 pos0 = data[posReadPos0].posChannels;\n    #endif\n    #if defined(lifeOutput) || defined(posOutput)\n        vec3 pos1 = data[posReadPos1].posChannels;\n    #endif\n\n    #if defined(lifeOutput) || defined(posOutput) || defined(accOutput)\n        #if defined(posOutput)\n            #define readLife posReadLife\n        #elif defined(lifeOutput)\n            #define readLife lifeReadLife\n        #elif defined(accOutput)\n            #define readLife accReadLife\n        #endif\n\n        float life = data[readLife].lifeChannels;\n        float spawn = le(life, 0.0);\n    #endif\n\n    #if defined(lifeOutput)\n        float lifeOldest = data[lifeReadLifeOldest].lifeChannels;\n    #endif\n\n    #if defined(posOutput) || defined(accOutput)\n        #if defined(posOutput)\n            #define readAcc posReadAcc\n        #elif defined(accOutput)\n            #define readAcc accReadAcc\n        #endif\n\n        vec3 acc = data[readAcc].accChannels;\n    #endif\n\n    // Output updated values.\n    #ifdef posOutput\n        // Use either Euler or Verlet integration.\n        vec3 pos = mix(pos1+(acc*dt), verlet(acc, pos0, pos1, dt), useVerlet);\n\n        posOutput = mix(pos, source, spawn);\n    #endif\n    #ifdef lifeOutput\n        life = max(0.0, life-dt);\n\n        float lifeSpawn = map(random(uv*loop),\n            0.0, 1.0, lifetime[0], lifetime[1]);\n\n        // Only spawn life once the oldest step reaches the end of its lifetime\n        // (past and current life are both 0).\n        lifeOutput = mix(life, lifeSpawn, spawn*le(lifeOldest, 0.0));\n    #endif\n    #ifdef accOutput\n        // To help accuracy of very small numbers, pass force as `[X, Y] = XeY`.\n        float f = force.x*pow(10.0, force.y);\n\n        acc += g*f*dt;\n\n        vec2 randoms = vec2(random((uv+loop)/dt), random((uv-loop)*dt));\n        vec3 accSpawn = randomOnSphere(randoms)*random(loop-(uv*dt))*f*5e3;\n\n        accOutput = mix(acc, accSpawn, spawn);\n    #endif\n}\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see [macroPass]{@link ../../macros.js#macroPass}\n * @see [macroValues]{@link ../../macros.js#macroValues}\n */\n\nprecision highp float;\n\n#define posChannels channels_0\n#define lifeChannels channels_1\n#define accChannels channels_2\nuseSamples\n// Only the first value derives from all values, giving these minimal `reads`.\nuseReads_0\n#define readPos reads_0_0\n#define readLife reads_0_1\n#define readAcc reads_0_2\n\nattribute float index;\n\nuniform sampler2D states[stepsPast*textures];\nuniform vec2 dataShape;\nuniform vec2 viewShape;\nuniform float pointSize;\nuniform vec2 lifetime;\nuniform vec2 force;\nuniform float dt;\nuniform float scale;\n\nvarying vec4 color;\n\n#pragma glslify: aspect = require(@epok.tech/glsl-aspect/contain)\n#pragma glslify: gt = require(glsl-conditionals/when_gt)\n\n#if stepsPast > 1\n    #pragma glslify: indexPairs = require(../../index-pairs)\n#endif\n\nvoid main() {\n    #if stepsPast > 1\n        // If multiple steps are given, use `gl.LINES`, shift into past steps.\n        vec2 stepEntry = indexPairs(index, float(stepsPast));\n        float stepPast = stepEntry.s;\n        float entry = stepEntry.t;\n        ivec2 stepShift = ivec2(int(stepPast), 0);\n    #else\n        // If only 1 step is given, use `gl.POINTS`, no shift into past steps.\n        ivec2 stepShift = ivec2(0);\n        float stepPast = 0.0;\n        float entry = index;\n    #endif\n\n    // Turn the 1D index into a 2D texture UV.\n    // Add pixel offset to sample from the pixel's center and avoid errors.\n    vec2 uv = vec2(mod(entry+0.25, dataShape.x)/dataShape.x,\n        (floor(entry/dataShape.x)+0.25)/dataShape.y);\n\n    // Can also use the `reads` logic to take the minimum possible samples here.\n    // Sample the desired state values - creates the `data` array.\n    tapSamplesShift(states, uv, textures, stepShift)\n\n    // Read values.\n    vec3 pos = data[readPos].posChannels;\n    float life = data[readLife].lifeChannels;\n    vec3 acc = data[readAcc].accChannels;\n\n    float alive = gt(life, 0.0);\n    vec2 ar = aspect(viewShape);\n    vec4 vertex = vec4(vec3(pos.xy*ar, pos.z)*scale, 1.0);\n\n    gl_Position = alive*vertex;\n    gl_PointSize = alive*pointSize*clamp(1.0-(vertex.z/vertex.w), 0.1, 1.0);\n\n    float a = pow(life/lifetime[1], 0.1);\n\n    color = a*vec4(stepPast/float(stepsPast), entry/float(count),\n        (length(acc)/(force.x*pow(10.0, force.y)*dt))*scale, a);\n}\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see [macroPass]{@link ../../macros.js#macroPass}\n * @see [macroValues]{@link ../../macros.js#macroValues}\n */\n\nprecision highp float;\n\nvarying vec4 color;\n\nvoid main() { gl_FragColor = color; }\n"],"names":["_console","ref","ref1","reglProps","pixelRatio","Math","max","floor","devicePixelRatio","extensions","$hBMe5","extensionsFloat","optionalExtensions","regl","self","$parcel$interopDefault","$3Cmit","console","log","$ksHHi","default","o","e","hasExtension","canvas","document","querySelector","classList","add","valuesMap","Map","set","values","$kxEDL","_limits","limits","maxTextureUnits","maxTextureSize","steps","s","v","scale","log2","query","URLSearchParams","location","search","$lKPpF","apply","parseInt","get","concat","stepsPast","scale1","hasTimestep","has","timestepDef","timestep","parseFloat","entries","flat","href","delete","valuesIndex","k","i","keys","derives","position","min","acceleration","life","canVerlet","cache","state","$e3wLf","gpgpu","props","timer","$8g7pT","step","now","rate","loop","useVerlet","lifetime","g","source","force","bound","maps","macros","vert","frag","$jYFPA","frags","uniforms","dt","_","param","_props","time","sin","PI","prop","$9pabq","u","drawCount","$gyl7y","countDrawIndexes","size","$i7NAh","length","drawIndexes","getDrawIndexes","drawState","$9BYky","output","$4MXss","getMaps","texturesMax","drawCommand","$1tr74","macroPass","$57MSl","$7Lnkd","attributes","index","getUniforms","pointSize","lineWidth","count","depth","enable","blend","func","src","dst","primitive","draw","clearView","color","frame","run","stepNow","clear","addEventListener","stopPropagation","preventDefault","x","clientX","y","clientY","innerWidth","innerHeight","module","hot","accept","call","reload","obj","key","value","Object","defineProperty","enumerable","configurable","writable","target","arguments","ownKeys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","forEach","$gHSxu","arr","$km6mS","$3rVPa","$iWEHp","Array","isArray","iter","Symbol","iterator","prototype","toString","from","TypeError","$kJ5JC","$f24YN","arr2","exports","$60359228a7d3fb28$export$be3f796aed065412","diff","pause","$60359228a7d3fb28$export$7548f4bc1b09ff22","$60359228a7d3fb28$export$85b884786400d38f","$60359228a7d3fb28$export$eb8a9b7a1ebec59a","Date","$60359228a7d3fb28$export$2e2bcd8739ae039","out","t0","n","_step","t","t1","isNaN","$ee5851911330bf41$var$r","reduce","$ee5851911330bf41$export$533b26079ad0b4b","f","a","undefined","$ee5851911330bf41$export$2e2bcd8739ae039","$6d8e5906de1cf303$export$2e2bcd8739ae039","out1","_maps1","$a3bac22a2cec4520$export$a8489f67fe30ef76","api","param1","to","maxDrawbuffers","glsl","_maps","match","_texturesMax","$20H3c","getState","$4NSvD","getStep","_cache","_reads","_passReads","$37c9c43fd5907c13$export$69a3209f1a06c04d","$37c9c43fd5907c13$export$5ca26c99531348ec","channelsMax","channelsMaxDef","error","$37c9c43fd5907c13$export$96707a1f51900f3d","param2","to1","_values","valuesDef","_channelsMax","texturesMaxDef","_packed","packed","channels","fitIndex","fitSize","Infinity","i1","fit","pack","$37c9c43fd5907c13$export$9d1d9285bd6d8c57","passes","textures","valueToTexture","valueToPass","textureToPass","getValue","p","pass","texture","push","$37c9c43fd5907c13$export$574963e692b662ec","param3","reads","all","getAddSample","derive","d","Number","isFinite","findIndex","_param","passReads","_pass","_value","samples","valueDerives","getAddSamples","$37c9c43fd5907c13$export$e8886fdb6718f96","$6f535731e26073af$var$e","$6f535731e26073af$export$2e2bcd8739ae039","$cd1b4d1540633814$export$ac0cd3cc21f80dfc","$cd1b4d1540633814$export$4bceda1224fc5ab8","$cd1b4d1540633814$export$b4781c2237bde956","$cd1b4d1540633814$export$26945b8c914b7fc","$cd1b4d1540633814$export$154f256b9eac9103","$cd1b4d1540633814$export$4d253b84ce5f5f8e","$cd1b4d1540633814$export$b029aceb5666f022","$cd1b4d1540633814$export$71c6d8e332d66a75","$cd1b4d1540633814$export$617a37502ff8853","$cd1b4d1540633814$export$27fb0dad99ae5dd2","$cd1b4d1540633814$export$ff01eb58fe4e69","$cd1b4d1540633814$export$cfdc3a7c4cb854c6","$OvAQZ","positions","$097d2d6ba61fde6a$export$ba60520149d1328e","$097d2d6ba61fde6a$export$878041e1e4cd4218","_textures","_passes","$176cf9cb32bd006b$export$50fdfeece43146fd","framebuffer","radius","width","height","_scale","scaleDef","_type","type","typeDef","_steps","stepsDef","passNow","_channelsMin","channelsMin","channelsMinDef","texturesMap","_length","textureProps1","mag","wrap","pow","w","h","shape","textures1","passes1","addPass","passProps","max1","textureProps","_step1","map","addTexture","stencil","$88hlK","$5ebc876929a0439f$export$2e2bcd8739ae039","start","end","fill","_step2","_obj","$37f6056e300b6832$var$scale","$37f6056e300b6832$export$89e7bec3b8bce705","buffer","_command","command","_pre","pre","preDef","step1","_positions","positionsDef","_vert","$dAkAi","verts","_count","stateCache","$9yAa9","passCommand","tmp","tmp1","vs","tmp2","fs","ss","$6qjSx","wrapGet","onPass","onStep","$4ad49746d3e88695$export$acb6ab09ed1b7b8b","l","$4ad49746d3e88695$export$ea134dcc07e79c49","$4ad49746d3e88695$export$2e2bcd8739ae039","_cache1","_cache2","$112d87fa33ebb5f5$export$4e46ac54fc82cf3b","$112d87fa33ebb5f5$export$69a3209f1a06c04d","$112d87fa33ebb5f5$export$11949c6f5fba7dcd","$112d87fa33ebb5f5$export$feaf5ffc92c2af94","on","$ayMqI","$112d87fa33ebb5f5$export$83d01c7b88bc16d5","name","qualify","init","ref2","join","$112d87fa33ebb5f5$export$45db4de6da38aa8d","$112d87fa33ebb5f5$export$3df19e70a88cb8cd","param4","$112d87fa33ebb5f5$export$1c7039c93eddfba","param5","$112d87fa33ebb5f5$export$c346962e7dd3191","param6","trim","$112d87fa33ebb5f5$export$d38b14fb9031108e","hook","_bound","boundDef","passesL","stepsL","c","JSON","stringify","_c","s1","slice","$112d87fa33ebb5f5$export$84186522bf5a7d4d","s2","$112d87fa33ebb5f5$export$49873e279ff642c0","reads1","passSamples","tap","$112d87fa33ebb5f5$export$9cb6037fa2a40c2e","$7b02a589e8d7c18a$var$start","$7b02a589e8d7c18a$var$end","split","$7b02a589e8d7c18a$export$bf9fb029d174d554","_uniforms","ref3","ref4","ref5","ref6","ref7","$c0d0347db9b941ce$export$4e06fab977536f8e","past","textureMap","texturesL","viewportWidth","viewportHeight","$fnH3v","setC2","b","pl","_loop","$c0d0347db9b941ce$export$a495db45d4904b10","ref9","ref8","$c0d0347db9b941ce$export$87ed20f81f3c66ff","isInteger","$b32a66f4c5b7b75f$export$dcfbb7940cfb3a48","$0367bb3900f2b1c9$export$2e2bcd8739ae039","states"],"version":3,"file":"index.cb50dfb3.js.map"}