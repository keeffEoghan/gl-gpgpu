{"version":3,"sources":["../node_modules/@epok.tech/fn-time/index.js","../node_modules/@epok.tech/gl-screen-triangle/index.js","../node_modules/@epok.tech/fn-lists/wrap-index.js","../node_modules/@epok.tech/fn-lists/reduce.js","../node_modules/@epok.tech/fn-lists/map.js","../node_modules/@epok.tech/fn-lists/each.js","../node_modules/@epok.tech/gl-screen-triangle/index.vert.glsl","../const.js","../maps.js","../node_modules/@epok.tech/fn-lists/range.js","../node_modules/@epok.tech/is-type/type.js","../node_modules/@epok.tech/is-type/number.js","../state.js","../macros.js","../node_modules/@thi.ng/vectors/setc.js","../inputs.js","../step.js","../index.js","lines-pairs/index.js","../node_modules/@epok.tech/gl-screen-triangle/uv-texture.vert.glsl","step.frag.glsl","draw.vert.glsl","draw.frag.glsl","index.js"],"names":["timer","steps","diff","pause","add","stepDef","startDef","timeDef","state","time","out","t0","step","d","t1","isNaN","dt","positions","vertices","count","length","dim","flat","wrap","wrapIndex","i","l","wrapGet","a","index","get","reduce","r","Array","prototype","f","undefined","call","map","v","each","e","forEach","module","exports","extensions","optionalExtensions","preDef","channelsMinDef","channelsMaxDef","texturesMaxDef","boundDef","scaleDef","stepsDef","typeDef","valuesDef","positionsDef","mapGroups","cache","packed","validValue","value","channelsMax","console","error","packValues","values","_","channels","fitIndex","fitSize","Infinity","fit","pack","maps","texturesMax","passes","textures","valueToTexture","valueToPass","textureToPass","p","pass","t","texture","push","mapSamples","derives","reads","getAddSamples","set","valueDerives","getAddSample","derive","sample","Number","isInteger","every","findIndex","s","passReads","samples","range","n","fill","type","start","end","split","x","toString","slice","isNumber","getState","api","framebuffer","radius","width","height","scale","stepNow","passNow","channelsMin","texturesMap","textureProps","min","mag","size","shape","addTexture","addPass","passProps","max","Math","color","depthStencil","macroPass","rgba","hooks","macroValues","macroOutput","macroSamples","macroSamplesTap","getPre","macros","pre","getGLSL3List","name","qualify","init","isArray","join","getGLSL1ListArray","getGLSL1ListLike","getGLSLList","glsl","trim","hasMacros","props","key","Object","hook","passesL","stepsL","bound","c","JSON","stringify","passSamples","tap","setC2","y","setC3","z","setC4","w","setC6","b","setC","xs","getUniforms","textureMap","texturesL","viewportWidth","h","viewportHeight","past","countDrawIndexes","getDrawIndexes","getStep","vec2","buffer","command","vert","vertDef","frag","verts","frags","uniforms","stateCache","passMacros","passCommand","vs","fs","attributes","depth","enable","run","onPass","onStep","gpgpu","limits","maxDrawbuffers","parseFloat","match","linesPairs","states","regl","self","query","document","location","search","parseInt","floor","sqrt","valuesMap","position","life","acceleration","valuesKeys","keys","derivesMap","indexOf","canVerlet","now","rate","loop","useVerlet","lifetime","g","source","stepVert","stepFrag","sin","PI","prop","force","log","drawCount","drawIndexes","drawState","drawCommand","drawVert","drawFrag","pointSize","lineWidth","primitive","draw","frame","addEventListener"],"mappings":"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","file":"particles-verlet-3d.6575f1cc.js","sourceRoot":"../particles-verlet-3d","sourcesContent":["/**\n * Simple time-stepping - frame, real-time, constant-step - via any API.\n */\n\nexport const steps = {\n    diff: -1, pause: 0, add: 1,\n    '📏': -1, '⏸': 0, add: '⏭',\n    '-1': -1, '0': 0, '1': 1,\n    '-': -1, '0': 0, '+': 1\n};\n\nexport const stepDef = steps.add;\nexport const startDef = 0;\nexport const timeDef = 1000/60;\n\n/**\n * Sets up properties needed to track time, starts/steps time in various ways.\n *\n * @example\n *     // Initial call sets up properties.\n *     const frame0 = { step: '-', time: Date.now() };\n *\n *     timer(frame0, frame0.time); // =>\n *     { ...frame0, dt: 0 };\n *\n *     // Subsequent calls advance time and track difference.\n *     const frame1 = { ...frame0 };\n *     const next = Date.now();\n *\n *     timer(frame0, next, frame1); // =>\n *     { ...frame1, dt: next-frame0.time, time: next };\n *\n * @param {object} state The state being tracked.\n * @param {number} [state.time=startDef] The initial time.\n * @param {string|number} [state.step=stepDef] How time advances:\n *     - Adding a time-step (`steps.add`/`'-'`, or a positive number).\n *     - Pausing (`steps.pause`/`'-'`, or `0`).\n *     - Diff from the latest time (`steps.diff`/`'-'`, or a negative number).\n * @param {number|function} [time=timeDef] The time (clock/frame/etc), or a\n *     function giving it; current time or time-step, according to `state.step`.\n * @param {object|false} [out=state] The state to set up; modifies `state` by\n *     default; or if falsey, returns the relevant calculated time value:\n *     - The latest time if add-stepping forwards, or paused.\n *     - The time-difference if diff-stepping from the latest time.\n *\n * @returns {object|number} The given `out` set up with its initial time; or if\n *     `out` is falsey, returns the initial time.\n */\nexport function timer(state, time = timeDef, out = state) {\n    // Get the initial time and step-step.\n    const { time: t0 = startDef, step = stepDef } = state;\n    // Get the step mode - from a key into `steps` or a numerical value.\n    const d = ((step in steps)? steps[step] : step);\n    // Step the time - '0' pauses; '+' adds a time-step; '-' sets time, to diff.\n    const t1 = ((!d)? t0 : ((d > 0)? t0 : 0)+((isNaN(time))? time() : time));\n    const dt = t1-t0;\n\n    // If only returning a value, return the unknown one as calculated:\n    // - The latest time if add-stepping forwards, or paused.\n    // - The time-difference if diff-stepping from the latest time.\n    if(!out) { return ((d >= 0)? t1 : dt); }\n\n    out.time = t1;\n    out.dt = dt;\n\n    return out;\n}\n\nexport default timer;\n","/**\n * The 3 vertices of a 2D triangle covering the viewport in NDC coordinates ([-1, 1]).\n *\n * @export\n * @type {array.<array.<number>>}\n */\nexport const vertices = [[-1, -1], [-1, 4], [4, -1]];\n\nexport const count = vertices.length;\nexport const dim = 2;\n\n/**\n * The flat array of the above triangle, to be bound as a WebGL attribute buffer for\n * rendering the triangle in the vertex shader.\n * These positions will result in clipped NDC coordinates ([-1, 1]) over the\n * viewport's width and height.\n *\n * @export\n * @type {array.<number>}\n */\nexport const positions = vertices.flat();\n\nexport default positions;\n","/**\n * Wraps an index within a given length, so that indexes greater than the length\n * loop back past 0, and indexes less than 0 loop backward from the length.\n * Similar to the indexing behaviour of `Array.slice`.\n *\n * @param {number} i The index to wrap.\n * @param {number} l The length to wrap the index within.\n *\n * @returns {number} The index wrapped within the length.\n */\nexport const wrapIndex = (i, l) => ((i%l)+l)%l;\n\n/**\n * Gives the entry at a wrapped index of a given list, never exceeds its bounds.\n *\n * @see wrapIndex\n *\n * @param {number} i The index to wrap.\n * @param {array} a A list to index (array or array-like object).\n * @param {number} a.length The length property of the given list.\n *\n * @returns {*} The entry at the wrapped index of the given list.\n */\nexport const wrapGet = (i, a) => a[wrapIndex(i, a.length)];\n\nexport const wrap = { index: wrapIndex, get: wrapGet };\n\nexport default wrap;\n","const r = Array.prototype.reduce;\n\n/**\n * Reduce an array-like object.\n * Similar to native, but with iteratee-first arguments.\n * Supports the native single-argument behaviour.\n *\n * @param {function} f The iteratee function, given standard arguments, plus the\n *     `out` argument.\n * @param {array} a The list to reduce over (array or array-like object).\n * @param {*} [out] The initial accumulator, if given; otherwise, uses standard\n *     `Array.reduce` behaviour.\n *\n * @returns {*} The result of running the reducer iteratee function over all\n *     elements of the list.\n */\nexport const reduce = (f, a, out) =>\n    // Needs separate `call` because native detects even `undefined` parameter.\n    ((out === undefined)? r.call(a, f) : r.call(a, f, out));\n\nexport default reduce;\n","import { reduce } from './reduce';\n\n/**\n * Map an array-like object.\n * Similar to native, but with iteratee-first arguments; and allows the object\n * into which properties will be mapped to be defined (a new array, by default),\n * avoiding always creating new arrays.\n *\n * @param {function} f The iteratee function, given standard `Array.map`\n *     arguments, plus the output object.\n * @param {array} a The list to map over (array or array-like object).\n * @param {*} [out=[]] The initial accumulator, if given; `a`, if defined and\n *     falsey.\n *\n * @returns {*} The `out` object, having been mapped through the iteratee\n *     function over the list.\n */\nexport const map = (f, a, out = []) => reduce((out, v, i) => {\n        out[i] = f(v, i, a, out);\n\n        return out;\n    },\n    a, (out || a));\n\nexport default map;\n","const e = Array.prototype.forEach;\n\n/**\n * Iterates a function over every element of a list, returning the list.\n *\n * @param {function} f The iteratee function.\n * @param {array} a A list to iterate over (array or array-like object).\n *\n * @returns {array} The given list.\n */\nexport const each = (f, a) => {\n    e.call(a, f);\n\n    return a;\n}\n\nexport default each;\n","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\n\\nvoid main() {\\n    gl_Position = vec4(position, 0, 1);\\n}\\n\";","/**\n * GPGPU defaults and constants.\n */\n\nimport { positions } from '@epok.tech/gl-screen-triangle';\n\nexport { default as vertDef }\n    from '@epok.tech/gl-screen-triangle/index.vert.glsl';\n\n/**\n * The required and optional GL extensions for a GPGPU state.\n *\n * @todo\n * For drawing into floating-point buffers:\n * `oes_texture_float` and `oes_texture_half_float` are required dependencies of\n * `webgl_color_buffer_float` and `ext_color_buffer_half_float`, respectively.\n *\n * @todo Can these be optional? Fallbacks? `ext_color_buffer_half_float`?\n */\nexport const extensions = () =>\n    ['oes_texture_float', 'webgl_color_buffer_float'];\n\nexport const optionalExtensions = () => ['webgl_draw_buffers'];\n\n/**\n * Default properties for GPGPU and GL capabilities and resources.\n */\n\n// Prefix namespace to avoid naming clashes.\nexport const preDef = '';\n\n// The allowable range of channels for framebuffer attachments.\n// Default avoids `RGB32F` framebuffer attachments, which errors on\n// Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1448632\nexport const channelsMinDef = 4;\nexport const channelsMaxDef = 4;\n\nexport const texturesMaxDef = 1;\nexport const boundDef = 1;\nexport const scaleDef = 10;\nexport const stepsDef = 2;\nexport const typeDef = 'float';\nexport const valuesDef = () => [channelsMaxDef];\nexport const positionsDef = () => [...positions];\n","/**\n * GPGPU mappings for step/draw shaders input/output.\n *\n * These maps show shaders how to make use of a system's supported features, how\n * to pack/unpack their data with framebuffers/textures, perform only the needed\n * texture samples to retrieve any past values they must derive from, etc.\n * Shaders may declare values they output, values they derive from, groupings of\n * in/dependent values - without handling how these concerns map to the\n * particular system resources they're using.\n * System limits/features/extensions are accounted for, to produce the most\n * efficient mappings available with the least I/O when it comes to drawing\n * (draw passes, texture samples, etc).\n */\n\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport each from '@epok.tech/fn-lists/each';\n\nimport { valuesDef, channelsMaxDef, texturesMaxDef } from './const';\n\nexport const cache = { packed: [] };\n\nexport const validValue = (value, channelsMax = channelsMaxDef) =>\n    (((1 <= value) && (value <= channelsMax)) ||\n        !!console.error(`\\`gl-gpgpu\\`: the given value (${value}) exceeds the `+\n            `range of channels available (1 to ${channelsMax}).`,\n            value, channelsMax));\n\n/**\n * Minimise resource usage, order `values` to pack into blocks of `channelsMax`.\n *\n * @see mapGroups\n *\n * @param {array<number>} values Each entry is how many co-dependent channels\n *     are grouped into one texture in one pass, separate entries may be in one\n *     or more textures/passes. See `mapGroups`.\n * @param {number} [channelsMax=channelsMaxDef] The maximum number of channels\n *     per texture. See `mapGroups`.\n * @param {array} [out=[]] An array to store the result; a new array by default.\n *\n * @returns {array<number>} `out` The indexes of the given `values`, reordered\n *     to pack into the fewest buckets of `channelsMax` size or less; stored in\n *     the given `out` array.\n */\nexport function packValues(values, channelsMax = channelsMaxDef, out = []) {\n    out.length = values.length;\n    map((_, i) => i, values, out);\n\n    // Counts the number of empty channels in the current group.\n    let channels = channelsMax;\n    // How many values have already been packed.\n    let packed = 0;\n    // Tracks the value that best fits the free channels (fills it tightest).\n    let fitIndex = 0;\n    let fitSize = Infinity;\n\n    for(let i = 0; packed < values.length;) {\n        const v = packed+i;\n        const value = values[out[v]];\n\n        if(!validValue(value, channelsMax)) { return out; }\n\n        // Check how value fits the channels - valid is >= 0, perfect is 0.\n        const fit = channels-value;\n\n        if((fit >= 0) && (fit < fitSize)) {\n            fitSize = fit;\n            fitIndex = v;\n        }\n\n        if((fitSize !== 0) && (v < values.length-1)) { ++i; }\n        else {\n            // Got a perfect fit or the search ended - swap in best fit value.\n            const pack = out[fitIndex];\n\n            out[fitIndex] = out[packed];\n            out[packed] = pack;\n\n            // Reduce the free channels by the best value, reset if needed.\n            (((channels -= values[pack]) > 0) || (channels = channelsMax));\n            // Start the search again over the remaining unpacked entries.\n            fitIndex = ++packed;\n            fitSize = Infinity;\n            i = 0;\n        }\n    }\n\n    return out;\n}\n\n/**\n * Groups the `values` of GPGPU data items across draw passes and data textures.\n *\n * @todo The `values` are grouped in the given order, which may affect the\n * number of passes/textures used; sort/zip the values first to pack them into\n * buckets of `channelsMax` tightly before mapping.\n *\n * @example\n *     mapGroups({ values: [2, 4, 1], channelsMax: 4, texturesMax: 1 }); // =>\n *     {\n *         values: [2, 4, 1],\n *         textures: [[0], [1], [2]], // length === 3\n *         passes: [[0], [1], [2]], // length === 3\n *         texturesMax: 1,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 2],\n *         valueToPass: [0, 1, 2],\n *         textureToPass: [0, 1, 2]\n *     };\n *\n *     mapGroups({ values: [4, 2, 1], texturesMax: 1 }); // =>\n *     {\n *         values: [4, 2, 1],\n *         textures: [[0], [1, 2]], // length === 2\n *         passes: [[0], [1]], // length === 2\n *         texturesMax: 1,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 1],\n *         valueToPass: [0, 1, 1],\n *         textureToPass: [0, 1]\n *     };\n *\n *     mapGroups({ values: [4, 2, 1], texturesMax: 4 }); // =>\n *     {\n *         values: [4, 2, 1],\n *         textures: [[0], [1, 2]], // length === 2\n *         passes: [[0, 1]], // length === 1\n *         texturesMax: 4,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 1],\n *         valueToPass: [0, 0, 0],\n *         textureToPass: [0, 0]\n *     };\n *\n *     mapGroups({ values: [2, 4, 1], texturesMax: 4 }); // =>\n *     {\n *         values: [2, 4, 1],\n *         textures: [[0], [1], [2]], // length === 3\n *         passes: [[0, 1, 2]], // length === 1\n *         texturesMax: 4,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 2],\n *         valueToPass: [0, 0, 0],\n *         textureToPass: [0, 0, 0]\n *     };\n *\n *     mapGroups({ values: [2, 4, 1, 2], texturesMax: 2 }); // =>\n *     {\n *         values: [2, 4, 1, 2],\n *         textures: [[0], [1], [2, 3]], // length === 3\n *         passes: [[0, 1], [2]], // length === 2\n *         texturesMax: 2,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 2, 2],\n *         valueToPass: [0, 0, 1, 1],\n *         textureToPass: [0, 0, 1]\n *     };\n *\n * @export\n * @param {object} [maps={}] The maps. A new object if not given.\n * @param {array<number>} [maps.values=valuesDef()] An array where each number\n *     denotes how many value channels are grouped into one data texture in one\n *     draw pass; each separate number may be drawn across one or more data\n *     textures/passes. Each value denotes the number of dependent channels to\n *     be drawn together; separate values denote channels that aren't dependent,\n *     and may be drawn in the same or a separate pass, depending on device\n *     support. The given order is (currently) maintained, and may affect the\n *     number of passes/textures used. Where the next state depends on previous\n *     states, these should ideally be an entry of `channels` or less, for\n *     fewest texture reads to retrieve previous states.\n * @param {number} [maps.channelsMax=channelsMaxDef] Maximum channels per texture.\n * @param {number} [maps.texturesMax=texturesMaxDef] Maximum textures bound per pass.\n * @param {object} [out=maps] An object to contain the results; modifies `maps`\n *     if not given.\n *\n * @returns {object} `out` The given `out` object; how `values` are grouped\n *     per-texture per-pass per-step, meta information, and given parameters.\n * @returns {array<array<number>>} `out.passes` Textures grouped into passes;\n *     arrays corresponding to framebuffers in separate draw passes; whose\n *     values are indexes into `out.textures`.\n * @returns {array<array<number>>} `out.textures` Values grouped into\n *     textures; arrays corresponding to framebuffer attachments, into which\n *     `values` are drawn; whose values are indexes into `out.values`.\n * @returns {array<number>} `out.values` The `values`, as given.\n * @returns {number} `out.texturesMax` The max textures per pass, as given.\n * @returns {number} `out.channelsMax` The max channels per texture, as given.\n * @returns {array<number>} `out.valueToTexture` Inverse map from each index of\n *     `out.values` to the index of the data texture containing it.\n * @returns {array<number>} `out.valueToPass` Inverse map from each index of\n *     `out.values` to the index of the pass containing it.\n * @returns {array<number>} `out.textureToPass` Inverse map from each index of\n *     `out.textures` to the index of the pass containing it.\n */\nexport function mapGroups(maps = {}, out = maps) {\n    const {\n            values = valuesDef(),\n            channelsMax = channelsMaxDef, texturesMax = texturesMaxDef\n        } = maps;\n\n    out.values = values;\n    out.texturesMax = texturesMax;\n    out.channelsMax = channelsMax;\n    out.passes = [[]];\n    out.textures = [[]];\n    out.valueToTexture = [];\n    out.valueToPass = [];\n    out.textureToPass = [];\n\n    // Pack `values` into blocks of `channelsMax` to minimise resources.\n    const packed = packValues(values, channelsMax, cache.packed);\n    // Counts the number of channels written in a single draw pass.\n    let channels = 0;\n\n    return reduce((out, index) => {\n            const value = values[index];\n\n            if(!validValue(value, channelsMax)) { return out; }\n\n            const {\n                    textures, passes, valueToTexture, valueToPass, textureToPass\n                } = out;\n\n            let p = passes.length-1;\n            let pass = passes[p];\n            let t = textures.length-1;\n            let texture = textures[t];\n\n            if((channels += value) > channelsMax) {\n                channels = value;\n                t = textures.push(texture = [])-1;\n\n                ((pass.length >= texturesMax) &&\n                    (p = passes.push(pass = [])-1));\n                pass.push(t);\n                textureToPass.push(p);\n            }\n            else if(pass.length === 0) {\n                pass.push(t);\n                textureToPass.push(p);\n            }\n\n            texture.push(index);\n            valueToTexture.push(t);\n            valueToPass.push(p);\n\n            return out;\n        },\n        packed, out);\n}\n\n/**\n * Maps the minimal set of texture reads to derive the next state of values from\n * a past state of values they depend upon.\n *\n * @example\n *     const maps = mapGroups({\n *         values: [2, 4, 1, 2], channelsMax: 4, texturesMax: 2,\n *         // Entries per-value of derived step/value indexes, entries include:\n *         // empty, single, multiple, and defined step samples.\n *         derives: [[1, 0], , [3, [1, 0]], [2]]\n *     });\n *\n *     mapSamples(maps); // =>\n *     {\n *         ...maps,\n *         // Per-pass, minimum texture samples for values.\n *         samples: [\n *             // Per-value - step/texture index pairs into `maps.textures`.\n *             [[0, 1], [0, 0]],\n *             [[0, 2], [1, 0]]\n *         ],\n *         // Per-pass, value indexes to texture samples.\n *         reads: [\n *             // Per-value - indexes into `out.samples`.\n *             [[0, 1], , , ],\n *             [, , [0, 1], [0]]\n *         ]\n *     };\n *\n * @see mapGroups\n *\n * @export\n * @param {object} maps How values are grouped per-texture per-pass per-step.\n *     See `mapGroups`.\n * @param {array<null,array<number,array<number>>>} [maps.derives] How values\n *     are derived. For each value index, a list of indexes of any past values\n *     it derives its from - a value not derived from past values may have an\n *     empty/null entry; a value derives from past values where its entry has:\n *     - Numbers; deriving from the most recent state at the given value index.\n *     - Lists of numbers; deriving from the given past state index (1st number\n *         denotes how many states ago), at the given value index (2nd number).\n *     If not given, no samples are mapped and `out` is returned unchanged.\n * @param {array<array<number>>} maps.passes Textures grouped into passes. See\n *     `mapGroups`.\n * @param {array<array<number>>} maps.textures Values grouped into textures. See\n *     `mapGroups`.\n * @param {array<number>} maps.valueToTexture Inverse map from each value index\n *     to the data texture index containing it.\n * @param {object} [out=maps] The object to store the result in; `maps` if not\n *     given.\n *\n * @returns {object} `out` The given `out` object, with resulting maps added if\n *     `maps.derives` were provided.\n * @returns {array<array<array<number>>>} `[out.samples]` Map of the minimum\n *     set of indexes into `maps.textures` that need to be sampled per-pass,\n *     to get all `derives` needed for each value of `maps.values` of each\n *     pass of `maps.passes`.\n * @returns {array<array<null,array<number>>>} `[out.reads]` Sparse map from\n *     each value of `derives` to its step and texture indexes in `out.samples`.\n * @returns {array<null,array<number,array<number>>>} `[out.derives]` How\n *     values are derived, as given.\n */\nexport function mapSamples(maps, out = maps) {\n    const { derives, passes, textures, valueToTexture } = maps;\n\n    if(!derives) { return out; }\n\n    out.derives = derives;\n\n    const reads = out.reads = [];\n\n    const getAddSample = (set, pass, value) => (derive, d) => {\n        const sample = ((Number.isInteger(derive))? [0, valueToTexture[derive]]\n            :   [derive[0], valueToTexture[derive[1]]]);\n\n        if(!sample.every(Number.isInteger)) {\n            return console.error('`mapSamples`: invalid map for sample',\n                derives, maps, pass, value, derive, d, sample);\n        }\n\n        const [step, texture] = sample;\n        let i = set.findIndex(([s, t]) => (s === step) && (t === texture));\n\n        ((i < 0) && (i = set.push(sample)-1));\n\n        const passReads = (reads[pass] || (reads[pass] = []));\n        const valueReads = (passReads[value] || (passReads[value] = []));\n\n        valueReads[d] = i;\n    };\n\n    const getAddSamples = (pass) => (set, value) => {\n        const valueDerives = derives[value];\n\n        (valueDerives && each(getAddSample(set, pass, value), valueDerives));\n\n        return set;\n    }\n\n    out.samples = map((pass, p) => reduce((set, texture) =>\n                reduce(getAddSamples(p), textures[texture], set),\n            pass, []),\n        passes, []);\n\n    return out;\n}\n\nexport default mapGroups;\n","/**\n * Creates an iterable array of the given length, containing empty entries.\n *\n * @param {number} n The number of elements to create.\n *\n * @returns {array} An array of the given number of empty elements.\n */\nexport const range = (n) => Array(n).fill();\n\nexport default range;\n","const [{ length: start}, { length: end }] = '[object {type}]'.split('{type}');\n\n/**\n * Gives the type of a given input.\n *\n * @see https://stackoverflow.com/a/17772086/716898\n *\n * @param {*} x Any input to test.\n *\n * @returns {string} The type of `x`.\n */\nexport const type = (x) => toString.call(x).slice(start, -end);\n\nexport default type;\n","import { type } from './type';\n\nexport const isNumber = (x) => type(x) === 'Number';\n\nexport default isNumber;\n","/**\n * GPGPU state and GL resources.\n *\n * @todo In-place updates of complex resources and meta info.\n * @todo Use transform feedback instead of data textures, if supported (WebGL2)?\n * @todo Consider class/object/data/function structure further.\n */\n\nimport range from '@epok.tech/fn-lists/range';\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport isNumber from '@epok.tech/is-type/number';\n\nimport {\n        scaleDef, stepsDef, valuesDef, channelsMinDef, typeDef\n    } from './const';\n\n/**\n * Set up the GPGPU resources and meta information for a state of a number data.\n *\n * @todo Transform feedback.\n * @todo Validation.\n * @todo Reorder the given `values` into the most efficient `maps`?\n *\n * @example\n *     const state = {\n *         steps: 2, maps: mapGroups({ values: [4, 2, 3], texturesMax: 4 })\n *     };\n *\n *     getState(api, state); // =>\n *     {\n *         ...state, passNow: -1, stepNow: -1,\n *         size: {\n *             type: 'float', steps: 2, passes: 2, textures: 6,\n *             width: 1024, height: 1024, shape: [1024, 1024], count: 1048576\n *         },\n *         steps: [[api.framebuffer], [api.framebuffer]],\n *         passes: [\n *             [\n *                 {\n *                     step: 0, index: 0, count: 0, map: [0, 1, 2],\n *                     framebuffer: api.framebuffer,\n *                     textures: [api.texture, api.texture, api.texture]\n *                 }\n *             ],\n *             [\n *                 {\n *                     step: 1, index: 0, count: 1, map: [0, 1, 2],\n *                     framebuffer: api.framebuffer,\n *                     textures: [api.texture, api.texture, api.texture]\n *                 }\n *             ]\n *         ],\n *         textures: [\n *             [\n *                 {\n *                     step: 0, pass: 0, index: 0, count: 0, map: [0],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 0, pass: 0, index: 1, count: 1, map: [1],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 0, pass: 0, index: 2, count: 2, map: [2],\n *                     texture: api.texture\n *                 }\n *             ],\n *             [\n *                 {\n *                     step: 1, pass: 0, index: 0, count: 3, map: [0],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 1, pass: 0, index: 1, count: 4, map: [1],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 1, pass: 0, index: 2, count: 5, map: [2],\n *                     texture: api.texture\n *                 }\n *             ]\n *         ]\n *     };\n *\n *     Object.assign(state, {\n *         type: 'uint8', stepNow: 2,\n *         maps: mapGroups({ values: [4, 2, 3], texturesMax: 1 })\n *     });\n *\n *     getState(api, state); // =>\n *     {\n *        ...state, passNow: -1, stepNow: 2,\n *        size: {\n *            type: 'uint8', steps: 2, passes: 6, textures: 6,\n *            width: 1024, height: 1024, shape: [1024, 1024], count: 1048576\n *        },\n *        steps: [\n *            [api.framebuffer, api.framebuffer, api.framebuffer],\n *            [api.framebuffer, api.framebuffer, api.framebuffer]\n *        ],\n *        passes: [\n *            [\n *                {\n *                    step: 0, index: 0, count: 0, map: [0],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 0, index: 1, count: 1, map: [1],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 0, index: 2, count: 2, map: [2],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                }\n *            ],\n *            [\n *                {\n *                    step: 1, index: 0, count: 3, map: [0],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 1, index: 1, count: 4, map: [1],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 1, index: 2, count: 5, map: [2],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                }\n *            ]\n *        ],\n *        textures: [\n *            [\n *                {\n *                    step: 0, pass: 0, index: 0, count: 0, map: [0],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 0, pass: 1, index: 1, count: 1, map: [1],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 0, pass: 2, index: 2, count: 2, map: [2],\n *                    texture: api.texture\n *                }\n *            ],\n *            [\n *                {\n *                    step: 1, pass: 0, index: 0, count: 3, map: [0],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 1, pass: 1, index: 1, count: 4, map: [1],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 1, pass: 2, index: 2, count: 5, map: [2],\n *                    texture: api.texture\n *                }\n *            ]\n *        ]\n *    };\n *\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [mapSamples]{@link ./maps.js#mapSamples}\n * @see [getStep]{@link ./step.js#getStep}\n * @see [macroPass]{@link ./macros.js#macroPass}\n *\n * @export\n * @param {object} api The API for GL resources.\n * @param {function} api.texture A function to create a GL texture.\n * @param {function} api.framebuffer A function to create a GL framebuffer.\n * @param {object} [state={}] The state parameters.\n * @param {number} [state.radius] The length of the sides of the data textures\n *     to allocate. If given, supersedes the `state` `width`/`height`/`scale`.\n * @param {number} [state.width] The width of the data textures to allocate.\n *     If given, supersedes `state.scale`.\n * @param {number} [state.height] The height of the data textures to allocate.\n *     If given, supersedes `state.scale`.\n * @param {number} [state.scale=scaleDef] The length of the data textures sides\n *     to allocate; gives a square power-of-two texture raising 2 to this power.\n * @param {number|array} [state.steps=stepsDef] How many steps of state to\n *     track, or the list of states if already set up.\n * @param {object} [state.maps] How `state.maps.values` are grouped per-texture\n *     per-pass per-step. See `mapGroups`.\n * @param {array<number>} [state.maps.values=valuesDef()] How values of each\n *     data item may be grouped into textures across passes. Set up here if not\n *     given. See `mapGroups`.\n * @param {number} [state.maps.channelsMin=channelsMinDef] The minimum allowed\n *     channels for framebuffer attachments. Sets up unused channels as needed\n *     to reach this limit.\n * @param {number} [state.maps.textures] How values are grouped into textures.\n *     See `mapGroups`.\n * @param {string} [state.type=typeDef] The data type of the textures.\n * @param {number} [state.stepNow=-1] The currently active state step, if any.\n * @param {number} [state.passNow=-1] The currently active draw pass, if any.\n * @param {object} [out=state] The state object to set up. Modifies the given\n *     `state` object by default.\n *\n * @returns {object} `out` The state object, set up with the data resources and\n *     meta information, for step/draw later:\n * @returns {object<number,array<number,array<number>>>} `out.maps` Any given\n *     `state.maps`. See `mapGroups`.\n * @returns {array<array<object<api.texture,number,array<number>>>>}\n *     `out.textures` Textures per step, as arrays of objects of `api.texture`,\n *     and meta info. See `out.maps.textures`.\n * @returns {array<array<object<api.framebuffer,number,array<number>>>>}\n *     `out.passes` Passes per step, as arrays of objects of `api.framebuffer`,\n *     referencing `out.textures`, and meta info. See `out.maps.passes`.\n * @returns {array<api.framebuffer<array<api.texture>>>} `out.steps`\n *     Hierarchy of steps of state, as an array of `api.framebuffer` from\n *     `out.passes`, with arrays of `api.texture` from `out.textures`, and meta\n *     information; set up here, or the given `state.steps` if it was an array.\n *     State data may be drawn into the framebuffers accordingly.\n *     See `mapGroups` and `getStep`.\n * @returns {object<number,string,array<number>>} `out.size` Size/type\n *     information on data resources.\n * @returns {number} `out.stepNow` The currently active state step, as given.\n * @returns {number} `out.passNow` The currently active draw pass, as given.\n */\nexport function getState(api, state = {}, out = state) {\n    // See usage here for what the API must implement.\n    const { texture, framebuffer } = api;\n\n    const {\n            radius, width, height, scale = scaleDef, type = typeDef,\n            steps = stepsDef, stepNow = -1, passNow = -1, maps\n        } = state;\n\n    out.maps = maps;\n    out.stepNow = stepNow;\n    out.passNow = passNow;\n\n    const {\n            values = valuesDef(),\n            channelsMin = channelsMinDef, textures: texturesMap\n        } = maps;\n\n    maps.channelsMin = channelsMin;\n    maps.values = values;\n\n    const textureProps = {\n        type, min: 'nearest', mag: 'nearest',\n        // Passing `state.scale` ensures a power-of-two square texture size.\n        width: (radius || width || 2**scale),\n        height: (radius || height || 2**scale)\n    };\n\n    // Size of the created resources.\n    const size = out.size = {\n        ...textureProps, steps: ((isNumber(steps))? steps : steps.length),\n        textures: 0, passes: 0,\n        shape: [textureProps.width, textureProps.height],\n        count: textureProps.width*textureProps.height\n    };\n\n    const textures = out.textures = [];\n    const passes = out.passes = [];\n\n    const addTexture = (step, pass, textureProps) => (index) =>\n        ((textures[step] || (textures[step] = []))[index] = {\n            // Meta info.\n            step, pass, index, count: size.textures++, map: texturesMap[index],\n            // Resources.\n            texture: texture(textureProps)\n        })\n        .texture;\n\n    const addPass = (step) => (pass, index) => {\n        // All framebuffer color attachments need the same number of channels.\n        const passProps = {\n            ...textureProps,\n            channels: reduce((max, t) =>\n                    reduce((max, v) => Math.max(max, values[v]),\n                        texturesMap[t], max),\n                pass, channelsMin)\n        };\n\n        const textures = map(addTexture(step, index, passProps), pass);\n\n        const f = framebuffer({\n            width: passProps.width,\n            height: passProps.height,\n            color: textures,\n            depthStencil: false\n        });\n\n        (passes[step] || (passes[step] = []))[index] = {\n            // Meta info.\n            step, index, count: size.passes++, map: pass,\n            // Resources.\n            textures, framebuffer: f\n        };\n\n        return f;\n    };\n\n    // Set up resources we'll need to store data per-texture per-pass per-step.\n    out.steps = map((passes, step) =>\n            // Use any given passes or create a new list of them.\n            (passes || map(addPass(step), maps.passes)),\n        // Use any given steps or create a new list of them.\n        ((isNumber(steps))? range(steps) : steps), 0);\n\n    return out;\n}\n\nexport default getState;\n","/**\n * GPGPU GLSL preprocessor macros for each part of the state.\n *\n * Careful defining these, as each set of different macros will result in new\n * shaders and compilations, missing the cache here and in the rendering system.\n * So, as few unique macros as possible should be created for a given set of\n * inputs, for efficiency.\n *\n * @todo Consider doing something better with indentation.\n */\n\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\nimport { type } from '@epok.tech/is-type/type';\n\nimport { preDef, boundDef } from './const';\n\nexport const rgba = 'rgba';\nexport const cache = {};\n\n// Keys for each part of the macro handling process available to hooks.\nexport const hooks = {\n    // The full set of macros.\n    macroPass: 'pass',\n    // Each part of the set of macros.\n    macroValues: 'values', macroOutput: 'output',\n    macroSamples: 'samples', macroSamplesTap: 'tap'\n};\n\n/**\n * Gives the prefix to use, to avoid namespace collisions.\n *\n * @param {object} state The state to check.\n * @param {string} [state.macros] The macros prefix; supersedes `state.pre`.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n *\n * @returns {string} The prefix string to use.\n */\nexport const getPre = ({ macros, pre = preDef }) =>\n    ((type(macros) === 'String')? macros : pre);\n\n/**\n * Generates an array declaration, as a GLSL 3 syntax string.\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @export\n * @example\n *     getGLSL3List('int', 'list', [1, 2, 3], 'const'); // =>\n *     'const int list_l = 3; '+\n *     'const int list[list_l] = int[list_l](int(1), int(2), int(3));\\n'+\n *     '#define list_i(i) list[i]\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 3 array declaration string.\n */\nexport const getGLSL3List = (type, name, a, qualify = '', init = type) =>\n    `const int ${name}_l = ${a.length}; `+\n    `${(qualify && qualify+' ')+type} ${name}[${name}_l] = ${\n        init}[${name}_l](${reduce((s, v, i) =>\n                `${s+type}(${((Array.isArray(v))? v.join(', ') : v)})${\n                    ((i < a.length-1)? ', ' : '')}`,\n            a, '')});\\n`+\n    `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Generates an array declaration, as a GLSL 1 syntax string.\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @export\n * @example\n *     getGLSL1ListArray('vec3', 'list', [[1, 0, 0], [0, 2, 0], [0, 0, 3]]);\n *     // =>\n *     'const int list_l = 3; '+\n *     'vec3 list[list_l]; '+\n *     'list[0] = vec3(1, 0, 0); '+\n *     'list[1] = vec3(0, 2, 0); '+\n *     'list[2] = vec3(0, 0, 3);\\n'+\n *     '#define list_i(i) list[i]\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array declaration string.\n */\nexport const getGLSL1ListArray = (type, name, a, qualify = '', init = type) =>\n    `const int ${name}_l = ${a.length}; ${\n    (qualify && qualify+' ')+type} ${name}[${name}_l]; ${\n    reduce((s, v, i) =>\n            `${s} ${name}[${i}] = ${\n                init}(${((Array.isArray(v))? v.join(', ') : v)});`,\n        a, '')}\\n`+\n    `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Generates an array-like declaration, as a GLSL 1 syntax string.\n * Workaround for lack of `const` arrays in GLSL < 3.\n *\n * @export\n * @example\n *     getGLSL1ListLike('float', 'list', [1, 2, 3], 'const'); // =>\n *     'const int list_l = 3; '+\n *     'const int list_0 = float(1); '+\n *     'const int list_1 = float(2); '+\n *     'const int list_2 = float(3);\\n'+\n *     '#define list_i(i) ((i == 2)? list_2 : ((i == 1)? list_1 : list_0))\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array-like declaration string.\n */\nexport const getGLSL1ListLike = (type, name, a, qualify = '', init = type) =>\n    `const int ${name}_l = ${a.length}; ${\n    reduce((s, v, i) =>\n            `${s} ${(qualify && qualify+' ')+type} ${name}_${i} = ${\n                init}(${((Array.isArray(v))? v.join(', ') : v)});`,\n        a, '')}\\n`+\n    // `#define ${name}_i(i) ${name}_##i`;\n    `#define ${name}_i(i) ${reduce((s, v, i) =>\n            ((i)? `((i == ${i})? ${name}_${i} : ${s})` : `${name}_${i}`),\n        a, '')}\\n`;\n\n/**\n * Creates a GLSL definition of an array, and initialises it with the given\n * values, type, and variable name.\n * The initialisation is valid GLSL 1.0 or greater syntax; but is written with\n * escaped new-lines so it may be used in a single-line - e.g: for preprocessor\n * macros.\n * For a `qualify` of `const` on any `glsl` less than `3`, falls back to using\n * non-array variables with the index appended to `name`, since `const` arrays\n * aren't supported before GLSL 3.0.\n *\n * @example\n *     getGLSLList('int', 'test', [0, 1]); // =>\n *     'const int test_l = 2; '+\n *     'int test[test_l]; '+\n *     'test[0] = int(0); '+\n *     'test[1] = int(1);\\n'+\n *     '#define test_i(i) test[i]\\n';\n *\n *     getGLSLList('ivec2', 'vecs', [[0, 1], [0, 0]], 'const', 3); // =>\n *     'const int vecs_l = 2; '+\n *     'const ivec2 vecs[vecs_l] = ivec2[vecs_l](ivec2(0, 1), ivec2(0, 0));\\n'+\n *     '#define vecs_i(i) vecs[i]\\n';\n *\n *     getGLSLList('int', 'listLike', [0, 1], 'const', 1); // =>\n *     'const int listLike_l = 2; '+\n *     'const int listLike_0 = int(0); '+\n *     'const int listLike_1 = int(1);\\n'+\n *     '#define listLike_i(i) ((i == 1)? listLike_1 : listLike_0)\\n';\n *\n * @export\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {number} [qualify=''] A GLSL qualifier, if needed (e.g: `const`).\n * @param {number} [glsl=1] The GLSL version to target, if specified.\n * @param {string} [init] A data-type initialiser.\n *\n * @returns {string} The GLSL (1 or 3) array or array-like declaration string.\n */\nexport const getGLSLList = (type, name, a, qualify = '', glsl = 1, init) =>\n    ((glsl >= 3)? getGLSL3List\n    : ((qualify.trim() === 'const')? getGLSL1ListLike\n    :   getGLSL1ListArray))(type, name, a, qualify, init);\n\n/**\n * Whether macros should be handled in this module; or the result of handling\n * them by a given named hook.\n * Allows macros of the given key to be handled by external named hooks, to\n * replace any part of the functionality in this module.\n *\n * @example\n *     // Macros to be handled in part of this module.\n *     hasMacros({}) === false;\n *     // Macros to be handled in part of this module (with a name prefix `m`).\n *     hasMacros({ macros: 'm' }) === false;\n *     // No/empty macros created.\n *     hasMacros({ macros: false }) === '';\n *     // Macros for 'a' handled by external static hook, not this module.\n *     hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'a') === '//A\\n';\n *     // Macros for 'b' handled by external function hook, not this module.\n *     hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'b') === '//B\\n';\n *\n * @param {object} props The properties handling macros.\n * @param {string} [key] The name for which macros should be handled.\n * @param {string|function|object|false} [macros=props.macros] Whether and\n *     how GLSL preprocessor macros should be handled:\n *     - If it's defined and falsey, no macros are handled in this module.\n *     - If it's a function, it's passed the given `props`, `key`, `macros`.\n *     - If it's an object, any value at the given `key` is entered recursively,\n *         with the given `props`, `key`, and `macros[key]`.\n *     - Otherwise, returns `false` to indicate macros should be handled here.\n *\n * @returns {string|*|false} Either the result of the macros handled elsewhere,\n *     or `false` if macros should be handled here.\n */\nexport function hasMacros(props, key, macros = props.macros) {\n    if(macros === undefined) { return false; }\n    if(!macros) { return ''; }\n\n    const t = type(macros);\n\n    return ((t === 'Function')? macros(props, key, macros)\n        : ((t === 'String')? macros\n        : (((macros instanceof Object) && (key in macros))?\n            hasMacros(props, key, macros[key])\n        :   false)));\n}\n\n/**\n * Defines the values within textures per-step, as GLSL preprocessor macros.\n * These macros define mappings from values to their textures and channels.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see getPre\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     macroValues({\n *         steps: Array(2),\n *         maps: mapGroups({ values: [4, 2, 1], texturesMax: 1 })\n *     }); // =>\n *     '#define texture_0 0\\n'+ // Value 0's texture.\n *     '#define channels_0 rgba\\n'+ // Value 0's channels.\n *     '\\n'+\n *     '#define texture_1 1\\n'+ // Value 1's texture.\n *     '#define channels_1 rg\\n'+ // Value 1's channels.\n *     '\\n'+\n *     '#define texture_2 1\\n'+ // Value 2's texture.\n *     '#define channels_2 b\\n'+ // Value 2's channels.\n *     '\\n'+\n *     // General metadata.\n *     '#define textures 2\\n'+\n *     '#define passes 2\\n'+\n *     '#define stepsPast 1\\n'+\n *     '#define steps 2\\n';\n *\n * @export\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string|function|object|falsey} [state.macros] How macros are handled\n *     or prefixed. See `hasMacros` and `getPre`.\n * @param {string} [state.pre] How macros are prefixed. See `getPre`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step.\n * @param {array<number>} state.maps.values How values of each data item are\n *     grouped into textures. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures The groupings of values\n *     into textures. See `mapGroups`.\n * @param {array} state.maps.passes The passes drawn per-step. See `mapGroups`.\n * @param {array} state.steps The states drawn across frames. See `getState`.\n * @param {number} [state.bound=boundDef] How many steps are bound as outputs,\n *     unavailable as inputs.\n * @param {object} [state.size] Any size information about the GL resources.\n * @param {number} [state.size.count] The number of data entries per texture\n *     (the texture's area), if given. See `getState`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings from\n *     values to textures/channels.\n */\nexport function macroValues(state) {\n    const key = hooks.macroValues;\n    const hook = hasMacros(state, key);\n\n    if(hook !== false) { return hook; }\n\n    const {\n            maps: { values, textures, passes: { length: passesL } },\n            steps: { length: stepsL }, bound = boundDef\n        } = state;\n\n    const count = (state.size && state.size.count);\n    const n = getPre(state);\n    const c = key+':'+\n        JSON.stringify({ n, bound, values, textures, stepsL, passesL, count });\n\n    return (cache[c] || (cache[c] =\n        reduce((s, texture, t, _, i = 0) => reduce((s, v) => s+\n                    `#define ${n}texture_${v} ${t}\\n`+\n                    `#define ${n}channels_${v} ${\n                        rgba.slice(i, (i += values[v]))}\\n\\n`,\n                texture, s),\n            textures, '')+\n        ((count)? `#define count ${count}\\n` : '')+\n        `#define ${n}textures ${textures.length}\\n`+\n        `#define ${n}passes ${passesL}\\n`+\n        `#define ${n}stepsPast ${stepsL-bound}\\n`+\n        `#define ${n}steps ${stepsL}\\n`));\n}\n\n/**\n * Defines the outputs being drawn to per-pass, as GLSL preprocessor macros.\n * These macros define mappings from values to their outputs, if bound.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see getPre\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const state = {\n *         passNow: 0, maps: mapGroups({ values: [4, 2, 1], texturesMax: 1 })\n *     };\n *\n *     macroOutput(state); // =>\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_0 0\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rgba\\n';\n *\n *     ++state.passNow;\n *\n *     macroOutput(state); // =>\n *     '#define passNow 1\\n'+\n *     '\\n'+\n *     '#define bound_1 1\\n'+\n *     '#define attach_1 0\\n'+\n *     '#define output_1 gl_FragData[attach_1].rg\\n'+\n *     '\\n'+\n *     '#define bound_2 1\\n'+\n *     '#define attach_2 0\\n'+\n *     '#define output_2 gl_FragData[attach_2].b\\n';\n *\n * @export\n * @param {object} state Properties for generating the macros. See `getState`:\n * @param {string|function|object|falsey} [state.macros] How macros are handled\n *     or prefixed. See `hasMacros` and `getPre`.\n * @param {string} [state.pre] How macros are prefixed. See `getPre`.\n * @param {number} state.passNow The index of the currently active pass.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<number>} state.maps.values How values of each data item may be\n *     grouped into textures across passes. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures The groupings of values\n *     into textures. See `mapGroups`.\n * @param {array<array<number>>} state.maps.passes The groupings of textures\n *     into passes. See `mapGroups`.\n *\n * @returns {string} The GLSL preprocessor macros defining the bound outputs.\n */\nexport function macroOutput(state) {\n    const key = hooks.macroOutput;\n    const hook = hasMacros(state, key);\n\n    if(hook !== false) { return hook; }\n\n    const { passNow: p, maps: { values, textures, passes } } = state;\n    const n = getPre(state);\n    const pass = passes[p];\n    const c = key+':'+JSON.stringify({ n, p, values, textures, passes });\n\n    return (cache[c] || (cache[c] =\n        `#define ${n}passNow ${p}\\n`+\n        reduce((s, texture, bound, _, i = 0) => reduce((s, v) => `${s}\\n`+\n                    `#define ${n}bound_${v} ${texture}\\n`+\n                    `#define ${n}attach_${v} ${bound}\\n`+\n                    `#define ${n}output_${v} gl_FragData[${n}attach_${v}].${\n                        rgba.slice(i, (i += values[v]))\n                    }\\n`,\n                textures[texture], s),\n            pass, '')));\n}\n\n/**\n * Defines the texture samples/reads per-pass, as GLSL preprocessor macros.\n * The macros define the mapping between the values and the minimum texture\n * samples for the data they derive from. They're set up as function-like macros\n * that may be called from the shader to initialise the mappings arrays with a\n * given name.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see getPre\n * @see getGLSLList\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [mapSamples]{@link ./maps.js#mapSamples}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     macroSamples({\n *         passNow: 0,\n *         maps: mapSamples(mapGroups({\n *             values: [4, 2, 1], channelsMax: 4, texturesMax: 1,\n *             derives: [[1, 0], , [3, [1, 0]]]\n *         }))\n *     }); // =>\n *     '#define useSamples '+\n *         'const int samples_l = 2; '+\n *         'const ivec2 samples_0 = ivec2(0, 1); '+\n *         'const ivec2 samples_1 = ivec2(0, 0);\\n'+\n *     '#define samples_i(i) ((i == 1)? samples_1 : samples_0)\\n'+\n *     '\\n'+\n *     '#define tapSamples(states, uv, textures) '+\n *         'const int data_l = 2; '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = texture2D(states[(0*textures)+1], uv); '+\n *         'data[1] = texture2D(states[(0*textures)+0], uv);\\n'+\n *         '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define useReads_0 '+\n *         'const int reads_0_l = 2; '+\n *         'const int reads_0_0 = int(0); '+\n *         'const int reads_0_1 = int(1);\\n'+\n *     '#define reads_0_i(i) ((i == 1)? reads_0_1 : reads_0_0)\\n';\n *\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string|function|object|falsey} [state.macros] How macros are handled\n *     or prefixed. See `hasMacros` and `getPre`.\n * @param {string} [state.pre] How macros are prefixed. See `getPre`.\n * @param {number} state.passNow The index of the currently active pass.\n * @param {object} state.maps  How `values` are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<array<number>>>} [state.maps.samples] The minimal set of\n *     texture samples to use. See `mapSamples`.\n * @param {array<array<array<number>>>} [state.maps.reads] The mappings from\n *     values to the corresponding `state.samples`. See `mapSamples`.\n * @param {number} [state.glsl=1] The GLSL language version. See `getGLSLList`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings for\n *     samples and reads, for each value.\n */\nexport function macroSamples(state) {\n    const key = hooks.macroSamples;\n    const hook = hasMacros(state, key);\n\n    if(hook !== false) { return hook; }\n\n    const { passNow: p, maps: { samples, reads }, glsl } = state;\n    const n = getPre(state);\n    const passSamples = (samples && samples[p]);\n    const passReads = (reads && reads[p]);\n    // Whether to generate GLSL preprocessor macros for the lookup logic.\n    const tap = hasMacros(state, hooks.macroSamplesTap);\n\n    const c = key+':'+\n        JSON.stringify({ n, p, passSamples, passReads, glsl, tap });\n\n    return (cache[c] || (cache[c] =\n        ((!passSamples)? ''\n        :   `#define ${n}useSamples ${\n                getGLSLList('ivec2', `${n}samples`, passSamples, 'const', glsl)\n            }\\n`+\n            // The texture-sampling logic.\n            // @todo `Index expression must be constant`\n            ((tap !== false)? tap\n            :   `#define ${n}tapSamples(states, uv, textures) ${\n                    getGLSLList('vec4', `${n}data`,\n                        // 2D-to-1D indexing, as textures a flat array.\n                        map(([s, t]) =>\n                                `texture2D(states[(${s}*textures)+${t}], uv)`,\n                            passSamples),\n                        '', glsl)}\\n`))+\n        ((!passReads)? ''\n        :   reduce((s, reads, v) =>\n                    `${s}\\n#define ${n}useReads_${v} ${\n                        getGLSLList('int', `${n}reads_${v}`, reads, 'const',\n                            glsl)}`,\n                passReads, ''))));\n}\n\n/**\n * Defines all GLSL preprocessor macro values, texture samples, and outputs for\n * the active pass.\n * The macros define the mapping between the active values, their textures and\n * channels, bound outputs, and other macros useful for a draw pass.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see macroValues\n * @see macroOutput\n * @see macroSamples\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const state = {\n *         steps: Array(2), passNow: 0,\n *         maps: mapSamples(mapGroups({\n *             values: [4, 2, 3], channelsMax: 4, texturesMax: 1,\n *             derives: [[1, 0], [2, [1, 0]]]\n *         }))\n *     };\n *\n *     macroPass(state); // =>\n *     '#define texture_0 0\\n'+\n *     '#define channels_0 rgba\\n'+\n *     '\\n'+\n *     '#define texture_1 1\\n'+\n *     '#define channels_1 rg\\n'+\n *     '\\n'+\n *     '#define texture_2 2\\n'+\n *     '#define channels_2 rgb\\n'+\n *     '\\n'+\n *     '#define textures 3\\n'+\n *     '#define passes 3\\n'+\n *     '#define steps 2\\n'+\n *     '\\n'+\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_0 0\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rgba\\n'+\n *     '\\n'+\n *     '#define useSamples '+\n *         'const int samples_l = 2; '+\n *         'const ivec2 samples_0 = ivec2(0, 1); '+\n *         'const ivec2 samples_1 = ivec2(0, 0);\\n'+\n *     '#define samples_i(i) ((i == 1)? samples_1 : samples_0)\\n'+\n *     '\\n'+\n *     '#define tapSamples(states, uv, textures) '+\n *         'const int data_l = 2; '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = texture2D(states[(0*textures)+1], uv); '+\n *         'data[1] = texture2D(states[(0*textures)+0], uv);\\n'+\n *         '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define useReads_0 '+\n *         'const int reads_0_l = 2; '+\n *         'const int reads_0_0 = int(0); '+\n *         'const int reads_0_1 = int(1);\\n'+\n *     '#define reads_0_i(i) ((i == 1)? reads_0_1 : reads_0_0)\\n';\n *\n *     ++state.passNow;\n *     state.macros = 'draw_';\n *     state.steps.push(null);\n *     Object.assign(state.maps, mapSamples(mapGroups({\n *         values: [4, 2, 3, 1], channelsMax: 4, texturesMax: 2,\n *         derives: [[1, 0], , [2, [1, 0]]]\n *     })));\n *\n *     macroPass(state); // =>\n *     '#define draw_texture_0 0\\n'+\n *     '#define draw_channels_0 rgba\\n'+\n *     '\\n'+\n *     '#define draw_texture_1 1\\n'+\n *     '#define draw_channels_1 rg\\n'+\n *     '\\n'+\n *     '#define draw_texture_2 2\\n'+\n *     '#define draw_channels_2 rgb\\n'+\n *     '\\n'+\n *     '#define draw_texture_3 2\\n'+\n *     '#define draw_channels_3 a\\n'+\n *     '\\n'+\n *     '#define draw_textures 3\\n'+\n *     '#define draw_passes 2\\n'+\n *     '#define draw_steps 3\\n'+\n *     '\\n'+\n *     '#define draw_passNow 1\\n'+\n *     '\\n'+\n *     '#define draw_bound_2 2\\n'+\n *     '#define draw_attach_2 0\\n'+\n *     '#define draw_output_2 gl_FragData[draw_attach_2].rgb\\n'+\n *     '\\n'+\n *     '#define draw_bound_3 2\\n'+\n *     '#define draw_attach_3 0\\n'+\n *     '#define draw_output_3 gl_FragData[draw_attach_3].a\\n'+\n *     '\\n'+\n *     '#define draw_useSamples '+\n *         'const ivec2 draw_samples_0 = ivec2(0, 2); '+\n *         'const ivec2 draw_samples_1 = ivec2(1, 0); '+\n *         'const int draw_samples_l = 2;\\n'+\n *     '#define draw_samples_i(i) '+\n *         '((i == 1)? draw_samples_1 : draw_samples_0)\\n'+\n *     '\\n'+\n *     '#define draw_tapSamples(states, uv, textures) '+\n *         'const int data_l = 2; '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = texture2D(states[(0*textures)+2], uv); '+\n *         'data[1] = texture2D(states[(1*textures)+0], uv);\\n'+\n *         '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define draw_useReads_2 '+\n *         'const int draw_reads_2_l = 2; '+\n *         'const int draw_reads_2_0 = int(0); '+\n *         'const int draw_reads_2_1 = int(1);\\n'+\n *     '#define draw_reads_2_i(i) '+\n *         '((i == 1)? draw_reads_2_1 : draw_reads_2_0)\\n';\n *\n * @export\n * @param {object} state Properties for generating the macros. See `getState`\n *     and `mapGroups`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings for\n *     values, textures, channels, bound outputs of the active pass, etc. See\n *     `macroValues`, `macroOutput`, and `macroSamples`.\n */\nexport function macroPass(state) {\n    const key = hooks.macroPass;\n    const hook = hasMacros(state, key);\n\n    return ((hook !== false)? hook\n        :   macroValues(state)+'\\n'+macroOutput(state)+'\\n'+\n                macroSamples(state)+'\\n');\n}\n\nexport default macroPass;\n","export const setC2 = (out, x, y) => (!out && (out = []), (out[0] = x), (out[1] = y), out);\nexport const setC3 = (out, x, y, z) => (!out && (out = []), (out[0] = x), (out[1] = y), (out[2] = z), out);\nexport const setC4 = (out, x, y, z, w) => (!out && (out = []),\n    (out[0] = x),\n    (out[1] = y),\n    (out[2] = z),\n    (out[3] = w),\n    out);\nexport const setC6 = (out, a, b, c, d, e, f) => (!out && (out = []),\n    (out[0] = a),\n    (out[1] = b),\n    (out[2] = c),\n    (out[3] = d),\n    (out[4] = e),\n    (out[5] = f),\n    out);\nexport const setC = (out, ...xs) => {\n    !out && (out = []);\n    for (let i = 0, n = xs.length; i < n; i++) {\n        out[i] = xs[i];\n    }\n    return out;\n};\n","/**\n * GPGPU inputs (uniforms, attributes, indexes, etc).\n */\n\nimport { setC2 } from '@thi.ng/vectors/setc';\nimport map from '@epok.tech/fn-lists/map';\nimport range from '@epok.tech/fn-lists/range';\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap-index';\nimport isNumber from '@epok.tech/is-type/number';\n\nimport { boundDef, preDef } from './const';\n\n/**\n * Common uniform inputs for GPGPU `step` and `draw`.\n * Uniforms are defined as callback hooks pulling from given `context` and\n * `props` properties, allowing different APIs or author-defined hooks.\n *\n * @see [getState]{@link ./state.js#getState}\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n *\n * @export\n * @param {object} state The GPGPU state to use. See `getState` and `mapGroups`.\n * @param {array} state.steps The steps of state. See `getState`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures How values are grouped into\n *     textures. See `mapGroups`.\n * @param {number} [state.bound=boundDef] How many steps are bound as outputs,\n *     unavailable as inputs.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n * @param {object} [out={}] The object to contain the uniforms.\n *\n * @returns {object<function>} `out` The uniform hooks for the given `state`.\n *     Each is a function taking 2 arguments: a `context` object of general\n *     or global properties, and a `props` object of local properties (such as\n *     the given `state`).\n */\nexport function getUniforms(state, out = {}) {\n    const {\n            steps: { length: stepsL }, maps: { textures: textureMap },\n            bound = boundDef, pre: n = preDef\n        } = state;\n\n    const texturesL = textureMap.length;\n    const cache = { viewShape: [] };\n\n    out[n+'stepNow'] = (_, { stepNow: s }) => s;\n    out[n+'dataShape'] = (_, { size: { shape: s } }) => s;\n    out[n+'viewShape'] = ({ viewportWidth: w, viewportHeight: h }) =>\n        setC2(cache.viewShape, w, h);\n\n    // Set up the past steps, as the number of steps into the past from the\n    // currently bound step ([1...(steps-1)]).\n\n    const addTexture = (past, texture) =>\n        // Hook to pull a given texture from the latest `props`.\n        out[`${n}states[${(past*texturesL)+texture}]`] =\n            (_, { stepNow: s, bound: b = bound, textures }) =>\n                wrap.get(s-b-past, textures)[texture].texture;\n\n    // Flatten all input textures, as uniforms are stored in flat arrays.\n    for(let past = 0; past < stepsL-bound; ++past) {\n        each((v, texture) => addTexture(past, texture), textureMap);\n    }\n\n    return out;\n}\n\n/**\n * Gives the number of indexes needed to draw a full state.\n *\n * @param {object} size Size/type information on data resources.\n * @param {number} [size.width] The width of each data-texture.\n * @param {number} [size.height] The height of each data-texture.\n * @param {number} [size.count=size.width*size.height] How many entries are in\n *     each data-texture; that is, its area (width*height).\n *\n * @returns {number} The number of indexes needed to draw a full state.\n */\nexport const countDrawIndexes = ({ width: w, height: h, count = w*h }) => count;\n\n/**\n * Gives the array of indexes needed to draw a full state.\n *\n * @param {number|object<number>} size The number of entries in each\n *     data-texture; or an object of size/type information on data resources.\n *\n * @returns {array<number>} An array of indexes for drawing all data-texture\n *     entries.\n */\nexport const getDrawIndexes = (size) =>\n    map((v, i) => i, range(isNumber(size)? size : countDrawIndexes(size)), 0);\n","/**\n * GPGPU update step.\n */\n\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap-index';\n\nimport { macroPass } from './macros';\nimport { getUniforms } from './inputs';\nimport { vertDef, positionsDef, preDef } from './const';\n\nconst scale = { vec2: 0.5 };\n\n/**\n * Creates a GPGPU update step function, for use with a GPGPU state object.\n *\n * @todo Optional transform feedback instead of GPGPU textures, where available\n *     (needs vertex draw, instead of texture draw).\n * @todo Make this fully extensible in state.\n *\n * @see [getState]{@link ./state.js#getState}\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [macroPass]{@link ./macros.js#macroPass}\n * @see [getUniforms]{@link ./inputs.js#getUniforms}\n *\n * @export\n * @param {object} api An API for GL resources.\n * @param {function} api.buffer A function to set up a GL buffer.\n * @param {function} api.command A function to call a GL draw, with all options.\n * @param {object} state The GPGPU state to use. See `getState` and `mapGroups`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @returns {array<array<number>>} `out.passes` How textures are grouped into\n *     passes. See `mapGroups`.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n * @param {object} [state.step=out] The properties for the step GL command.\n * @param {string} [state.step.vert=vertDef] The step vertex shader GLSL; a\n *     simple flat screen shader if not given.\n * @param {string} state.step.frag The step fragment shader GLSL.\n * @param {object} [state.step.uniforms=getUniforms(state)] The step uniforms;\n *     modifies any given. See `getUniforms`.\n * @param {array|api.buffer} [state.step.positions=positionsDef()] The step\n *     position attributes; 3 points of a large flat triangle if not given.\n * @param {number} [state.step.count=state.step.positions.length*scale.vec2] The\n *     number of elements/attributes to draw.\n * @param {array} [state.step.verts] Preprocesses and caches vertex GLSL code\n *     per-pass if given, otherwise processes it just-in-time before each pass.\n * @param {array} [state.step.frags] Preprocesses and caches fragment GLSL code\n *     per-pass, otherwise processes it just-in-time before each pass.\n * @param {object} [out={}] The results object; a new object if not given.\n *\n * @returns {object} `out` The given `out` object; containing a GPGPU update\n *     step function and related properties, to be passed a GPGPU state.\n * @returns {string} `out.vert` The given/new `state.vert` vertex shader GLSL.\n * @returns {string} `out.frag` The given `state.frag` fragment shader GLSL.\n * @returns {array.string} `[out.verts]` Any cached pre-processed vertex shaders\n *     GLSL, if `state.step.verts` was given.\n * @returns {array.string} `[out.frags]` Any cached pre-processed fragment\n *     shaders GLSL, if `state.step.verts` was enabled.\n * @returns {object} `out.uniforms` The given `state.uniforms`.\n * @returns {number} `out.count` The given/new `state.count`.\n * @returns {api.buffer} `out.positions` The given/new `state.positions`; passed\n *     through `api.buffer`.\n * @returns {api.command} `out.pass` A GL command function to draw a given pass.\n * @returns {function} `out.run` The main step function, which performs all the\n *     draw pass GL commands for a given state step.\n */\nexport function getStep(api, state, out = {}) {\n    const { buffer, command = api } = api;\n    const { maps: { passes }, pre: n = preDef, step = out } = state;\n    let { positions = positionsDef() } = step;\n    const {\n            vert = vertDef, frag, verts, frags, uniforms,\n            count = positions.length*scale.vec2\n        } = step;\n\n    out.vert = vert;\n    out.frag = frag;\n    out.uniforms = getUniforms(state, uniforms);\n    out.count = count;\n    positions = out.positions = buffer(positions);\n\n    if(verts || frags) {\n        // Pre-process the shaders needed for all the passes.\n        const stateCache = { ...state };\n\n        (verts && (out.verts = verts));\n        (frags && (out.frags = frags));\n\n        each((pass, p) => {\n                stateCache.passNow = p;\n\n                const passMacros = macroPass(stateCache);\n\n                (verts && (verts[p] = passMacros+vert));\n                (frags && (frags[p] = passMacros+frag));\n            },\n            passes);\n    }\n\n    out.pass = command(out.passCommand = {\n        // Uses the full-screen vertex shader state by default.\n        vert(_, props) {\n            const { passNow: p, step } = props;\n            const { vert: v = vert, verts: vs = verts } = step;\n\n            return ((vs)? vs[p] : macroPass(props)+v);\n        },\n        frag(_, props) {\n            const { passNow: p, step } = props;\n            const { frag: f = frag, frags: fs = frags } = step;\n\n            return ((fs)? fs[p] : macroPass(props)+f);\n        },\n        attributes: {\n            [n+'position']: (_, { step: { positions: p = positions } }) => p\n        },\n        uniforms,\n        count,\n        depth: { enable: false },\n        framebuffer: (_, { steps: a, stepNow: s, passNow: p }) =>\n            wrap.get(s, a)[p]\n    });\n\n    out.run = (props = state) => {\n        const { step: { pass, onPass, onStep }, maps: { passes } } = props;\n\n        ++props.stepNow;\n        (onStep && onStep(props, wrap.get(props.stepNow, props.steps)));\n\n        each((passProps, p) => {\n                props.passNow = p;\n                pass((onPass)? onPass(props, passProps) : props);\n            },\n            passes);\n\n        return props;\n    };\n\n    return out;\n}\n\nexport default getStep;\n","/**\n * GPGPU state-stepping: maps minimal draw passes, shaders, GL resources,\n * inputs, outputs. BYORenderer.\n *\n * Rendering approach/engine specific, decoupled from the physics code.\n * The modules and many hooks may be used as given, or piecemeal, or overridden.\n */\n\nimport { mapGroups, mapSamples } from './maps';\nimport { getState } from './state';\nimport { getStep } from './step';\n\nexport * from './const';\n\n/**\n * Sets up all the maps, inputs, resources, etc for a GPGPU process.\n *\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [mapSamples]{@link ./maps.js#mapSamples}\n * @see [getState]{@link ./step.js#getState}\n * @see [getUniforms]{@link ./step.js#getUniforms}\n * @see [getStep]{@link ./step.js#getStep}\n * @see [macroPass]{@link ./macros.js#macroPass}\n *\n * @param {object} api An API for GL resources. See `getState` and `getStep`.\n * @param {object} [api.limits=api] A map of GL resource limits.\n * @param {number} [api.limits.maxDrawbuffers] The maximum number of GL textures\n *     a framebuffer can bind in a single draw call.\n * @param {object} [state={}] State properties to set up; a new object by\n *     default. See `getState`, `getUniforms`, and `getStep`.\n * @param {object} [state.maps] How values are grouped per-texture per-pass\n *     per-step. Sets up new maps if not given or missing its mapped properties.\n *     See `mapGroups`.\n * @param {number} [state.maps.texturesMax=api.limits.maxDrawbuffers] The\n *     maximum number of textures to use per draw pass. Uses more passes above\n *     this limit.\n * @param {object} [out=state] The state object to set up. Modifies the given\n *     `state` object by default.\n */\nexport function gpgpu(api, state = {}, out = state) {\n    const { maxDrawbuffers: texturesMax, glsl } = (api.limits || api);\n    const { maps = {} } = state;\n\n    out.glsl = parseFloat(glsl.match(/[0-9\\.]+/)[0]);\n\n    (('texturesMax' in maps) || (maps.texturesMax = texturesMax));\n    ((('textures' in maps) && ('passes' in maps)) || mapGroups(maps));\n    ((('derives' in maps) && !('samples' in maps)) && mapSamples(maps));\n    out.maps = maps;\n\n    getState(api, state, out);\n    out.step = getStep(api, state);\n\n    return out;\n}\n\nexport default gpgpu;\n","/**\n * How many vertexes for pairs of line segments linking each entry's states,\n * using `gl.LINES`.\n * If fewer than 2 states are given, lines can't be drawn, assumes `gl.POINTS`.\n * Every pair of indexes is a line-segment connecting each state to its past\n * state, making one continuous line back through steps using `gl.LINES`;\n * iterating each start index and its past index.\n * Corresponds to the indexing logic in the `linesPairs` GLSL function.\n *\n * @see `gl.LINES` at https://webglfundamentals.org/webgl/lessons/webgl-points-lines-triangles.html\n * @see [linesPairs]{@link ./index.glsl#linesPairs}\n *\n * @example\n *     // 2 entries, 3 steps, 8 indexes:\n *     [0, 1, 2, 3, 4, 5, 6, 7]\n *     // 2 lines, 2 segments each:\n *     [[[0, 1], [1, 2]], [[0, 1], [1, 2]]]\n *     // 2 lines of entry indexes:\n *     [[[0, 0], [0, 0]], [[1, 1], [1, 1]]]\n * @example\n *     // 2 entries, 4 steps, 12 indexes:\n *     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n *     // 2 lines, 3 segments each:\n *     [[[0, 1], [1, 2], [2, 3]], [[0, 1], [1, 2], [2, 3]]]\n *     // 2 lines of entry indexes:\n *     [[[0, 0], [0, 0], [0, 0]], [[1, 1], [1, 1], [1, 1]]]\n * @example\n *     // 3 entries, 3 steps, 12 indexes:\n *     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n *     // 3 lines, 2 segments each:\n *     [[[0, 1], [1, 2]], [[0, 1], [1, 2]], [[0, 1], [1, 2]]]\n *     // 3 lines of entry indexes:\n *     [[[0, 0], [0, 0]], [[1, 1], [1, 1]], [[2, 2], [2, 2]]]\n * @example\n *     // 1 entry, 2 steps, 2 indexes:\n *     [0, 1]\n *     // 1 line, 1 segment:\n *     [[[0, 1]]]\n *     // 2 lines of entry indexes:\n *     [[[0, 0]]]\n *\n * @param {number} states The number of steps of state to link by pairs of line\n *     segments.\n *\n * @returns {number} The number of points needed to link all steps of state\n *     by pairs of line segments. May be multiplied with the number of entries\n *     in each step.\n */\nexport const linesPairs = (states) => Math.max(1, (states-1)*2);\n\nexport default linesPairs;\n","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\n\\nvarying vec2 uv;\\n\\n// Translation for UV NDC to texture coordinates.\\nconst vec2 offset = vec2(0.5);\\n\\nvoid main() {\\n    uv = (position*0.5)+offset;\\n    gl_Position = vec4(position, 0, 1);\\n}\\n\";","module.exports=\"/**\\n * The update step for a GPGPU particle simulation.\\n * Requires setup with preprocessor macros - see `macroPass`.\\n *\\n * @see [getStep]{@link ../step.js#getStep}\\n * @see [macroPass]{@link ../macros.js#macroPass}\\n */\\n\\n#ifdef GL_EXT_draw_buffers\\n    #extension GL_EXT_draw_buffers : require\\n#endif\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\n// Setting up the macros and aliases.\\n\\n#define posTexture texture_0\\n#define lifeTexture texture_1\\n#define accTexture texture_2\\n\\n#define posChannels channels_0\\n#define lifeChannels channels_1\\n#define accChannels channels_2\\n\\nuseSamples\\n\\n#ifdef output_0\\n    #define posOutput output_0\\n    useReads_0\\n    #define posReadPos0 reads_0_i(0)\\n    #define posReadPos1 reads_0_i(1)\\n    #define posReadAcc reads_0_i(2)\\n    #define posReadLife reads_0_i(3)\\n#endif\\n#ifdef output_1\\n    #define lifeOutput output_1\\n    useReads_1\\n    #define lifeReadLifeOldest reads_1_i(0)\\n    #define lifeReadLife1 reads_1_i(1)\\n#endif\\n#ifdef output_2\\n    #define accOutput output_2\\n    useReads_2\\n    #define accReadAcc reads_2_i(0)\\n    #define accReadLife reads_2_i(1)\\n#endif\\n\\n// The main shader.\\n\\n// States from `gl-gpgpu`.\\nuniform sampler2D states[stepsPast*textures];\\n// Custom inputs for this demo.\\nuniform float dt;\\nuniform float time;\\nuniform float loop;\\nuniform vec2 lifetime;\\nuniform float force;\\nuniform float useVerlet;\\nuniform vec3 g;\\nuniform vec3 source;\\n\\nvarying vec2 uv;\\n\\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\\n}\\n\\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\\n}\\n\\nvec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\\n}\\n\\nvec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\\n}\\n\\n#ifdef posOutput\\n    /**\\n * GLSL Verlet integration in 1-3 dimensions.\\n * See slide 26 of the second part of Acko's Animating Your Way to Glory.\\n * @see http://acko.net/blog/animate-your-way-to-glory/\\n *\\n * @todo Use macro to repeat calculation in any dimension?\\n *\\n * @param {float|vec2|vec3} a Acceleration.\\n * @param {float|vec2|vec3} p0 Past position.\\n * @param {float|vec2|vec3} p1 Current position.\\n * @param {float} dt0 Time elapsed in the last frame.\\n * @param {float} dt1 Time elapsed in the current frame.\\n *\\n * @returns {float|vec2|vec3} The new position.\\n */\\n\\nfloat verlet(in float a, in float p0, in float p1, in float dt0, in float dt1) {\\n    return (2.0*p1)-p0+(a*dt0*dt1);\\n}\\n\\nvec2 verlet(in vec2 a, in vec2 p0, in vec2 p1, in float dt0, in float dt1) {\\n    return (2.0*p1)-p0+(a*dt0*dt1);\\n}\\n\\nvec3 verlet(in vec3 a, in vec3 p0, in vec3 p1, in float dt0, in float dt1) {\\n    return (2.0*p1)-p0+(a*dt0*dt1);\\n}\\n\\n/**\\n * Constant time-step versions.\\n *\\n * @param {float|vec2|vec3} a Acceleration.\\n * @param {float|vec2|vec3} p0 Last position.\\n * @param {float|vec2|vec3} p1 Current position.\\n * @param {float} dt Time elapsed.\\n *\\n * @returns {float|vec2|vec3} The new position.\\n */\\n\\nfloat verlet(in float a, in float p0, in float p1, in float dt) {\\n    return verlet(a, p0, p1, dt, dt);\\n}\\n\\nvec2 verlet(in vec2 a, in vec2 p0, in vec2 p1, in float dt) {\\n    return verlet(a, p0, p1, dt, dt);\\n}\\n\\nvec3 verlet(in vec3 a, in vec3 p0, in vec3 p1, in float dt) {\\n    return verlet(a, p0, p1, dt, dt);\\n}\\n\\n#endif\\n\\n#if defined(lifeOutput) || defined(accOutput)\\n    highp float random(vec2 co)\\n{\\n    highp float a = 12.9898;\\n    highp float b = 78.233;\\n    highp float c = 43758.5453;\\n    highp float dt= dot(co.xy ,vec2(a,b));\\n    highp float sn= mod(dt,3.14);\\n    return fract(sin(sn) * c);\\n}\\n\\n#endif\\n\\n#ifdef accOutput\\n    const float tau = 6.28318530718;\\n\\n    // @see https://observablehq.com/@rreusser/equally-distributing-points-on-a-sphere\\n    vec3 randomOnSphere(vec2 randoms) {\\n        float a = randoms[0]*tau;\\n        float u = (randoms[1]*2.0)-1.0;\\n\\n        return vec3(sqrt(1.0-(u*u))*vec2(cos(a), sin(a)), u);\\n    }\\n#endif\\n\\nfloat when_gt_2281831123(float x, float y) {\\n  return max(sign(x - y), 0.0);\\n}\\n\\nvec2 when_gt_2281831123(vec2 x, vec2 y) {\\n  return max(sign(x - y), 0.0);\\n}\\n\\nvec3 when_gt_2281831123(vec3 x, vec3 y) {\\n  return max(sign(x - y), 0.0);\\n}\\n\\nvec4 when_gt_2281831123(vec4 x, vec4 y) {\\n  return max(sign(x - y), 0.0);\\n}\\n\\nfloat when_le_529295689(float x, float y) {\\n  return 1.0 - when_gt_2281831123(x, y);\\n}\\n\\nvec2 when_le_529295689(vec2 x, vec2 y) {\\n  return 1.0 - when_gt_2281831123(x, y);\\n}\\n\\nvec3 when_le_529295689(vec3 x, vec3 y) {\\n  return 1.0 - when_gt_2281831123(x, y);\\n}\\n\\nvec4 when_le_529295689(vec4 x, vec4 y) {\\n  return 1.0 - when_gt_2281831123(x, y);\\n}\\n\\nvoid main() {\\n    // Sample textures.\\n    tapSamples(states, uv, textures)\\n\\n    // Read values.\\n\\n    #ifdef posOutput\\n        vec3 pos0 = data[posReadPos0].posChannels;\\n    #endif\\n    #if defined(lifeOutput) || defined(posOutput)\\n        vec3 pos1 = data[posReadPos1].posChannels;\\n    #endif\\n\\n    #if defined(lifeOutput) || defined(posOutput) || defined(accOutput)\\n        #if defined(posOutput)\\n            #define readLife posReadLife\\n        #elif defined(lifeOutput)\\n            #define readLife lifeReadLife\\n        #elif defined(accOutput)\\n            #define readLife accReadLife\\n        #endif\\n\\n        float life = data[readLife].lifeChannels;\\n        float spawn = when_le_529295689(life, 0.0);\\n    #endif\\n\\n    #if defined(lifeOutput)\\n        float lifeOldest = data[lifeReadLifeOldest].lifeChannels;\\n    #endif\\n\\n    #if defined(posOutput) || defined(accOutput)\\n        #if defined(posOutput)\\n            #define readAcc posReadAcc\\n        #elif defined(accOutput)\\n            #define readAcc accReadAcc\\n        #endif\\n\\n        vec3 acc = data[readAcc].accChannels;\\n    #endif\\n\\n    // Output updated values.\\n    #ifdef posOutput\\n        // Use either Euler or Verlet integration.\\n        vec3 pos = mix(pos1+(acc*dt*force), verlet(acc, pos0, pos1, dt),\\n            useVerlet);\\n\\n        posOutput = mix(pos, source, spawn);\\n    #endif\\n    #ifdef lifeOutput\\n        life = max(0.0, life-dt);\\n\\n        float lifeSpawn = map(random(uv*loop),\\n            0.0, 1.0, lifetime[0], lifetime[1]);\\n\\n        // Only spawn life once the oldest step reaches the end of its lifetime\\n        // (past and current life are both 0).\\n        lifeOutput = mix(life, lifeSpawn, spawn*when_le_529295689(lifeOldest, 0.0));\\n    #endif\\n    #ifdef accOutput\\n        acc += g*dt*force;\\n\\n        vec2 randoms = vec2(random((uv+loop)/dt), random((uv-loop)*dt));\\n        vec3 accSpawn = randomOnSphere(randoms)*(random((loop-uv)*dt)*force);\\n\\n        accOutput = mix(acc, accSpawn, spawn);\\n    #endif\\n}\\n\";","module.exports=\"/**\\n * Drawing a GPGPU particle simulation.\\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\\n *\\n * @see [macroPass]{@link ../macros.js#macroPass}\\n * @see [macroValues]{@link ../macros.js#macroValues}\\n */\\n\\n#define posTexture texture_0\\n#define lifeTexture texture_1\\n#define accTexture texture_2\\n\\n#define posChannels channels_0\\n#define lifeChannels channels_1\\n#define accChannels channels_2\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nattribute float index;\\n\\nuniform sampler2D states[stepsPast*textures];\\nuniform vec2 dataShape;\\nuniform vec2 viewShape;\\nuniform float pointSize;\\nuniform vec2 lifetime;\\n\\nvarying vec4 color;\\n\\nfloat when_gt_1540259130(float x, float y) {\\n  return max(sign(x - y), 0.0);\\n}\\n\\nvec2 when_gt_1540259130(vec2 x, vec2 y) {\\n  return max(sign(x - y), 0.0);\\n}\\n\\nvec3 when_gt_1540259130(vec3 x, vec3 y) {\\n  return max(sign(x - y), 0.0);\\n}\\n\\nvec4 when_gt_1540259130(vec4 x, vec4 y) {\\n  return max(sign(x - y), 0.0);\\n}\\n\\n/**\\n * The step and entry indexes corrseponding to how many vertexes for pairs of\\n * line segments to link each entry's states, as detailed in the `linesPairs` JS\\n * function.\\n *\\n * @see [linesPairs]{@link ./index.js#linesPairs}\\n *\\n * @param {float|int} index The index of a vertex (assumes simple sequential\\n *     index attribute).\\n * @param {float|int} states How many steps of state each entry has.\\n *\\n * @returns {vec2|ivec2} The step and entry index, respectively, to look up the\\n *     correct data to draw a line along each entry's steps of state.\\n */\\nvec2 linesPairs(float index, float states) {\\n    float i = index/2.0;\\n    float s = states-1.0;\\n    float d = floor(i/s);\\n\\n    // Equivalent, but can avoid recalculating part of modulo, reusing `d`.\\n    // @see https://www.shaderific.com/glsl-functions#modulo\\n    // float m = mod(i, s);\\n    float m = i-(s*d);\\n\\n    return vec2(ceil(m), d);\\n}\\n\\nivec2 linesPairs(int index, int states) {\\n    return ivec2(linesPairs(float(index), float(states)));\\n}\\n\\nvoid main() {\\n    #if stepsPast < 2\\n        // If fewer than 2 steps are given, uses `gl.POINTS`.\\n        vec2 stepEntry = vec2(0.0, index);\\n    #else\\n        vec2 stepEntry = linesPairs(index, float(stepsPast));\\n    #endif\\n\\n    // Step back a full state's worth of textures per step index.\\n    int stateIndex = int(stepEntry[0])*textures;\\n\\n    // Turn the 1D index into a 2D texture UV - adding a half-pixel offset to\\n    // ensure sampling from the pixel's center and avoid errors.\\n    vec2 uv = vec2(mod(stepEntry[1]+0.5, dataShape.x)/dataShape.x,\\n        (floor(stepEntry[1]/dataShape.x)+0.5)/dataShape.y);\\n\\n    // Sample the desired state values.\\n    // @todo Make use of the `reads` logic to take the minimum possible samples.\\n    vec3 pos = texture2D(states[stateIndex+posTexture], uv).posChannels;\\n    float life = texture2D(states[stateIndex+lifeTexture], uv).lifeChannels;\\n    float l = pow(life/lifetime[1], 0.2);\\n\\n    color = mix(vec4(l),\\n        vec4(stepEntry[0]/float(stepsPast), stepEntry[1]/float(count), 0.4, l),\\n        0.3);\\n\\n    gl_Position = vec4(pos/max(viewShape.x, viewShape.y), 1)*when_gt_1540259130(life, 0.0);\\n    gl_PointSize = pointSize*l;\\n}\\n\";","module.exports=\"/**\\n * Drawing a GPGPU particle simulation.\\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\\n *\\n * @see [macroPass]{@link ../macros.js#macroPass}\\n * @see [macroValues]{@link ../macros.js#macroValues}\\n */\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec4 color;\\n\\nvoid main() { gl_FragColor = color; }\\n\";","/**\n * Test implementation of 3D particle Verlet-integration simulation.\n */\nimport getRegl from 'regl';\nimport timer from '@epok.tech/fn-time';\nimport { count, vertices } from '@epok.tech/gl-screen-triangle';\nimport wrap from '@epok.tech/fn-lists/wrap-index';\n\nimport { gpgpu, extensions, optionalExtensions } from '../';\nimport { macroValues } from '../macros';\nimport { getUniforms, countDrawIndexes, getDrawIndexes } from '../inputs';\nimport linesPairs from './lines-pairs';\n\nimport stepVert from '@epok.tech/gl-screen-triangle/uv-texture.vert.glsl';\n\nimport stepFrag from './step.frag.glsl';\n\nimport drawVert from './draw.vert.glsl';\nimport drawFrag from './draw.frag.glsl';\n\nconst regl = self.regl = getRegl({\n    extensions: extensions(), optionalExtensions: optionalExtensions()\n});\n\nconst query = document.location.search.match(/(?:[\\?\\&]addSteps=)([\\-0-9]+)/i);\n\nconst bound = 1;\n// 1 active state, 2 past states needed for Verlet integration, plus as many\n// others as can be bound.\nconst steps = bound+2+((query && parseInt(query[1], 10)) || 0);\nconst scale = Math.floor(10-(Math.sqrt(steps)/2));\n\n// How many values/channels each property independently tracks.\nconst valuesMap = { position: 3, life: 1, acceleration: 3 };\nconst valuesKeys = Object.keys(valuesMap);\nconst derivesMap = {\n    position: [\n        // Position, 2 steps past.\n        [Math.min(steps-1-bound, 1), valuesKeys.indexOf('position')],\n        // Position, 1 step past.\n        valuesKeys.indexOf('position'),\n        valuesKeys.indexOf('acceleration'),\n        valuesKeys.indexOf('life')\n    ],\n    life: [\n        // Life, oldest step.\n        [Math.max(0, steps-1-bound), valuesKeys.indexOf('life')],\n        // Life, 1 step past.\n        valuesKeys.indexOf('life')\n    ],\n    acceleration: [\n        valuesKeys.indexOf('acceleration'), valuesKeys.indexOf('life')\n    ]\n};\n\nconst values = Object.values(valuesMap);\nconst derives = Object.values(derivesMap);\n\nconst canVerlet = (steps, bound) => steps-bound >= 2;\n\nconst state = gpgpu(regl, {\n    props: {\n        timer: {\n            // Real-time, look-behind delta-time.\n            step: '-', time: regl.now()*1e3,\n            // Fixed-step, look-ahead add-time.\n            // step: '+', time: 0, step: 1e3/60,\n        },\n        // Speed up or slow down the passage of time.\n        rate: 1,\n        // Loop time over this period to avoid instability of parts of the demo.\n        loop: 3e3,\n        // Whether to use Verlet (midpoint) or Euler (forward) integration.\n        useVerlet: true,\n        // Range of how long a particle lives before respawning.\n        lifetime: [1e3, 2e3],\n        // Acceleration due to gravity.\n        g: [0, -9.807e-3, 0],\n        // The position particles respawn from.\n        source: [0, 0, 0]\n    },\n    bound, steps, scale,\n    maps: { values: [...values], derives: [...derives] },\n    step: {\n        vert: stepVert, frag: stepFrag,\n        verts: [], frags: [],\n        uniforms: {\n            dt: (_, { props: { timer: { dt }, rate } }) => dt*rate,\n            time: (_, { props: { timer: { time }, rate } }) => time*rate,\n            loop: (_, { props: { timer: { time }, loop } }) =>\n                Math.sin(time/loop*Math.PI)*loop,\n            lifetime: regl.prop('props.lifetime'),\n            g: regl.prop('props.g'),\n            source: regl.prop('props.source'),\n            force: (_, { steps: s, bound: b, props: { useVerlet: v } }) =>\n                ((canVerlet(s.length, b) && v)? 1e-3 : 1),\n            useVerlet: (_, { steps: s, bound: b, props: { useVerlet: v } }) =>\n                +(canVerlet(s.length, b) && v)\n        }\n    }\n});\n\ntimer(state.props.timer, state.props.timer.time);\n\nconsole.log(self.state = state);\n\nconst drawCount = countDrawIndexes(state.size)*\n    // @todo Why does `bound` not seem to make much difference?\n    // linesPairs(state.steps.length-state.bound);\n    linesPairs(state.steps.length);\n\nconst drawIndexes = getDrawIndexes(drawCount);\nconst drawState = { ...state };\n\nconst drawCommand = {\n    vert: macroValues(drawState)+'\\n'+drawVert,\n    frag: drawFrag,\n    attributes: { index: drawIndexes },\n    uniforms: getUniforms(drawState,\n        { ...drawState.step.uniforms, pointSize: 4 }),\n    lineWidth: 1,\n    count: drawCount,\n    primitive: ((drawState.steps.length > 2)? 'lines' : 'points')\n};\n\nconsole.log((self.drawCommand = drawCommand), drawCount);\n\nconst draw = regl(drawCommand);\n\nregl.frame(() => {\n    // Real-time.\n    timer(state.props.timer, regl.now()*1e3);\n    // Fixed-step.\n    // timer(state.props.timer, state.props.timer.step);\n\n    state.step.run();\n    drawState.stepNow = state.stepNow;\n    draw(drawState);\n});\n\nself.addEventListener('click', () =>\n    console.log('useVerlet',\n        (state.props.useVerlet = (canVerlet(state.steps.length, state.bound) &&\n            !state.props.useVerlet))));\n"]}