{"mappings":"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","sources":["demo/particles/index.js","node_modules/@swc/helpers/src/_define_property.js","node_modules/@swc/helpers/src/_object_spread.js","node_modules/@swc/helpers/src/_sliced_to_array.js","node_modules/@swc/helpers/src/_array_with_holes.js","node_modules/@swc/helpers/src/_iterable_to_array.js","node_modules/@swc/helpers/src/_non_iterable_rest.js","node_modules/@swc/helpers/src/_to_consumable_array.js","node_modules/@swc/helpers/src/_array_without_holes.js","node_modules/@swc/helpers/src/_non_iterable_spread.js","node_modules/querystring-es3/index.js","node_modules/querystring-es3/decode.js","node_modules/querystring-es3/encode.js","node_modules/@epok.tech/fn-time/dist/es/index.js","node_modules/@epok.tech/gl-screen-triangle/index.js","node_modules/@epok.tech/fn-lists/wrap-index.js","index.js","maps.js","node_modules/@epok.tech/fn-lists/map.js","node_modules/@epok.tech/fn-lists/reduce.js","node_modules/@epok.tech/fn-lists/each.js","const.js","node_modules/@epok.tech/gl-screen-triangle/index.vert.glsl","state.js","node_modules/@epok.tech/fn-lists/range.js","node_modules/@epok.tech/is-type/number.js","node_modules/@epok.tech/is-type/type.js","step.js","macros.js","inputs.js","node_modules/@thi.ng/vectors/setc.js","index-pairs/index.js","node_modules/@epok.tech/gl-screen-triangle/uv-texture.vert.glsl","demo/particles/step.frag.glsl","demo/particles/draw.vert.glsl","demo/particles/draw.frag.glsl"],"sourcesContent":["/**\n * Test implementation of 3D particle Verlet-integration simulation.\n */\nimport getRegl from 'regl';\nimport querystring from 'querystring';\nimport timer from '@epok.tech/fn-time';\nimport { count, vertices } from '@epok.tech/gl-screen-triangle';\nimport wrap from '@epok.tech/fn-lists/wrap-index';\n\nimport { gpgpu, extensionsFloat, optionalExtensions } from '../../index';\nimport { macroValues } from '../../macros';\nimport { getUniforms, countDrawIndexes, getDrawIndexes } from '../../inputs';\nimport indexPairs from '../../index-pairs';\n\nimport stepVert from '@epok.tech/gl-screen-triangle/uv-texture.vert.glsl';\n\nimport stepFrag from './step.frag.glsl';\n\nimport drawVert from './draw.vert.glsl';\nimport drawFrag from './draw.frag.glsl';\n\nconst reglProps = {\n    extensions: extensionsFloat(), optionalExtensions: optionalExtensions()\n};\n\nconst regl = self.regl = getRegl(reglProps);\n\nconsole.log('extensions',\n    ...reglProps.extensions.map((e) => e+': '+regl.hasExtension(e)));\n\nconsole.log('optionalExtensions',\n    ...reglProps.optionalExtensions.map((e) => e+': '+regl.hasExtension(e)));\n\nconst canvas = document.querySelector('canvas');\n\nconst query = querystring.parse(document.location.search.slice(1));\nconst bound = 1;\n// 1 active state, 2 past states needed for Verlet integration, plus as many\n// others as can be bound.\nconst steps = bound+(parseInt(query.steps, 10) || 2);\nconst scale = Math.floor((parseInt(query.scale, 10) || 9)-(Math.sqrt(steps)/2));\n\n// How many values/channels each property independently tracks.\nconst valuesMap = { position: 3, life: 1, acceleration: 3 };\nconst valuesKeys = Object.keys(valuesMap);\nconst derivesMap = {\n    position: [\n        // Position, 2 steps past.\n        [Math.min(steps-1-bound, 1), valuesKeys.indexOf('position')],\n        // Position, 1 step past.\n        valuesKeys.indexOf('position'),\n        valuesKeys.indexOf('acceleration'),\n        valuesKeys.indexOf('life')\n    ],\n    life: [\n        // Life, oldest step.\n        [Math.max(0, steps-1-bound), valuesKeys.indexOf('life')],\n        // Life, 1 step past.\n        valuesKeys.indexOf('life')\n    ],\n    acceleration: [\n        valuesKeys.indexOf('acceleration'), valuesKeys.indexOf('life')\n    ]\n};\n\nconst values = Object.values(valuesMap);\nconst derives = Object.values(derivesMap);\n\nconst canVerlet = (steps, bound) => steps-bound >= 2;\n\nconst state = gpgpu(regl, {\n    props: {\n        timer: {\n            // Real-time, look-behind delta-time.\n            step: '-', time: regl.now()*1e3,\n            // Fixed-step, look-ahead add-time.\n            // step: '+', time: 0, step: 1e3/60,\n        },\n        // Speed up or slow down the passage of time.\n        rate: 1,\n        // Loop time over this period to avoid instability of parts of the demo.\n        loop: 3e3,\n        // Whether to use Verlet (midpoint) or Euler (forward) integration.\n        useVerlet: true,\n        // Range of how long a particle lives before respawning.\n        lifetime: [1e3, 5e3],\n        // Acceleration due to gravity.\n        g: [0, -9.80665, 0],\n        // The position particles respawn from.\n        source: [0, 0, 0],\n        // To help accuracy of very small numbers, pass force as `[x, y] = xEy`.\n        // One of these options chosen depending on integration used.\n        force: [\n            // Euler.\n            [1, -4],\n            // Verlet.\n            [1, -7]\n        ],\n        // To help with accuracy of small numbers, uniformly scale the drawing.\n        // scale: 1\n        scale: 1e-3\n    },\n    bound, steps, scale,\n    maps: { values: [...values], derives: [...derives] },\n    step: {\n        vert: stepVert, frag: stepFrag,\n        verts: [], frags: [],\n        uniforms: {\n            dt: (_, { props: { timer: { dt }, rate } }) => dt*rate,\n            time: (_, { props: { timer: { time }, rate } }) => time*rate,\n            loop: (_, { props: { timer: { time }, loop } }) =>\n                Math.sin(time/loop*Math.PI)*loop,\n            lifetime: regl.prop('props.lifetime'),\n            g: regl.prop('props.g'),\n            source: regl.prop('props.source'),\n            scale: regl.prop('props.scale'),\n            force: (_, { steps: s, bound: b, props: { useVerlet, force } }) =>\n                force[+(useVerlet && canVerlet(s.length, b))],\n            useVerlet: (_, { steps: s, bound: b, props: { useVerlet } }) =>\n                +(useVerlet && canVerlet(s.length, b))\n        }\n    }\n});\n\ntimer(state.props.timer, state.props.timer.time);\n\nconsole.log(self.state = state);\n\nconst drawCount = countDrawIndexes(state.size)*\n    // @todo Why does `bound` not seem to make much difference?\n    // indexPairs(state.steps.length-state.bound);\n    indexPairs(state.steps.length);\n\nconst drawIndexes = getDrawIndexes(drawCount);\nconst drawState = { ...state };\n\nconst drawCommand = {\n    vert: macroValues(drawState)+'\\n'+drawVert,\n    frag: drawFrag,\n    attributes: { index: drawIndexes },\n    uniforms: getUniforms(drawState,\n        { ...drawState.step.uniforms, pointSize: 4 }),\n    lineWidth: 1,\n    count: drawCount,\n    primitive: ((drawState.steps.length > 2)? 'lines' : 'points')\n};\n\nconsole.log((self.drawCommand = drawCommand), drawCount);\n\nconst draw = regl(drawCommand);\n\nregl.frame(() => {\n    // Real-time.\n    timer(state.props.timer, regl.now()*1e3);\n    // Fixed-step.\n    // timer(state.props.timer, state.props.timer.step);\n\n    state.step.run();\n    drawState.stepNow = state.stepNow;\n    draw(drawState);\n});\n\nself.addEventListener('click', () =>\n    console.log('useVerlet',\n        (state.props.useVerlet = (canVerlet(state.steps.length, state.bound) &&\n            !state.props.useVerlet))));\n\ncanvas.addEventListener('touchmove', (e) => {\n    e.stopPropagation();\n    e.preventDefault();\n});\n\ncanvas.addEventListener((('onpointermove' in self)? 'pointermove'\n        :   (('ontouchmove' in self)? 'touchmove' : 'mousemove')),\n    (e) => {\n        const { clientX: x, clientY: y } = e;\n        const { source, scale } = state.props;\n        const size = Math.min(innerWidth, innerHeight);\n\n        source[0] = ((((x-((innerWidth-size)*0.5))/size)*2)-1)/scale;\n        source[1] = -((((y-((innerHeight-size)*0.5))/size)*2)-1)/scale;\n\n        e.stopPropagation();\n        e.preventDefault();\n    });\n\nmodule?.hot?.accept?.(() => location.reload());\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n","import defineProperty from './_define_property';\n\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import arrayWithHoles from './_array_with_holes';\nimport iterableToArrayLimit from './_iterable_to_array';\nimport nonIterableRest from './_non_iterable_rest';\n\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n","import arrayWithoutHoles from './_array_without_holes';\nimport iterableToArray from './_iterable_to_array';\nimport nonIterableSpread from './_non_iterable_spread';\n\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","/**\n * Simple time-stepping - frame, real-time, constant-step - via any API.\n */\n\nexport const steps = {\n    diff: -1, pause: 0, add: 1,\n    '📏': -1, '⏸': 0, add: '⏭',\n    '-1': -1, '0': 0, '1': 1,\n    '-': -1, '0': 0, '+': 1\n};\n\nexport const stepDef = steps.add;\nexport const startDef = 0;\nexport const timeDef = 1000/60;\n\n/**\n * Sets up properties needed to track time, starts/steps time in various ways.\n *\n * @example\n *     // Initial call sets up properties.\n *     const frame0 = { step: '-', time: Date.now() };\n *\n *     timer(frame0, frame0.time); // =>\n *     { ...frame0, dt: 0 };\n *\n *     // Subsequent calls advance time and track difference.\n *     const frame1 = { ...frame0 };\n *     const next = Date.now();\n *\n *     timer(frame0, next, frame1); // =>\n *     { ...frame1, dt: next-frame0.time, time: next };\n *\n * @param {object} state The state being tracked.\n * @param {number} [state.time=startDef] The initial time.\n * @param {string|number} [state.step=stepDef] How time advances:\n *     - Adding a time-step (`steps.add`/`'-'`, or a positive number).\n *     - Pausing (`steps.pause`/`'-'`, or `0`).\n *     - Diff from the latest time (`steps.diff`/`'-'`, or a negative number).\n * @param {number|function} [time=timeDef] The time (clock/frame/etc), or a\n *     function giving it; current time or time-step, according to `state.step`.\n * @param {object|false} [out=state] The state to set up; modifies `state` by\n *     default; or if falsey, returns the relevant calculated time value:\n *     - The latest time if add-stepping forwards, or paused.\n *     - The time-difference if diff-stepping from the latest time.\n *\n * @returns {object|number} The given `out` set up with its initial time; or if\n *     `out` is falsey, returns the initial time.\n */\nexport function timer(state, time = timeDef, out = state) {\n    // Get the initial time and step-step.\n    const { time: t0 = startDef, step = stepDef } = state;\n    // Get the step mode - from a key into `steps` or a numerical value.\n    const d = ((step in steps)? steps[step] : step);\n    // Step the time - '0' pauses; '+' adds a time-step; '-' sets time, to diff.\n    const t1 = ((!d)? t0 : ((d > 0)? t0 : 0)+((isNaN(time))? time() : time));\n    const dt = t1-t0;\n\n    // If only returning a value, return the unknown one as calculated:\n    // - The latest time if add-stepping forwards, or paused.\n    // - The time-difference if diff-stepping from the latest time.\n    if(!out) { return ((d >= 0)? t1 : dt); }\n\n    out.time = t1;\n    out.dt = dt;\n\n    return out;\n}\n\nexport default timer;\n","/**\n * The 3 vertices of a 2D triangle covering the viewport in NDC coordinates ([-1, 1]).\n *\n * @export\n * @type {array.<array.<number>>}\n */\nexport const vertices = [[-1, -1], [-1, 4], [4, -1]];\n\nexport const count = vertices.length;\nexport const dim = 2;\n\n/**\n * The flat array of the above triangle, to be bound as a WebGL attribute buffer for\n * rendering the triangle in the vertex shader.\n * These positions will result in clipped NDC coordinates ([-1, 1]) over the\n * viewport's width and height.\n *\n * @export\n * @type {array.<number>}\n */\nexport const positions = vertices.flat();\n\nexport default positions;\n","/**\n * Wraps an index within a given length, so that indexes greater than the length\n * loop back past 0, and indexes less than 0 loop backward from the length.\n * Similar to the indexing behaviour of `Array.slice`.\n *\n * @param {number} i The index to wrap.\n * @param {number} l The length to wrap the index within.\n *\n * @returns {number} The index wrapped within the length.\n */\nexport const wrapIndex = (i, l) => ((i%l)+l)%l;\n\n/**\n * Gives the entry at a wrapped index of a given list, never exceeds its bounds.\n *\n * @see wrapIndex\n *\n * @param {number} i The index to wrap.\n * @param {array} a A list to index (array or array-like object).\n * @param {number} a.length The length property of the given list.\n *\n * @returns {*} The entry at the wrapped index of the given list.\n */\nexport const wrapGet = (i, a) => a[wrapIndex(i, a.length)];\n\nexport const wrap = { index: wrapIndex, get: wrapGet };\n\nexport default wrap;\n","/**\n * GPGPU state-stepping: maps minimal draw passes, shaders, GL resources,\n * inputs, outputs. BYORenderer.\n *\n * Rendering approach/engine specific, decoupled from the physics code.\n * The modules and many hooks may be used as given, or piecemeal, or overridden.\n */\n\nimport { mapGroups, mapSamples } from './maps';\nimport { getState } from './state';\nimport { getStep } from './step';\n\nexport * from './const';\n\n/**\n * Sets up all the maps, inputs, resources, etc for a GPGPU process.\n *\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [mapSamples]{@link ./maps.js#mapSamples}\n * @see [getState]{@link ./step.js#getState}\n * @see [getUniforms]{@link ./step.js#getUniforms}\n * @see [getStep]{@link ./step.js#getStep}\n * @see [macroPass]{@link ./macros.js#macroPass}\n *\n * @param {object} api An API for GL resources. See `getState` and `getStep`.\n * @param {object} [api.limits=api] A map of GL resource limits.\n * @param {number} [api.limits.maxDrawbuffers] The maximum number of GL textures\n *     a framebuffer can bind in a single draw call.\n * @param {object} [state={}] State properties to set up; a new object by\n *     default. See `getState`, `getUniforms`, and `getStep`.\n * @param {object} [state.maps] How values are grouped per-texture per-pass\n *     per-step. Sets up new maps if not given or missing its mapped properties.\n *     See `mapGroups`.\n * @param {number} [state.maps.texturesMax=api.limits.maxDrawbuffers] The\n *     maximum number of textures to use per draw pass. Uses more passes above\n *     this limit.\n * @param {object} [out=state] The state object to set up. Modifies the given\n *     `state` object by default.\n */\nexport function gpgpu(api, state = {}, out = state) {\n    const { maxDrawbuffers: texturesMax, glsl } = (api.limits || api);\n    const { maps = {} } = state;\n\n    out.glsl = parseFloat(glsl.match(/[0-9\\.]+/)[0]);\n\n    (maps.texturesMax ?? (maps.texturesMax = texturesMax));\n    ((('textures' in maps) && ('passes' in maps)) || mapGroups(maps));\n    ((('derives' in maps) && !('samples' in maps)) && mapSamples(maps));\n    out.maps = maps;\n\n    getState(api, state, out);\n    out.step = getStep(api, state);\n\n    return out;\n}\n\nexport default gpgpu;\n","/**\n * GPGPU mappings for step/draw shaders input/output.\n *\n * These maps show shaders how to make use of a system's supported features, how\n * to pack/unpack their data with framebuffers/textures, perform only the needed\n * texture samples to retrieve any past values they must derive from, etc.\n * Shaders may declare values they output, values they derive from, groupings of\n * in/dependent values - without handling how these concerns map to the\n * particular system resources they're using.\n * System limits/features/extensions are accounted for, to produce the most\n * efficient mappings available with the least I/O when it comes to drawing\n * (draw passes, texture samples, etc).\n *\n * @todo Check `packValues` optional and/or based on the given `derives` work.\n * @todo Check examples are correct.\n */\n\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport each from '@epok.tech/fn-lists/each';\n\nimport { valuesDef, channelsMaxDef, texturesMaxDef } from './const';\n\nexport const cache = { packed: [] };\n\nexport const validValue = (value, channelsMax = channelsMaxDef) =>\n    (((1 <= value) && (value <= channelsMax)) ||\n        !!console.error(`\\`gl-gpgpu\\`: the given value (${value}) exceeds the `+\n            `range of channels available (1 to ${channelsMax}).`,\n            value, channelsMax));\n\n/**\n * Minimise resource usage, order `values` to pack into blocks of `channelsMax`.\n *\n * @see mapGroups\n *\n * @param {array<number>} values Each entry is how many co-dependent channels\n *     are grouped into one texture in one pass, separate entries may be in one\n *     or more textures/passes. See `mapGroups`.\n * @param {number} [channelsMax=channelsMaxDef] The maximum number of channels\n *     per texture. See `mapGroups`.\n * @param {array} [out=[]] An array to store the result; a new array by default.\n *\n * @returns {array<number>} `out` The indexes of the given `values`, reordered\n *     to pack into the fewest buckets of `channelsMax` size or less; stored in\n *     the given `out` array.\n */\nexport function packValues(values, channelsMax = channelsMaxDef, out = []) {\n    out.length = values.length;\n    map((_, i) => i, values, out);\n\n    // Counts the number of empty channels in the current group.\n    let channels = channelsMax;\n    // How many values have already been packed.\n    let packed = 0;\n    // Tracks the value that best fits the free channels (fills it tightest).\n    let fitIndex = 0;\n    let fitSize = Infinity;\n\n    for(let i = 0; packed < values.length;) {\n        const v = packed+i;\n        const value = values[out[v]];\n\n        if(!validValue(value, channelsMax)) { return out; }\n\n        // Check how value fits the channels - valid is >= 0, perfect is 0.\n        const fit = channels-value;\n\n        if((fit >= 0) && (fit < fitSize)) {\n            fitSize = fit;\n            fitIndex = v;\n        }\n\n        if((fitSize !== 0) && (v < values.length-1)) { ++i; }\n        else {\n            // Got a perfect fit or the search ended - swap in best fit value.\n            const pack = out[fitIndex];\n\n            out[fitIndex] = out[packed];\n            out[packed] = pack;\n\n            // Reduce the free channels by the best value, reset if needed.\n            (((channels -= values[pack]) > 0) || (channels = channelsMax));\n            // Start the search again over the remaining unpacked entries.\n            fitIndex = ++packed;\n            fitSize = Infinity;\n            i = 0;\n        }\n    }\n\n    return out;\n}\n\n/**\n * Groups the `values` of GPGPU data items across draw passes and data textures.\n *\n * @todo Now `values` may be packed first into buckets of `channelsMax` tightly\n *     before mapping, check whether the examples are correct.\n *\n * @example\n *     mapGroups({ values: [2, 4, 1], channelsMax: 4, texturesMax: 1 }); // =>\n *     {\n *         values: [2, 4, 1],\n *         textures: [[0], [1], [2]], // length === 3\n *         passes: [[0], [1], [2]], // length === 3\n *         texturesMax: 1,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 2],\n *         valueToPass: [0, 1, 2],\n *         textureToPass: [0, 1, 2]\n *     };\n *\n *     mapGroups({ values: [4, 2, 1], texturesMax: 1 }); // =>\n *     {\n *         values: [4, 2, 1],\n *         textures: [[0], [1, 2]], // length === 2\n *         passes: [[0], [1]], // length === 2\n *         texturesMax: 1,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 1],\n *         valueToPass: [0, 1, 1],\n *         textureToPass: [0, 1]\n *     };\n *\n *     mapGroups({ values: [4, 2, 1], texturesMax: 4 }); // =>\n *     {\n *         values: [4, 2, 1],\n *         textures: [[0], [1, 2]], // length === 2\n *         passes: [[0, 1]], // length === 1\n *         texturesMax: 4,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 1],\n *         valueToPass: [0, 0, 0],\n *         textureToPass: [0, 0]\n *     };\n *\n *     mapGroups({ values: [2, 4, 1], texturesMax: 4 }); // =>\n *     {\n *         values: [2, 4, 1],\n *         textures: [[0], [1], [2]], // length === 3\n *         passes: [[0, 1, 2]], // length === 1\n *         texturesMax: 4,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 2],\n *         valueToPass: [0, 0, 0],\n *         textureToPass: [0, 0, 0]\n *     };\n *\n *     mapGroups({ values: [2, 4, 1, 2], texturesMax: 2 }); // =>\n *     {\n *         values: [2, 4, 1, 2],\n *         textures: [[0], [1], [2, 3]], // length === 3\n *         passes: [[0, 1], [2]], // length === 2\n *         texturesMax: 2,\n *         channelsMax: 4,\n *         valueToTexture: [0, 1, 2, 2],\n *         valueToPass: [0, 0, 1, 1],\n *         textureToPass: [0, 0, 1]\n *     };\n *\n * @see packValues\n *\n * @export\n * @param {object} [maps={}] The maps. A new object if not given.\n * @param {array<number>} [maps.values=valuesDef()] An array where each number\n *     denotes how many value channels are grouped into one data texture in one\n *     draw pass; each separate number may be drawn across one or more data\n *     textures/passes. Each value denotes the number of dependent channels to\n *     be drawn together; separate values denote channels that aren't dependent,\n *     and may be drawn in the same or a separate pass, depending on device\n *     support. The given order is (currently) maintained, and may affect the\n *     number of passes/textures used. Where the next state depends on previous\n *     states, these should ideally be an entry of `channels` or less, for\n *     fewest texture reads to retrieve previous states.\n * @param {number} [maps.channelsMax=channelsMaxDef] Maximum channels per\n *     texture.\n * @param {number} [maps.texturesMax=texturesMaxDef] Maximum textures bound per\n *     pass.\n * @param {array<number>|falsey} [maps.packed] An array of indexes into `values`\n *     packed into an order that best fits into blocks of `channelsMax` to\n *     minimise resources; or `falsey` to use `values` in their given order;\n *     uses `packValues` if not given.\n * @param {object} [out=maps] An object to contain the results; modifies `maps`\n *     if not given.\n *\n * @returns {object} `out` The given `out` object; how `values` are grouped\n *     per-texture per-pass per-step, meta information, and given parameters.\n * @returns {array<array<number>>} `out.passes` Textures grouped into passes;\n *     arrays corresponding to framebuffers in separate draw passes; whose\n *     values are indexes into `out.textures`.\n * @returns {array<array<number>>} `out.textures` Values grouped into\n *     textures; arrays corresponding to framebuffer attachments, into which\n *     `values` are drawn; whose values are indexes into `out.values`.\n * @returns {array<number>} `out.values` The `values`, as given.\n * @returns {number} `out.texturesMax` The max textures per pass, as given.\n * @returns {number} `out.channelsMax` The max channels per texture, as given.\n * @returns {array<number>} `out.valueToTexture` Inverse map from each index of\n *     `out.values` to the index of the data texture containing it.\n * @returns {array<number>} `out.valueToPass` Inverse map from each index of\n *     `out.values` to the index of the pass containing it.\n * @returns {array<number>} `out.textureToPass` Inverse map from each index of\n *     `out.textures` to the index of the pass containing it.\n */\nexport function mapGroups(maps = {}, out = maps) {\n    const {\n            values = valuesDef(),\n            channelsMax = channelsMaxDef, texturesMax = texturesMaxDef,\n            // Pack `values` into blocks of `channelsMax` to minimise resources.\n            packed = packValues(values, channelsMax, cache.packed)\n        } = maps;\n\n    out.values = values;\n    out.texturesMax = texturesMax;\n    out.channelsMax = channelsMax;\n    out.passes = [[]];\n    out.textures = [[]];\n    out.valueToTexture = [];\n    out.valueToPass = [];\n    out.textureToPass = [];\n\n    // Counts the number of channels written in a single draw pass.\n    let channels = 0;\n    // Get the value, via `packed` if valid, or directly as given in `values`.\n    const getValue = ((packed)? (v) => values[v] : (v) => v);\n\n    return reduce((out, v) => {\n            const value = getValue(v);\n\n            if(!validValue(value, channelsMax)) { return out; }\n\n            const {\n                    textures, passes, valueToTexture, valueToPass, textureToPass\n                } = out;\n\n            let p = passes.length-1;\n            let pass = passes[p];\n            let t = textures.length-1;\n            let texture = textures[t];\n\n            if((channels += value) > channelsMax) {\n                channels = value;\n                t = textures.push(texture = [])-1;\n\n                ((pass.length >= texturesMax) &&\n                    (p = passes.push(pass = [])-1));\n\n                pass.push(t);\n                textureToPass.push(p);\n            }\n            else if(pass.length === 0) {\n                pass.push(t);\n                textureToPass.push(p);\n            }\n\n            texture.push(v);\n            valueToTexture.push(t);\n            valueToPass.push(p);\n\n            return out;\n        },\n        (packed || values), out);\n}\n\n/**\n * Maps the minimal set of texture reads to derive the next state of values from\n * a past state of values they depend upon.\n *\n * @example\n *     const maps = mapGroups({\n *         values: [2, 4, 1, 2], channelsMax: 4, texturesMax: 2,\n *         // Entries per-value of derived step/value indexes, entries include:\n *         // empty, single, multiple, and defined step samples.\n *         derives: [[1, 0], , [3, [1, 0]], [2]]\n *     });\n *\n *     mapSamples(maps); // =>\n *     {\n *         ...maps,\n *         // Per-pass, minimum texture samples for values.\n *         samples: [\n *             // Per-value - step/texture index pairs into `maps.textures`.\n *             [[0, 1], [0, 0]],\n *             [[0, 2], [1, 0]]\n *         ],\n *         // Per-pass, value indexes to texture samples.\n *         reads: [\n *             // Per-value - indexes into `out.samples`.\n *             [[0, 1], , , ],\n *             [, , [0, 1], [0]]\n *         ]\n *     };\n *\n * @see mapGroups\n *\n * @export\n * @param {object} maps How values are grouped per-texture per-pass per-step.\n *     See `mapGroups`.\n * @param {array<null,array<number,array<number>>>} [maps.derives] How values\n *     are derived. For each value index, a list of indexes of any past values\n *     it derives its from - a value not derived from past values may have an\n *     empty/null entry; a value derives from past values where its entry has:\n *     - Numbers; deriving from the most recent state at the given value index.\n *     - Lists of numbers; deriving from the given past state index (1st number\n *         denotes how many states ago), at the given value index (2nd number).\n *     If not given, no samples are mapped and `out` is returned unchanged.\n * @param {array<array<number>>} maps.passes Textures grouped into passes. See\n *     `mapGroups`.\n * @param {array<array<number>>} maps.textures Values grouped into textures. See\n *     `mapGroups`.\n * @param {array<number>} maps.valueToTexture Inverse map from each value index\n *     to the data texture index containing it.\n * @param {object} [out=maps] The object to store the result in; `maps` if not\n *     given.\n *\n * @returns {object} `out` The given `out` object, with resulting maps added if\n *     `maps.derives` were provided.\n * @returns {array<array<array<number>>>} `[out.samples]` Map of the minimum\n *     set of indexes into `maps.textures` that need to be sampled per-pass,\n *     to get all `derives` needed for each value of `maps.values` of each\n *     pass of `maps.passes`.\n * @returns {array<array<null,array<number>>>} `[out.reads]` Sparse map from\n *     each value of `derives` to its step and texture indexes in `out.samples`.\n * @returns {array<null,array<number,array<number>>>} `[out.derives]` How\n *     values are derived, as given.\n */\nexport function mapSamples(maps, out = maps) {\n    const { derives, passes, textures, valueToTexture } = maps;\n\n    if(!derives) { return out; }\n\n    out.derives = derives;\n\n    const reads = out.reads = [];\n\n    const getAddSample = (set, pass, value) => (derive, d) => {\n        const sample = ((Number.isInteger(derive))? [0, valueToTexture[derive]]\n            :   [derive[0], valueToTexture[derive[1]]]);\n\n        if(!sample.every(Number.isInteger)) {\n            return console.error('`mapSamples`: invalid map for sample',\n                derives, maps, pass, value, derive, d, sample);\n        }\n\n        const [step, texture] = sample;\n        let i = set.findIndex(([s, t]) => (s === step) && (t === texture));\n\n        ((i < 0) && (i = set.push(sample)-1));\n\n        const passReads = (reads[pass] || (reads[pass] = []));\n        const valueReads = (passReads[value] || (passReads[value] = []));\n\n        valueReads[d] = i;\n    };\n\n    const getAddSamples = (pass) => (set, value) => {\n        const valueDerives = derives[value];\n\n        (valueDerives && each(getAddSample(set, pass, value), valueDerives));\n\n        return set;\n    }\n\n    out.samples = map((pass, p) => reduce((set, texture) =>\n                reduce(getAddSamples(p), textures[texture], set),\n            pass, []),\n        passes, []);\n\n    return out;\n}\n\nexport default mapGroups;\n","import { reduce } from './reduce';\n\n/**\n * Map an array-like object.\n * Similar to native, but with iteratee-first arguments; and allows the object\n * into which properties will be mapped to be defined (a new array, by default),\n * avoiding always creating new arrays.\n *\n * @param {function} f The iteratee function, given standard `Array.map`\n *     arguments, plus the output object.\n * @param {array} a The list to map over (array or array-like object).\n * @param {*} [out=[]] The initial accumulator, if given; `a` if falsey given;\n *     or a new array if not given.\n *\n * @returns {*} The result of mapping `out` through the iteratee function over\n *     the `a` list.\n */\nexport const map = (f, a, out = []) => reduce((out, v, i) => {\n        out[i] = f(v, i, a, out);\n\n        return out;\n    },\n    a, (out || a));\n\nexport default map;\n","const r = Array.prototype.reduce;\n\n/**\n * Reduce an array-like object.\n * Similar to native, but with iteratee-first arguments.\n * Supports the native single-argument behaviour.\n *\n * @param {function} f The iteratee function, given standard arguments, plus the\n *     `out` argument.\n * @param {array} a The list to reduce over (array or array-like object).\n * @param {*} [out] The initial accumulator, if given; otherwise, uses standard\n *     `Array.reduce` behaviour.\n *\n * @returns {*} The result of running the reducer iteratee function over all\n *     elements of the list.\n */\nexport const reduce = (f, a, out) =>\n    // Needs separate `call` because native detects even `undefined` parameter.\n    ((out === undefined)? r.call(a, f) : r.call(a, f, out));\n\nexport default reduce;\n","const e = Array.prototype.forEach;\n\n/**\n * Iterates a function over every element of a list, returning the list.\n *\n * @param {function} f The iteratee function.\n * @param {array} a A list to iterate over (array or array-like object).\n *\n * @returns {array} The given list.\n */\nexport const each = (f, a) => {\n    e.call(a, f);\n\n    return a;\n}\n\nexport default each;\n","/**\n * GPGPU defaults and constants.\n */\n\nimport { positions } from '@epok.tech/gl-screen-triangle';\n\nexport { default as vertDef }\n    from '@epok.tech/gl-screen-triangle/index.vert.glsl';\n\n// The required and optional GL extensions for a GPGPU state.\n\nexport const extensions = () => [];\n\n// To draw to `float` buffers.\nexport const extensionsFloat = () =>\n    ['oes_texture_float', 'webgl_color_buffer_float'];\n\n// To draw to `half float` buffers.\nexport const extensionsHalfFloat = () =>\n    ['oes_texture_half_float', 'ext_color_buffer_half_float'];\n\nexport const optionalExtensions = () => ['webgl_draw_buffers'];\n\n/**\n * Default properties for GPGPU and GL capabilities and resources.\n */\n\n// Prefix namespace to avoid naming clashes.\nexport const preDef = '';\n\n// The allowable range of channels for framebuffer attachments.\n// Default avoids `RGB32F` framebuffer attachments, which errors on\n// Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1448632\nexport const channelsMinDef = 4;\nexport const channelsMaxDef = 4;\n\nexport const texturesMaxDef = 1;\nexport const boundDef = 1;\nexport const scaleDef = 10;\nexport const stepsDef = 2;\nexport const typeDef = 'float';\nexport const valuesDef = () => [channelsMaxDef];\nexport const positionsDef = () => [...positions];\n","precision highp float;\n\nattribute vec2 position;\n\nvoid main() {\n    gl_Position = vec4(position, 0, 1);\n}\n","/**\n * GPGPU state and GL resources.\n *\n * @todo In-place updates of complex resources and meta info.\n * @todo Use transform feedback instead of data textures, if supported (WebGL2)?\n * @todo Consider class/object/data/function structure further.\n */\n\nimport range from '@epok.tech/fn-lists/range';\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport isNumber from '@epok.tech/is-type/number';\n\nimport {\n        scaleDef, stepsDef, valuesDef, channelsMinDef, typeDef\n    } from './const';\n\n/**\n * Set up the GPGPU resources and meta information for a state of a number data.\n *\n * @todo Transform feedback.\n * @todo Validate, check examples.\n * @todo Reorder the given `values` into the most efficient `maps`?\n *\n * @example\n *     const state = {\n *         steps: 2, maps: mapGroups({ values: [4, 2, 3], texturesMax: 4 })\n *     };\n *\n *     getState(api, state); // =>\n *     {\n *         ...state, passNow: -1, stepNow: -1,\n *         size: {\n *             type: 'float', steps: 2, passes: 2, textures: 6,\n *             width: 1024, height: 1024, shape: [1024, 1024], count: 1048576\n *         },\n *         steps: [[api.framebuffer], [api.framebuffer]],\n *         passes: [\n *             [\n *                 {\n *                     step: 0, index: 0, count: 0, map: [0, 1, 2],\n *                     framebuffer: api.framebuffer,\n *                     textures: [api.texture, api.texture, api.texture]\n *                 }\n *             ],\n *             [\n *                 {\n *                     step: 1, index: 0, count: 1, map: [0, 1, 2],\n *                     framebuffer: api.framebuffer,\n *                     textures: [api.texture, api.texture, api.texture]\n *                 }\n *             ]\n *         ],\n *         textures: [\n *             [\n *                 {\n *                     step: 0, pass: 0, index: 0, count: 0, map: [0],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 0, pass: 0, index: 1, count: 1, map: [1],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 0, pass: 0, index: 2, count: 2, map: [2],\n *                     texture: api.texture\n *                 }\n *             ],\n *             [\n *                 {\n *                     step: 1, pass: 0, index: 0, count: 3, map: [0],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 1, pass: 0, index: 1, count: 4, map: [1],\n *                     texture: api.texture\n *                 },\n *                 {\n *                     step: 1, pass: 0, index: 2, count: 5, map: [2],\n *                     texture: api.texture\n *                 }\n *             ]\n *         ]\n *     };\n *\n *     Object.assign(state, {\n *         type: 'uint8', stepNow: 2,\n *         maps: mapGroups({ values: [4, 2, 3], texturesMax: 1 })\n *     });\n *\n *     getState(api, state); // =>\n *     {\n *        ...state, passNow: -1, stepNow: 2,\n *        size: {\n *            type: 'uint8', steps: 2, passes: 6, textures: 6,\n *            width: 1024, height: 1024, shape: [1024, 1024], count: 1048576\n *        },\n *        steps: [\n *            [api.framebuffer, api.framebuffer, api.framebuffer],\n *            [api.framebuffer, api.framebuffer, api.framebuffer]\n *        ],\n *        passes: [\n *            [\n *                {\n *                    step: 0, index: 0, count: 0, map: [0],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 0, index: 1, count: 1, map: [1],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 0, index: 2, count: 2, map: [2],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                }\n *            ],\n *            [\n *                {\n *                    step: 1, index: 0, count: 3, map: [0],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 1, index: 1, count: 4, map: [1],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                },\n *                {\n *                    step: 1, index: 2, count: 5, map: [2],\n *                    framebuffer: api.framebuffer, textures: [api.texture]\n *                }\n *            ]\n *        ],\n *        textures: [\n *            [\n *                {\n *                    step: 0, pass: 0, index: 0, count: 0, map: [0],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 0, pass: 1, index: 1, count: 1, map: [1],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 0, pass: 2, index: 2, count: 2, map: [2],\n *                    texture: api.texture\n *                }\n *            ],\n *            [\n *                {\n *                    step: 1, pass: 0, index: 0, count: 3, map: [0],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 1, pass: 1, index: 1, count: 4, map: [1],\n *                    texture: api.texture\n *                },\n *                {\n *                    step: 1, pass: 2, index: 2, count: 5, map: [2],\n *                    texture: api.texture\n *                }\n *            ]\n *        ]\n *    };\n *\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [mapSamples]{@link ./maps.js#mapSamples}\n * @see [getStep]{@link ./step.js#getStep}\n * @see [macroPass]{@link ./macros.js#macroPass}\n *\n * @export\n * @param {object} api The API for GL resources.\n * @param {function} api.texture A function to create a GL texture.\n * @param {function} api.framebuffer A function to create a GL framebuffer.\n * @param {object} [state={}] The state parameters.\n * @param {number} [state.radius] The length of the sides of the data textures\n *     to allocate. If given, supersedes the `state` `width`/`height`/`scale`.\n * @param {number} [state.width] The width of the data textures to allocate.\n *     If given, supersedes `state.scale`.\n * @param {number} [state.height] The height of the data textures to allocate.\n *     If given, supersedes `state.scale`.\n * @param {number} [state.scale=scaleDef] The length of the data textures sides\n *     to allocate; gives a square power-of-two texture raising 2 to this power.\n * @param {number|array} [state.steps=stepsDef] How many steps of state to\n *     track, or the list of states if already set up.\n * @param {object} [state.maps] How `state.maps.values` are grouped per-texture\n *     per-pass per-step. See `mapGroups`.\n * @param {array<number>} [state.maps.values=valuesDef()] How values of each\n *     data item may be grouped into textures across passes. Set up here if not\n *     given. See `mapGroups`.\n * @param {number} [state.maps.channelsMin=channelsMinDef] The minimum allowed\n *     channels for framebuffer attachments. Sets up unused channels as needed\n *     to reach this limit.\n * @param {number} [state.maps.textures] How values are grouped into textures.\n *     See `mapGroups`.\n * @param {string} [state.type=typeDef] The data type of the textures.\n * @param {number} [state.stepNow=-1] The currently active state step, if any.\n * @param {number} [state.passNow=-1] The currently active draw pass, if any.\n * @param {object} [out=state] The state object to set up. Modifies the given\n *     `state` object by default.\n *\n * @returns {object} `out` The state object, set up with the data resources and\n *     meta information, for step/draw later:\n * @returns {object<number,array<number,array<number>>>} `out.maps` Any given\n *     `state.maps`. See `mapGroups`.\n * @returns {array<array<object<api.texture,number,array<number>>>>}\n *     `out.textures` Textures per step, as arrays of objects of `api.texture`,\n *     and meta info. See `out.maps.textures`.\n * @returns {array<array<object<api.framebuffer,number,array<number>>>>}\n *     `out.passes` Passes per step, as arrays of objects of `api.framebuffer`,\n *     referencing `out.textures`, and meta info. See `out.maps.passes`.\n * @returns {array<api.framebuffer<array<api.texture>>>} `out.steps`\n *     Hierarchy of steps of state, as an array of `api.framebuffer` from\n *     `out.passes`, with arrays of `api.texture` from `out.textures`, and meta\n *     information; set up here, or the given `state.steps` if it was an array.\n *     State data may be drawn into the framebuffers accordingly.\n *     See `mapGroups` and `getStep`.\n * @returns {object<number,string,array<number>>} `out.size` Size/type\n *     information on data resources.\n * @returns {number} `out.stepNow` The currently active state step, as given.\n * @returns {number} `out.passNow` The currently active draw pass, as given.\n */\nexport function getState(api, state = {}, out = state) {\n    // See usage here for what the API must implement.\n    const { texture, framebuffer } = api;\n\n    const {\n            radius, width, height, scale = scaleDef, type = typeDef,\n            steps = stepsDef, stepNow = -1, passNow = -1, maps\n        } = state;\n\n    out.maps = maps;\n    out.stepNow = stepNow;\n    out.passNow = passNow;\n\n    const {\n            values = valuesDef(),\n            channelsMin = channelsMinDef, textures: texturesMap\n        } = maps;\n\n    maps.channelsMin = channelsMin;\n    maps.values = values;\n\n    const textureProps = {\n        type, min: 'nearest', mag: 'nearest', wrap: 'clamp',\n        // Passing `state.scale` ensures a power-of-two square texture size.\n        width: (radius ?? width ?? 2**scale),\n        height: (radius ?? height ?? 2**scale)\n    };\n\n    // Size of the created resources.\n    const size = out.size = {\n        ...textureProps, steps: ((isNumber(steps))? steps : steps.length),\n        textures: 0, passes: 0,\n        shape: [textureProps.width, textureProps.height],\n        count: textureProps.width*textureProps.height\n    };\n\n    const textures = out.textures = [];\n    const passes = out.passes = [];\n\n    const addTexture = (step, pass, textureProps) => (index) =>\n        ((textures[step] || (textures[step] = []))[index] = {\n            // Meta info.\n            step, pass, index, count: size.textures++, map: texturesMap[index],\n            // Resources.\n            texture: texture(textureProps)\n        })\n        .texture;\n\n    const addPass = (step) => (pass, index) => {\n        // All framebuffer color attachments need the same number of channels.\n        const passProps = {\n            ...textureProps,\n            channels: reduce((max, t) =>\n                    reduce((max, v) => Math.max(max, values[v]),\n                        texturesMap[t], max),\n                pass, channelsMin)\n        };\n\n        const textures = map(addTexture(step, index, passProps), pass);\n\n        const frame = framebuffer({\n            width: passProps.width, height: passProps.height,\n            color: textures, depth: false, stencil: false\n        });\n\n        (passes[step] || (passes[step] = []))[index] = {\n            // Meta info.\n            step, index, count: size.passes++, map: pass,\n            // Resources.\n            textures, framebuffer: frame\n        };\n\n        return frame;\n    };\n\n    // Set up resources we'll need to store data per-texture per-pass per-step.\n    out.steps = map((passes, step) =>\n            // Use any given passes or create a new list of them.\n            (passes || map(addPass(step), maps.passes)),\n        // Use any given steps or create a new list of them.\n        ((isNumber(steps))? range(steps) : steps), 0);\n\n    return out;\n}\n\nexport default getState;\n","/**\n * Creates an iterable array of the given length of empty entries, or\n * those given by optional arguments to `Array.fill`.\n *\n * @see Array.fill\n *\n * @param {number} n The number of elements to create.\n * @param {*} [value] A value to fill the array with; for `Array.fill`.\n * @param {number} [start=0] Start index, inclusive; for `Array.fill`.\n * @param {number} [end=n] End index, exclusive; for `Array.fill`.\n *\n * @returns {array} An array of the given number of empty elements.\n */\nexport const range = (n, value, start, end) => Array(n).fill(value, start, end);\n\nexport default range;\n","import { type } from './type';\n\nexport const isNumber = (x) => (type(x) === 'Number');\n\nexport default isNumber;\n","const [{ length: start}, { length: end }] = '[object {type}]'.split('{type}');\n\n/**\n * Gives the type of a given input.\n *\n * @see https://stackoverflow.com/a/17772086/716898\n *\n * @param {*} x Any input to test.\n *\n * @returns {string} The type of `x`.\n */\nexport const type = (x) => toString.call(x).slice(start, -end);\n\nexport default type;\n","/**\n * GPGPU update step.\n */\n\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap-index';\n\nimport { macroPass } from './macros';\nimport { getUniforms } from './inputs';\nimport { vertDef, positionsDef, preDef } from './const';\n\nconst scale = { vec2: 0.5 };\n\n/**\n * Creates a GPGPU update step function, for use with a GPGPU state object.\n *\n * @todo Optional transform feedback instead of GPGPU textures, where available\n *     (needs vertex draw, instead of texture draw).\n * @todo Make this fully extensible in state.\n *\n * @see [getState]{@link ./state.js#getState}\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [macroPass]{@link ./macros.js#macroPass}\n * @see [getUniforms]{@link ./inputs.js#getUniforms}\n *\n * @export\n * @param {object} api An API for GL resources.\n * @param {function} api.buffer A function to set up a GL buffer.\n * @param {function} api.command A function to call a GL draw, with all options.\n * @param {object} state The GPGPU state to use. See `getState` and `mapGroups`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @returns {array<array<number>>} `out.passes` How textures are grouped into\n *     passes. See `mapGroups`.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n * @param {object} [state.step=out] The properties for the step GL command.\n * @param {string} [state.step.vert=vertDef] The step vertex shader GLSL; a\n *     simple flat screen shader if not given.\n * @param {string} state.step.frag The step fragment shader GLSL.\n * @param {object} [state.step.uniforms=getUniforms(state)] The step uniforms;\n *     modifies any given. See `getUniforms`.\n * @param {array|api.buffer} [state.step.positions=positionsDef()] The step\n *     position attributes; 3 points of a large flat triangle if not given.\n * @param {number} [state.step.count=state.step.positions.length*scale.vec2] The\n *     number of elements/attributes to draw.\n * @param {array} [state.step.verts] Preprocesses and caches vertex GLSL code\n *     per-pass if given, otherwise processes it just-in-time before each pass.\n * @param {array} [state.step.frags] Preprocesses and caches fragment GLSL code\n *     per-pass, otherwise processes it just-in-time before each pass.\n * @param {object} [out={}] The results object; a new object if not given.\n *\n * @returns {object} `out` The given `out` object; containing a GPGPU update\n *     step function and related properties, to be passed a GPGPU state.\n * @returns {string} `out.vert` The given/new `state.vert` vertex shader GLSL.\n * @returns {string} `out.frag` The given `state.frag` fragment shader GLSL.\n * @returns {array.string} `[out.verts]` Any cached pre-processed vertex shaders\n *     GLSL, if `state.step.verts` was given.\n * @returns {array.string} `[out.frags]` Any cached pre-processed fragment\n *     shaders GLSL, if `state.step.verts` was enabled.\n * @returns {object} `out.uniforms` The given `state.uniforms`.\n * @returns {number} `out.count` The given/new `state.count`.\n * @returns {api.buffer} `out.positions` The given/new `state.positions`; passed\n *     through `api.buffer`.\n * @returns {api.command} `out.pass` A GL command function to draw a given pass.\n * @returns {function} `out.run` The main step function, which performs all the\n *     draw pass GL commands for a given state step.\n */\nexport function getStep(api, state, out = {}) {\n    const { buffer, command = api } = api;\n    const { maps: { passes }, pre = preDef, step = out } = state;\n    let { positions = positionsDef() } = step;\n    const {\n            vert = vertDef, verts, frag, frags, uniforms,\n            count = positions.length*scale.vec2\n        } = step;\n\n    out.vert = vert;\n    out.frag = frag;\n    out.uniforms = getUniforms(state, uniforms);\n    out.count = count;\n    positions = out.positions = buffer(positions);\n\n    if(verts || frags) {\n        // Pre-process the shaders needed for all the passes.\n        const stateCache = { ...state };\n\n        (verts && (out.verts = verts));\n        (frags && (out.frags = frags));\n\n        each((pass, p) => {\n                stateCache.passNow = p;\n\n                const passMacros = macroPass(stateCache);\n\n                (verts && (verts[p] = passMacros+vert));\n                (frags && (frags[p] = passMacros+frag));\n            },\n            passes);\n    }\n\n    out.pass = command(out.passCommand = {\n        // Uses the full-screen vertex shader state by default.\n        vert(_, props) {\n            const { passNow: p, step } = props;\n            const { vert: v = vert, verts: vs = verts } = step;\n\n            return ((vs)? vs[p] : macroPass(props)+v);\n        },\n        frag(_, props) {\n            const { passNow: p, step } = props;\n            const { frag: f = frag, frags: fs = frags } = step;\n\n            return ((fs)? fs[p] : macroPass(props)+f);\n        },\n        attributes: {\n            [pre+'position']: (_, { step: { positions: p = positions } }) => p\n        },\n        uniforms,\n        count,\n        depth: { enable: false },\n        framebuffer: (_, { steps: ss, stepNow: s, passNow: p }) =>\n            wrap.get(s, ss)[p]\n    });\n\n    out.run = (props = state) => {\n        const { step: { pass, onPass, onStep }, maps: { passes } } = props;\n\n        ++props.stepNow;\n        onStep?.(props, wrap.get(props.stepNow, props.steps));\n\n        each((passProps, p) => {\n                props.passNow = p;\n                pass(onPass?.(props, passProps) ?? props);\n            },\n            passes);\n\n        return props;\n    };\n\n    return out;\n}\n\nexport default getStep;\n","/**\n * GPGPU GLSL preprocessor macros for each part of the state.\n *\n * Careful defining these, as each set of different macros will result in new\n * shaders and compilations, missing the cache here and in the rendering system.\n * So, as few unique macros as possible should be created for a given set of\n * inputs, for efficiency.\n *\n * @todo Check examples are correct.\n * @todo Consider doing something better with indentation.\n */\n\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\nimport { type } from '@epok.tech/is-type/type';\n\nimport { preDef, boundDef } from './const';\n\nexport const rgba = 'rgba';\nexport const cache = {};\n\n// Keys for each part of the macro handling process available to hooks.\nexport const hooks = {\n    // The full set of macros.\n    macroPass: 'pass',\n    // Each part of the set of macros.\n    macroValues: 'values', macroOutput: 'output',\n    macroSamples: 'samples', macroSamplesTap: 'tap'\n};\n\n/**\n * Gives the prefix to use, to avoid namespace collisions.\n *\n * @param {object} state The state to check.\n * @param {string} [state.macros] The macros prefix; supersedes `state.pre`.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n *\n * @returns {string} The prefix string to use.\n */\nexport const getPre = ({ macros, pre = preDef }) =>\n    ((type(macros) === 'String')? macros : pre);\n\n/**\n * Generates an array declaration, as a GLSL 3 syntax string.\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @export\n * @example\n *     getGLSL3List('int', 'list', [1, 2, 3], 'const'); // =>\n *     'const int list_l = 3; '+\n *     'const int list[list_l] = int[list_l](int(1), int(2), int(3));\\n'+\n *     '#define list_i(i) list[i]\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 3 array declaration string.\n */\nexport const getGLSL3List = (type, name, a, qualify = '', init = type) =>\n    `const int ${name}_l = ${a.length}; `+\n    `${(qualify && qualify+' ')+type} ${name}[${name}_l] = ${\n        init}[${name}_l](${reduce((s, v, i) =>\n                `${s+type}(${((Array.isArray(v))? v.join(', ') : v)})${\n                    ((i < a.length-1)? ', ' : '')}`,\n            a, '')});\\n`+\n    `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Generates an array declaration, as a GLSL 1 syntax string.\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @export\n * @example\n *     getGLSL1ListArray('vec3', 'list', [[1, 0, 0], [0, 2, 0], [0, 0, 3]]);\n *     // =>\n *     'const int list_l = 3; '+\n *     'vec3 list[list_l]; '+\n *     'list[0] = vec3(1, 0, 0); '+\n *     'list[1] = vec3(0, 2, 0); '+\n *     'list[2] = vec3(0, 0, 3);\\n'+\n *     '#define list_i(i) list[i]\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array declaration string.\n */\nexport const getGLSL1ListArray = (type, name, a, qualify = '', init = type) =>\n    `const int ${name}_l = ${a.length}; ${\n    (qualify && qualify+' ')+type} ${name}[${name}_l]; ${\n    reduce((s, v, i) =>\n            `${s} ${name}[${i}] = ${\n                init}(${((Array.isArray(v))? v.join(', ') : v)});`,\n        a, '')}\\n`+\n    `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Generates an array-like declaration, as a GLSL 1 syntax string.\n * Workaround for lack of `const` arrays in GLSL < 3.\n *\n * @export\n * @example\n *     getGLSL1ListLike('float', 'list', [1, 2, 3], 'const'); // =>\n *     'const int list_l = 3; '+\n *     'const int list_0 = float(1); '+\n *     'const int list_1 = float(2); '+\n *     'const int list_2 = float(3);\\n'+\n *     '#define list_i(i) ((i == 2)? list_2 : ((i == 1)? list_1 : list_0))\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array-like declaration string.\n */\nexport const getGLSL1ListLike = (type, name, a, qualify = '', init = type) =>\n    `const int ${name}_l = ${a.length}; ${\n    reduce((s, v, i) =>\n            `${s} ${(qualify && qualify+' ')+type} ${name}_${i} = ${\n                init}(${((Array.isArray(v))? v.join(', ') : v)});`,\n        a, '')}\\n`+\n    // `#define ${name}_i(i) ${name}_##i`;\n    `#define ${name}_i(i) ${reduce((s, v, i) =>\n            ((i)? `((i == ${i})? ${name}_${i} : ${s})` : `${name}_${i}`),\n        a, '')}\\n`;\n\n/**\n * Creates a GLSL definition of an array, and initialises it with the given\n * values, type, and variable name.\n * The initialisation is valid GLSL 1.0 or greater syntax; but is written with\n * escaped new-lines so it may be used in a single-line - e.g: for preprocessor\n * macros.\n * For a `qualify` of `const` on any `glsl` less than `3`, falls back to using\n * non-array variables with the index appended to `name`, since `const` arrays\n * aren't supported before GLSL 3.0.\n *\n * @example\n *     getGLSLList('int', 'test', [0, 1]); // =>\n *     'const int test_l = 2; '+\n *     'int test[test_l]; '+\n *     'test[0] = int(0); '+\n *     'test[1] = int(1);\\n'+\n *     '#define test_i(i) test[i]\\n';\n *\n *     getGLSLList('ivec2', 'vecs', [[0, 1], [0, 0]], 'const', 3); // =>\n *     'const int vecs_l = 2; '+\n *     'const ivec2 vecs[vecs_l] = ivec2[vecs_l](ivec2(0, 1), ivec2(0, 0));\\n'+\n *     '#define vecs_i(i) vecs[i]\\n';\n *\n *     getGLSLList('int', 'listLike', [0, 1], 'const', 1); // =>\n *     'const int listLike_l = 2; '+\n *     'const int listLike_0 = int(0); '+\n *     'const int listLike_1 = int(1);\\n'+\n *     '#define listLike_i(i) ((i == 1)? listLike_1 : listLike_0)\\n';\n *\n * @export\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {number} [qualify=''] A GLSL qualifier, if needed (e.g: `const`).\n * @param {number} [glsl=1] The GLSL version to target, if specified.\n * @param {string} [init] A data-type initialiser.\n *\n * @returns {string} The GLSL (1 or 3) array or array-like declaration string.\n */\nexport const getGLSLList = (type, name, a, qualify = '', glsl = 1, init) =>\n    ((glsl >= 3)? getGLSL3List\n    : ((qualify.trim() === 'const')? getGLSL1ListLike\n    :   getGLSL1ListArray))(type, name, a, qualify, init);\n\n/**\n * Whether macros should be handled in this module; or the result of handling\n * them by a given named hook.\n * Allows macros of the given key to be handled by external named hooks, to\n * replace any part of the functionality in this module.\n *\n * @example\n *     // Macros to be handled in part of this module.\n *     hasMacros({}) === false;\n *     // Macros to be handled in part of this module (with a name prefix `m`).\n *     hasMacros({ macros: 'm' }) === false;\n *     // No/empty macros created.\n *     hasMacros({ macros: false }) === '';\n *     // Macros for 'a' handled by external static hook, not this module.\n *     hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'a') === '//A\\n';\n *     // Macros for 'b' handled by external function hook, not this module.\n *     hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'b') === '//B\\n';\n *\n * @param {object} props The properties handling macros.\n * @param {string} [key] The name for which macros should be handled.\n * @param {string|function|object|false} [macros=props.macros] Whether and\n *     how GLSL preprocessor macros should be handled:\n *     - If it's defined and falsey, no macros are handled in this module.\n *     - If it's a function, it's passed the given `props`, `key`, `macros`.\n *     - If it's an object, any value at the given `key` is entered recursively,\n *         with the given `props`, `key`, and `macros[key]`.\n *     - Otherwise, returns `false` to indicate macros should be handled here.\n *\n * @returns {string|*|false} Either the result of the macros handled elsewhere,\n *     or `false` if macros should be handled here.\n */\nexport function hasMacros(props, key, macros = props.macros) {\n    if(macros === undefined) { return false; }\n    if(!macros) { return ''; }\n\n    const t = type(macros);\n\n    return ((t === 'Function')? macros(props, key, macros)\n        : ((t === 'String')? macros\n        : (((macros instanceof Object) && (key in macros))?\n            hasMacros(props, key, macros[key])\n        :   false)));\n}\n\n/**\n * Defines the values within textures per-step, as GLSL preprocessor macros.\n * These macros define mappings from values to their textures and channels.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see getPre\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     macroValues({\n *         steps: Array(2),\n *         maps: mapGroups({ values: [4, 2, 1], texturesMax: 1 })\n *     }); // =>\n *     '#define texture_0 0\\n'+ // Value 0's texture.\n *     '#define channels_0 rgba\\n'+ // Value 0's channels.\n *     '\\n'+\n *     '#define texture_1 1\\n'+ // Value 1's texture.\n *     '#define channels_1 rg\\n'+ // Value 1's channels.\n *     '\\n'+\n *     '#define texture_2 1\\n'+ // Value 2's texture.\n *     '#define channels_2 b\\n'+ // Value 2's channels.\n *     '\\n'+\n *     // General metadata.\n *     '#define textures 2\\n'+\n *     '#define passes 2\\n'+\n *     '#define stepsPast 1\\n'+\n *     '#define steps 2\\n';\n *\n * @export\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string|function|object|falsey} [state.macros] How macros are handled\n *     or prefixed. See `hasMacros` and `getPre`.\n * @param {string} [state.pre] How macros are prefixed. See `getPre`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step.\n * @param {array<number>} state.maps.values How values of each data item are\n *     grouped into textures. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures The groupings of values\n *     into textures. See `mapGroups`.\n * @param {array} state.maps.passes The passes drawn per-step. See `mapGroups`.\n * @param {array} state.steps The states drawn across frames. See `getState`.\n * @param {number} [state.bound=boundDef] How many steps are bound as outputs,\n *     unavailable as inputs.\n * @param {object} [state.size] Any size information about the GL resources.\n * @param {number} [state.size.count] The number of data entries per texture\n *     (the texture's area), if given. See `getState`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings from\n *     values to textures/channels.\n */\nexport function macroValues(state) {\n    const key = hooks.macroValues;\n    const hook = hasMacros(state, key);\n\n    if(hook !== false) { return hook; }\n\n    const {\n            maps: { values, textures, passes: { length: passesL } },\n            steps: { length: stepsL }, bound = boundDef\n        } = state;\n\n    const count = (state.size && state.size.count);\n    const n = getPre(state);\n    const c = key+':'+\n        JSON.stringify({ n, bound, values, textures, stepsL, passesL, count });\n\n    return (cache[c] || (cache[c] =\n        reduce((s, texture, t, _, i = 0) => reduce((s, v) => s+\n                    `#define ${n}texture_${v} ${t}\\n`+\n                    `#define ${n}channels_${v} ${\n                        rgba.slice(i, (i += values[v]))}\\n\\n`,\n                texture, s),\n            textures, '')+\n        ((count)? `#define count ${count}\\n` : '')+\n        `#define ${n}textures ${textures.length}\\n`+\n        `#define ${n}passes ${passesL}\\n`+\n        `#define ${n}stepsPast ${stepsL-bound}\\n`+\n        `#define ${n}steps ${stepsL}\\n`));\n}\n\n/**\n * Defines the outputs being drawn to per-pass, as GLSL preprocessor macros.\n * These macros define mappings from values to their outputs, if bound.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see getPre\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const state = {\n *         passNow: 0, maps: mapGroups({ values: [4, 2, 1], texturesMax: 1 })\n *     };\n *\n *     macroOutput(state); // =>\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_0 0\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rgba\\n';\n *\n *     ++state.passNow;\n *\n *     macroOutput(state); // =>\n *     '#define passNow 1\\n'+\n *     '\\n'+\n *     '#define bound_1 1\\n'+\n *     '#define attach_1 0\\n'+\n *     '#define output_1 gl_FragData[attach_1].rg\\n'+\n *     '\\n'+\n *     '#define bound_2 1\\n'+\n *     '#define attach_2 0\\n'+\n *     '#define output_2 gl_FragData[attach_2].b\\n';\n *\n * @export\n * @param {object} state Properties for generating the macros. See `getState`:\n * @param {string|function|object|falsey} [state.macros] How macros are handled\n *     or prefixed. See `hasMacros` and `getPre`.\n * @param {string} [state.pre] How macros are prefixed. See `getPre`.\n * @param {number} state.passNow The index of the currently active pass.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<number>} state.maps.values How values of each data item may be\n *     grouped into textures across passes. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures The groupings of values\n *     into textures. See `mapGroups`.\n * @param {array<array<number>>} state.maps.passes The groupings of textures\n *     into passes. See `mapGroups`.\n *\n * @returns {string} The GLSL preprocessor macros defining the bound outputs.\n */\nexport function macroOutput(state) {\n    const key = hooks.macroOutput;\n    const hook = hasMacros(state, key);\n\n    if(hook !== false) { return hook; }\n\n    const { passNow: p, maps: { values, textures, passes } } = state;\n    const n = getPre(state);\n    const pass = passes[p];\n    const c = key+':'+JSON.stringify({ n, p, values, textures, passes });\n\n    return (cache[c] || (cache[c] =\n        `#define ${n}passNow ${p}\\n`+\n        reduce((s, texture, bound, _, i = 0) => reduce((s, v) => `${s}\\n`+\n                    `#define ${n}bound_${v} ${texture}\\n`+\n                    `#define ${n}attach_${v} ${bound}\\n`+\n                    `#define ${n}output_${v} gl_FragData[${n}attach_${v}].${\n                        rgba.slice(i, (i += values[v]))\n                    }\\n`,\n                textures[texture], s),\n            pass, '')));\n}\n\n/**\n * Defines the texture samples/reads per-pass, as GLSL preprocessor macros.\n * The macros define the mapping between the values and the minimum texture\n * samples for the data they derive from. They're set up as function-like macros\n * that may be called from the shader to initialise the mappings arrays with a\n * given name.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see getPre\n * @see getGLSLList\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [mapSamples]{@link ./maps.js#mapSamples}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     macroSamples({\n *         passNow: 0,\n *         maps: mapSamples(mapGroups({\n *             values: [4, 2, 1], channelsMax: 4, texturesMax: 1,\n *             derives: [[1, 0], , [3, [1, 0]]]\n *         }))\n *     }); // =>\n *     '#define useSamples '+\n *         'const int samples_l = 2; '+\n *         'const ivec2 samples_0 = ivec2(0, 1); '+\n *         'const ivec2 samples_1 = ivec2(0, 0);\\n'+\n *     '#define samples_i(i) ((i == 1)? samples_1 : samples_0)\\n'+\n *     '\\n'+\n *     '#define tapSamples(states, uv, textures) '+\n *         'const int data_l = 2; '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = texture2D(states[(0*textures)+1], uv); '+\n *         'data[1] = texture2D(states[(0*textures)+0], uv);\\n'+\n *         '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define useReads_0 '+\n *         'const int reads_0_l = 2; '+\n *         'const int reads_0_0 = int(0); '+\n *         'const int reads_0_1 = int(1);\\n'+\n *     '#define reads_0_i(i) ((i == 1)? reads_0_1 : reads_0_0)\\n';\n *\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string|function|object|falsey} [state.macros] How macros are handled\n *     or prefixed. See `hasMacros` and `getPre`.\n * @param {string} [state.pre] How macros are prefixed. See `getPre`.\n * @param {number} state.passNow The index of the currently active pass.\n * @param {object} state.maps  How `values` are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<array<number>>>} [state.maps.samples] The minimal set of\n *     texture samples to use. See `mapSamples`.\n * @param {array<array<array<number>>>} [state.maps.reads] The mappings from\n *     values to the corresponding `state.samples`. See `mapSamples`.\n * @param {number} [state.glsl=1] The GLSL language version. See `getGLSLList`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings for\n *     samples and reads, for each value.\n */\nexport function macroSamples(state) {\n    const key = hooks.macroSamples;\n    const hook = hasMacros(state, key);\n\n    if(hook !== false) { return hook; }\n\n    const { passNow: p, maps: { samples, reads }, glsl } = state;\n    const n = getPre(state);\n    const passSamples = (samples && samples[p]);\n    const passReads = (reads && reads[p]);\n    // Whether to generate GLSL preprocessor macros for the lookup logic.\n    const tap = hasMacros(state, hooks.macroSamplesTap);\n\n    const c = key+':'+\n        JSON.stringify({ n, p, passSamples, passReads, glsl, tap });\n\n    return (cache[c] || (cache[c] =\n        ((!passSamples)? ''\n        :   `#define ${n}useSamples ${\n                getGLSLList('ivec2', `${n}samples`, passSamples, 'const', glsl)\n            }\\n`+\n            // The texture-sampling logic.\n            // @todo `Index expression must be constant`\n            ((tap !== false)? tap\n            :   `#define ${n}tapSamples(states, uv, textures) ${\n                    getGLSLList('vec4', `${n}data`,\n                        // 2D-to-1D indexing, as textures a flat array.\n                        map(([s, t]) =>\n                                `texture2D(states[(${s}*textures)+${t}], uv)`,\n                            passSamples),\n                        '', glsl)}\\n`))+\n        ((!passReads)? ''\n        :   reduce((s, reads, v) =>\n                    `${s}\\n#define ${n}useReads_${v} ${\n                        getGLSLList('int', `${n}reads_${v}`, reads, 'const',\n                            glsl)}`,\n                passReads, ''))));\n}\n\n/**\n * Defines all GLSL preprocessor macro values, texture samples, and outputs for\n * the active pass.\n * The macros define the mapping between the active values, their textures and\n * channels, bound outputs, and other macros useful for a draw pass.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see macroValues\n * @see macroOutput\n * @see macroSamples\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const state = {\n *         steps: Array(2), passNow: 0,\n *         maps: mapSamples(mapGroups({\n *             values: [4, 2, 3], channelsMax: 4, texturesMax: 1,\n *             derives: [[1, 0], [2, [1, 0]]]\n *         }))\n *     };\n *\n *     macroPass(state); // =>\n *     '#define texture_0 0\\n'+\n *     '#define channels_0 rgba\\n'+\n *     '\\n'+\n *     '#define texture_1 1\\n'+\n *     '#define channels_1 rg\\n'+\n *     '\\n'+\n *     '#define texture_2 2\\n'+\n *     '#define channels_2 rgb\\n'+\n *     '\\n'+\n *     '#define textures 3\\n'+\n *     '#define passes 3\\n'+\n *     '#define steps 2\\n'+\n *     '\\n'+\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_0 0\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rgba\\n'+\n *     '\\n'+\n *     '#define useSamples '+\n *         'const int samples_l = 2; '+\n *         'const ivec2 samples_0 = ivec2(0, 1); '+\n *         'const ivec2 samples_1 = ivec2(0, 0);\\n'+\n *     '#define samples_i(i) ((i == 1)? samples_1 : samples_0)\\n'+\n *     '\\n'+\n *     '#define tapSamples(states, uv, textures) '+\n *         'const int data_l = 2; '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = texture2D(states[(0*textures)+1], uv); '+\n *         'data[1] = texture2D(states[(0*textures)+0], uv);\\n'+\n *         '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define useReads_0 '+\n *         'const int reads_0_l = 2; '+\n *         'const int reads_0_0 = int(0); '+\n *         'const int reads_0_1 = int(1);\\n'+\n *     '#define reads_0_i(i) ((i == 1)? reads_0_1 : reads_0_0)\\n';\n *\n *     ++state.passNow;\n *     state.macros = 'draw_';\n *     state.steps.push(null);\n *     Object.assign(state.maps, mapSamples(mapGroups({\n *         values: [4, 2, 3, 1], channelsMax: 4, texturesMax: 2,\n *         derives: [[1, 0], , [2, [1, 0]]]\n *     })));\n *\n *     macroPass(state); // =>\n *     '#define draw_texture_0 0\\n'+\n *     '#define draw_channels_0 rgba\\n'+\n *     '\\n'+\n *     '#define draw_texture_1 1\\n'+\n *     '#define draw_channels_1 rg\\n'+\n *     '\\n'+\n *     '#define draw_texture_2 2\\n'+\n *     '#define draw_channels_2 rgb\\n'+\n *     '\\n'+\n *     '#define draw_texture_3 2\\n'+\n *     '#define draw_channels_3 a\\n'+\n *     '\\n'+\n *     '#define draw_textures 3\\n'+\n *     '#define draw_passes 2\\n'+\n *     '#define draw_steps 3\\n'+\n *     '\\n'+\n *     '#define draw_passNow 1\\n'+\n *     '\\n'+\n *     '#define draw_bound_2 2\\n'+\n *     '#define draw_attach_2 0\\n'+\n *     '#define draw_output_2 gl_FragData[draw_attach_2].rgb\\n'+\n *     '\\n'+\n *     '#define draw_bound_3 2\\n'+\n *     '#define draw_attach_3 0\\n'+\n *     '#define draw_output_3 gl_FragData[draw_attach_3].a\\n'+\n *     '\\n'+\n *     '#define draw_useSamples '+\n *         'const ivec2 draw_samples_0 = ivec2(0, 2); '+\n *         'const ivec2 draw_samples_1 = ivec2(1, 0); '+\n *         'const int draw_samples_l = 2;\\n'+\n *     '#define draw_samples_i(i) '+\n *         '((i == 1)? draw_samples_1 : draw_samples_0)\\n'+\n *     '\\n'+\n *     '#define draw_tapSamples(states, uv, textures) '+\n *         'const int data_l = 2; '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = texture2D(states[(0*textures)+2], uv); '+\n *         'data[1] = texture2D(states[(1*textures)+0], uv);\\n'+\n *         '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define draw_useReads_2 '+\n *         'const int draw_reads_2_l = 2; '+\n *         'const int draw_reads_2_0 = int(0); '+\n *         'const int draw_reads_2_1 = int(1);\\n'+\n *     '#define draw_reads_2_i(i) '+\n *         '((i == 1)? draw_reads_2_1 : draw_reads_2_0)\\n';\n *\n * @export\n * @param {object} state Properties for generating the macros. See `getState`\n *     and `mapGroups`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings for\n *     values, textures, channels, bound outputs of the active pass, etc. See\n *     `macroValues`, `macroOutput`, and `macroSamples`.\n */\nexport function macroPass(state) {\n    const key = hooks.macroPass;\n    const hook = hasMacros(state, key);\n\n    return ((hook !== false)? hook\n        :   macroValues(state)+'\\n'+macroOutput(state)+'\\n'+\n                macroSamples(state)+'\\n');\n}\n\nexport default macroPass;\n","/**\n * GPGPU inputs (uniforms, attributes, indexes, etc).\n */\n\nimport { setC2 } from '@thi.ng/vectors/setc';\nimport map from '@epok.tech/fn-lists/map';\nimport range from '@epok.tech/fn-lists/range';\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap-index';\nimport isNumber from '@epok.tech/is-type/number';\n\nimport { boundDef, preDef } from './const';\n\n/**\n * Common uniform inputs for GPGPU `step` and `draw`.\n * Uniforms are defined as callback hooks pulling from given `context` and\n * `props` properties, allowing different APIs or author-defined hooks.\n *\n * @see [getState]{@link ./state.js#getState}\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n *\n * @export\n * @param {object} state The GPGPU state to use. See `getState` and `mapGroups`.\n * @param {array} state.steps The steps of state. See `getState`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures How values are grouped into\n *     textures. See `mapGroups`.\n * @param {number} [state.bound=boundDef] How many steps are bound as outputs,\n *     unavailable as inputs.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n * @param {object} [out={}] The object to contain the uniforms.\n *\n * @returns {object<function>} `out` The uniform hooks for the given `state`.\n *     Each is a function taking 2 arguments: a `context` object of general\n *     or global properties, and a `props` object of local properties (such as\n *     the given `state`).\n */\nexport function getUniforms(state, out = {}) {\n    const {\n            steps: { length: stepsL }, maps: { textures: textureMap },\n            bound = boundDef, pre: n = preDef\n        } = state;\n\n    const texturesL = textureMap.length;\n    const cache = { viewShape: [] };\n\n    out[n+'stepNow'] = (_, { stepNow: s }) => s;\n    out[n+'dataShape'] = (_, { size: { shape: s } }) => s;\n    out[n+'viewShape'] = ({ viewportWidth: w, viewportHeight: h }) =>\n        setC2(cache.viewShape, w, h);\n\n    // Set up the past steps, as the number of steps into the past from the\n    // currently bound step ([1...(steps-1)]).\n\n    const addTexture = (past, texture) =>\n        // Hook to pull a given texture from the latest `props`.\n        out[`${n}states[${(past*texturesL)+texture}]`] =\n            (_, { stepNow: s, bound: b = bound, textures }) =>\n                wrap.get(s-b-past, textures)[texture].texture;\n\n    // Flatten all input textures, as uniforms are stored in flat arrays.\n    for(let past = 0, pl = stepsL-bound; past < pl; ++past) {\n        each((v, texture) => addTexture(past, texture), textureMap);\n    }\n\n    return out;\n}\n\n/**\n * Gives the number of indexes needed to draw a full state.\n *\n * @param {object} size Size/type information on data resources.\n * @param {number} [size.width] The width of each data-texture.\n * @param {number} [size.height] The height of each data-texture.\n * @param {number} [size.count=size.width*size.height] How many entries are in\n *     each data-texture; that is, its area (width*height).\n *\n * @returns {number} The number of indexes needed to draw a full state.\n */\nexport const countDrawIndexes = ({ width: w, height: h, count = w*h }) => count;\n\n/**\n * Gives the array of indexes needed to draw a full state.\n *\n * @param {number|object<number>} size The number of entries in each\n *     data-texture; or an object of size/type information on data resources.\n *\n * @returns {array<number>} An array of indexes for drawing all data-texture\n *     entries.\n */\nexport const getDrawIndexes = (size) =>\n    map((v, i) => i, range(isNumber(size)? size : countDrawIndexes(size)), 0);\n","export const setC2 = (out, x, y) => (!out && (out = []), (out[0] = x), (out[1] = y), out);\nexport const setC3 = (out, x, y, z) => (!out && (out = []), (out[0] = x), (out[1] = y), (out[2] = z), out);\nexport const setC4 = (out, x, y, z, w) => (!out && (out = []),\n    (out[0] = x),\n    (out[1] = y),\n    (out[2] = z),\n    (out[3] = w),\n    out);\nexport const setC6 = (out, a, b, c, d, e, f) => (!out && (out = []),\n    (out[0] = a),\n    (out[1] = b),\n    (out[2] = c),\n    (out[3] = d),\n    (out[4] = e),\n    (out[5] = f),\n    out);\nexport const setC = (out, ...xs) => {\n    !out && (out = []);\n    for (let i = 0, n = xs.length; i < n; i++) {\n        out[i] = xs[i];\n    }\n    return out;\n};\n","/**\n * How many vertexes for pairs of line segments linking each entry's states,\n * using `gl.LINES`.\n * If fewer than 2 states are given, lines can't be drawn, assumes `gl.POINTS`.\n * Every pair of indexes is a line-segment connecting each state to its past\n * state, making one continuous line back through steps using `gl.LINES`;\n * iterating each start index and its past index.\n * Corresponds to the indexing logic in the `indexPairs` GLSL function.\n *\n * @see [readme]{@link ./readme.md}\n * @see `gl.LINES` at https://webglfundamentals.org/webgl/lessons/webgl-points-lines-triangles.html\n * @see [indexPairs]{@link ./index.glsl#indexPairs}\n *\n * @param {number} states The number of steps of state to link by pairs of line\n *     segments.\n *\n * @returns {number} The number of points needed to link all steps of state\n *     by pairs of line segments. May be multiplied with the number of entries\n *     in each step.\n */\nexport const indexPairs = (states) => Math.max(1, (states-1)*2);\n\nexport default indexPairs;\n","precision highp float;\n\nattribute vec2 position;\n\nvarying vec2 uv;\n\n// Translation for UV NDC to texture coordinates.\nconst vec2 offset = vec2(0.5);\n\nvoid main() {\n    uv = (position*0.5)+offset;\n    gl_Position = vec4(position, 0, 1);\n}\n","/**\n * The update step for a GPGPU particle simulation.\n * Requires setup with preprocessor macros - see `macroPass`.\n *\n * @see [getStep]{@link ../../step.js#getStep}\n * @see [macroPass]{@link ../../macros.js#macroPass}\n */\n\n#ifdef GL_EXT_draw_buffers\n    #extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\n\n// Setting up the macros and aliases.\n\n#define posTexture texture_0\n#define lifeTexture texture_1\n#define accTexture texture_2\n\n#define posChannels channels_0\n#define lifeChannels channels_1\n#define accChannels channels_2\n\nuseSamples\n\n#ifdef output_0\n    #define posOutput output_0\n    useReads_0\n    #define posReadPos0 reads_0_i(0)\n    #define posReadPos1 reads_0_i(1)\n    #define posReadAcc reads_0_i(2)\n    #define posReadLife reads_0_i(3)\n#endif\n#ifdef output_1\n    #define lifeOutput output_1\n    useReads_1\n    #define lifeReadLifeOldest reads_1_i(0)\n    #define lifeReadLife1 reads_1_i(1)\n#endif\n#ifdef output_2\n    #define accOutput output_2\n    useReads_2\n    #define accReadAcc reads_2_i(0)\n    #define accReadLife reads_2_i(1)\n#endif\n\n// The main shader.\n\n// States from `gl-gpgpu`.\nuniform sampler2D states[stepsPast*textures];\nuniform vec2 dataShape;\n// Custom inputs for this demo.\nuniform float dt;\nuniform float time;\nuniform float loop;\nuniform vec2 lifetime;\nuniform vec2 force;\nuniform float useVerlet;\nuniform vec3 g;\nuniform vec3 source;\n\nvarying vec2 uv;\n\n#pragma glslify: map = require('glsl-map');\n\n#ifdef posOutput\n    #pragma glslify: verlet = require('@epok.tech/glsl-verlet');\n#endif\n\n#if defined(lifeOutput) || defined(accOutput)\n    #pragma glslify: random = require('glsl-random');\n#endif\n\n#ifdef accOutput\n    const float tau = 6.28318530718;\n\n    // @see https://observablehq.com/@rreusser/equally-distributing-points-on-a-sphere\n    vec3 randomOnSphere(vec2 randoms) {\n        float a = randoms[0]*tau;\n        float u = (randoms[1]*2.0)-1.0;\n\n        return vec3(sqrt(1.0-(u*u))*vec2(cos(a), sin(a)), u);\n    }\n#endif\n\n#pragma glslify: le = require('glsl-conditionals/when_le');\n\nvoid main() {\n    // Sample textures.\n    // Add pixel offset to sample from the pixel's center and avoid errors.\n    vec2 st = uv+(vec2(0.25)/dataShape);\n\n    tapSamples(states, st, textures)\n\n    // Read values.\n\n    #ifdef posOutput\n        vec3 pos0 = data[posReadPos0].posChannels;\n    #endif\n    #if defined(lifeOutput) || defined(posOutput)\n        vec3 pos1 = data[posReadPos1].posChannels;\n    #endif\n\n    #if defined(lifeOutput) || defined(posOutput) || defined(accOutput)\n        #if defined(posOutput)\n            #define readLife posReadLife\n        #elif defined(lifeOutput)\n            #define readLife lifeReadLife\n        #elif defined(accOutput)\n            #define readLife accReadLife\n        #endif\n\n        float life = data[readLife].lifeChannels;\n        float spawn = le(life, 0.0);\n    #endif\n\n    #if defined(lifeOutput)\n        float lifeOldest = data[lifeReadLifeOldest].lifeChannels;\n    #endif\n\n    #if defined(posOutput) || defined(accOutput)\n        #if defined(posOutput)\n            #define readAcc posReadAcc\n        #elif defined(accOutput)\n            #define readAcc accReadAcc\n        #endif\n\n        vec3 acc = data[readAcc].accChannels;\n    #endif\n\n    // Output updated values.\n    #ifdef posOutput\n        // Use either Euler or Verlet integration.\n        vec3 pos = mix(pos1+(acc*dt), verlet(acc, pos0, pos1, dt), useVerlet);\n\n        posOutput = mix(pos, source, spawn);\n    #endif\n    #ifdef lifeOutput\n        life = max(0.0, life-dt);\n\n        float lifeSpawn = map(random(uv*loop),\n            0.0, 1.0, lifetime[0], lifetime[1]);\n\n        // Only spawn life once the oldest step reaches the end of its lifetime\n        // (past and current life are both 0).\n        lifeOutput = mix(life, lifeSpawn, spawn*le(lifeOldest, 0.0));\n    #endif\n    #ifdef accOutput\n        // To help accuracy of very small numbers, pass force as `[x, y] = xEy`.\n        float f = force.x*pow(10.0, force.y);\n\n        acc += g*f*dt;\n\n        vec2 randoms = vec2(random((uv+loop)/dt), random((uv-loop)*dt));\n        vec3 accSpawn = randomOnSphere(randoms)*random(loop-(uv*dt))*f*5e3;\n\n        accOutput = mix(acc, accSpawn, spawn);\n    #endif\n}\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see [macroPass]{@link ../../macros.js#macroPass}\n * @see [macroValues]{@link ../../macros.js#macroValues}\n */\n\n#define posTexture texture_0\n#define lifeTexture texture_1\n#define accTexture texture_2\n\n#define posChannels channels_0\n#define lifeChannels channels_1\n#define accChannels channels_2\n\nprecision highp float;\n\nattribute float index;\n\nuniform sampler2D states[stepsPast*textures];\nuniform vec2 dataShape;\nuniform vec2 viewShape;\nuniform float pointSize;\nuniform vec2 lifetime;\nuniform float scale;\n\nvarying vec4 color;\n\n#pragma glslify: aspect = require(@epok.tech/glsl-aspect/contain)\n#pragma glslify: gt = require(glsl-conditionals/when_gt)\n\n#pragma glslify: indexPairs = require(../../index-pairs)\n\nvoid main() {\n    #if stepsPast < 2\n        // If fewer than 2 steps are given, uses `gl.POINTS`.\n        vec2 stepEntry = vec2(0.0, index);\n    #else\n        vec2 stepEntry = indexPairs(index, float(stepsPast));\n    #endif\n\n    // Step back a full state's worth of textures per step index.\n    int stateIndex = int(stepEntry[0])*textures;\n\n    // Turn the 1D index into a 2D texture UV.\n    // Add pixel offset to sample from the pixel's center and avoid errors.\n    vec2 uv = vec2(mod(stepEntry[1]+0.25, dataShape.x)/dataShape.x,\n        (floor(stepEntry[1]/dataShape.x)+0.25)/dataShape.y);\n\n    // Sample the desired state values.\n    // @todo Make use of the `reads` logic to take the minimum possible samples.\n    vec3 pos = texture2D(states[stateIndex+posTexture], uv).posChannels;\n    float life = texture2D(states[stateIndex+lifeTexture], uv).lifeChannels;\n    float l = pow(life/lifetime[1], 0.7);\n\n    color = mix(vec4(l),\n        vec4(stepEntry[0]/float(stepsPast), stepEntry[1]/float(count), 0.8,\n            l/(dataShape.x*dataShape.y)),\n        l);\n\n    vec2 ar = aspect(viewShape);\n\n    gl_Position = gt(life, 0.0)*\n        vec4(vec3(pos.xy*ar, pos.z*max(ar.x, ar.y))*scale, 1);\n\n    gl_PointSize = pointSize*l;\n}\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see [macroPass]{@link ../../macros.js#macroPass}\n * @see [macroValues]{@link ../../macros.js#macroValues}\n */\n\nprecision highp float;\n\nvarying vec4 color;\n\nvoid main() { gl_FragColor = color; }\n"],"names":["_console","_console1","ref","ref1","reglProps","extensions","$hBMe5","extensionsFloat","optionalExtensions","regl","self","$parcel$interopDefault","$3Cmit","console","log","apply","concat","$kxEDL","default","map","e","hasExtension","canvas","document","querySelector","query","$e0CCo","parse","location","search","slice","steps1","parseInt","steps","scale1","Math","floor","scale","sqrt","valuesMap","position","life","acceleration","valuesKeys","Object","keys","derivesMap","min","indexOf","max","values","derives","canVerlet","bound","state","$e3wLf","gpgpu","props","timer","step","time","now","rate","loop","useVerlet","lifetime","g","source","force","maps","vert","$dAkAi","frag","$jYFPA","verts","frags","uniforms","dt","_","param","_props","sin","PI","prop","s","b","length","$8g7pT","drawCount","$gyl7y","countDrawIndexes","size","$i7NAh","drawIndexes","getDrawIndexes","drawState","$9BYky","drawCommand","$1tr74","macroValues","$57MSl","$7Lnkd","attributes","index","getUniforms","pointSize","lineWidth","count","primitive","draw","frame","run","stepNow","addEventListener","stopPropagation","preventDefault","x","clientX","y","clientY","innerWidth","innerHeight","module","hot","accept","call","reload","obj","key","value","defineProperty","enumerable","configurable","writable","target","i","arguments","ownKeys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","forEach","$gHSxu","arr","$km6mS","$3rVPa","$iWEHp","Array","isArray","iter","Symbol","iterator","prototype","toString","from","TypeError","$kJ5JC","$f24YN","arr2","$a32f05930136dd0a$export$2f872c0f2117be69","$a32f05930136dd0a$export$98e6a39c04603d36","$a32f05930136dd0a$export$c564cdbbe6da493","$a32f05930136dd0a$export$fac44ee5b035f737","parcelRequire","$432a03fd38fe166a$var$hasOwnProperty","hasOwnProperty","exports","qs","sep","eq","options","regexp","split","maxKeys","len","kstr","vstr","k","v","replace","idx","substr","decodeURIComponent","$432a03fd38fe166a$var$isArray","push","xs","$000d6f7e9a744db1$var$stringifyPrimitive","isFinite","name","undefined","$000d6f7e9a744db1$var$map","$000d6f7e9a744db1$var$objectKeys","ks","encodeURIComponent","$000d6f7e9a744db1$var$isArray","join","f","res","$60359228a7d3fb28$export$be3f796aed065412","diff","pause","add","$60359228a7d3fb28$export$7548f4bc1b09ff22","$60359228a7d3fb28$export$85b884786400d38f","$60359228a7d3fb28$export$2e2bcd8739ae039","out","t0","d","t1","isNaN","$097d2d6ba61fde6a$export$ba60520149d1328e","$097d2d6ba61fde6a$export$878041e1e4cd4218","flat","$4ad49746d3e88695$export$acb6ab09ed1b7b8b","l","$4ad49746d3e88695$export$2e2bcd8739ae039","get","a","$a3bac22a2cec4520$export$a8489f67fe30ef76","api","param1","_texturesMax","limits","texturesMax","maxDrawbuffers","glsl","_maps","parseFloat","match","$4MXss","mapGroups","mapSamples","$20H3c","getState","$4NSvD","getStep","$37c9c43fd5907c13$export$69a3209f1a06c04d","$37c9c43fd5907c13$export$5ca26c99531348ec","channelsMax","channelsMaxDef","error","$37c9c43fd5907c13$export$96707a1f51900f3d","param2","out1","_values","valuesDef","_channelsMax","texturesMaxDef","_packed","packed","$9pabq","channels","fitIndex","fitSize","Infinity","i1","fit","pack","$37c9c43fd5907c13$export$9d1d9285bd6d8c57","passes","textures","valueToTexture","valueToPass","textureToPass","getValue","$ksHHi","p","pass","t","texture","$37c9c43fd5907c13$export$574963e692b662ec","param3","reads","getAddSamples","set","valueDerives","$9yAa9","derive","sample","Number","isInteger","every","_sample","$84KjE","findIndex","_param","passReads","getAddSample","samples","$6d8e5906de1cf303$export$2e2bcd8739ae039","reduce","$ee5851911330bf41$var$r","$ee5851911330bf41$export$533b26079ad0b4b","$ee5851911330bf41$export$2e2bcd8739ae039","$6f535731e26073af$var$e","$6f535731e26073af$export$2e2bcd8739ae039","$cd1b4d1540633814$export$ac0cd3cc21f80dfc","$cd1b4d1540633814$export$4bceda1224fc5ab8","$cd1b4d1540633814$export$b4781c2237bde956","$cd1b4d1540633814$export$26945b8c914b7fc","$cd1b4d1540633814$export$154f256b9eac9103","$cd1b4d1540633814$export$4d253b84ce5f5f8e","$cd1b4d1540633814$export$b029aceb5666f022","$cd1b4d1540633814$export$71c6d8e332d66a75","$cd1b4d1540633814$export$617a37502ff8853","$cd1b4d1540633814$export$27fb0dad99ae5dd2","$cd1b4d1540633814$export$ff01eb58fe4e69","$cd1b4d1540633814$export$cfdc3a7c4cb854c6","$OvAQZ","positions","$176cf9cb32bd006b$export$50fdfeece43146fd","framebuffer","radius","width","height","_scale","scaleDef","_type","type","typeDef","_steps","stepsDef","_stepNow","_passNow","passNow","_channelsMin","channelsMin","channelsMinDef","texturesMap","textureProps1","mag","wrap","pow","$cgVN0","shape","textures1","passes1","addPass","passProps","max1","textureProps","addTexture","color","depth","stencil","$88hlK","$5ebc876929a0439f$export$2e2bcd8739ae039","n","start","end","fill","$8ef3ce73a578cefc$export$2e2bcd8739ae039","$ayMqI","$7b02a589e8d7c18a$var$start","$7b02a589e8d7c18a$var$end","$7b02a589e8d7c18a$export$bf9fb029d174d554","_obj","$37f6056e300b6832$var$scale","$37f6056e300b6832$export$89e7bec3b8bce705","buffer","_command","command","_pre","pre","preDef","_step1","step1","_positions","positionsDef","_vert","$fuIAL","_count","stateCache","passMacros","macroPass","passCommand","tmp","tmp1","vs","tmp2","fs","enable","ss","$6qjSx","_step","onPass","onStep","$112d87fa33ebb5f5$export$4e46ac54fc82cf3b","$112d87fa33ebb5f5$export$69a3209f1a06c04d","$112d87fa33ebb5f5$export$11949c6f5fba7dcd","$112d87fa33ebb5f5$export$eb485f7ab2fcf311","macros","$112d87fa33ebb5f5$export$1c7039c93eddfba","qualify","init","$112d87fa33ebb5f5$export$3df19e70a88cb8cd","$112d87fa33ebb5f5$export$45db4de6da38aa8d","$112d87fa33ebb5f5$export$c346962e7dd3191","param4","trim","$112d87fa33ebb5f5$export$feaf5ffc92c2af94","$112d87fa33ebb5f5$export$84186522bf5a7d4d","hook","passesL","stepsL","_bound","boundDef","c","JSON","stringify","s1","$112d87fa33ebb5f5$export$d38b14fb9031108e","s2","$112d87fa33ebb5f5$export$49873e279ff642c0","reads1","passSamples","tap","$112d87fa33ebb5f5$export$9cb6037fa2a40c2e","$c0d0347db9b941ce$export$4e06fab977536f8e","past","textureMap","texturesL","cache","w","viewportWidth","h","viewportHeight","$fnH3v","setC2","pl","_loop","$c0d0347db9b941ce$export$a495db45d4904b10","$c0d0347db9b941ce$export$87ed20f81f3c66ff","$b32a66f4c5b7b75f$export$dcfbb7940cfb3a48","$0367bb3900f2b1c9$export$2e2bcd8739ae039","states"],"version":3,"file":"index.4579a774.js.map"}