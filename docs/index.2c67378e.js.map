{"mappings":"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","sources":["demo/particles/index.js","node_modules/@swc/helpers/src/_define_property.js","node_modules/@swc/helpers/src/_object_spread.js","node_modules/@swc/helpers/src/_sliced_to_array.js","node_modules/@swc/helpers/src/_array_with_holes.js","node_modules/@swc/helpers/src/_iterable_to_array.js","node_modules/@swc/helpers/src/_non_iterable_rest.js","node_modules/@swc/helpers/src/_to_consumable_array.js","node_modules/@swc/helpers/src/_array_without_holes.js","node_modules/@swc/helpers/src/_non_iterable_spread.js","node_modules/clamp/index.js","node_modules/@epok.tech/fn-time/dist/es/index.js","node_modules/@epok.tech/fn-lists/reduce.js","node_modules/@epok.tech/fn-lists/map.js","node_modules/@epok.tech/fn-lists/each.js","node_modules/@epok.tech/fn-lists/range.js","index.js","maps.js","const.js","node_modules/@epok.tech/gl-screen-triangle/dist/esm/index.js","index.vert.glsl","state.js","step.js","node_modules/@epok.tech/fn-lists/wrap-index.js","macros.js","node_modules/@epok.tech/is-type/type.js","inputs.js","node_modules/@thi.ng/vectors/setc.js","index-pairs/index.js","demo/particles/step.frag.glsl","demo/particles/draw.vert.glsl","demo/particles/draw.frag.glsl"],"sourcesContent":["/**\n * Demo implementation of 3D particle Verlet/Euler integration simulation.\n */\n\nimport getRegl from 'regl';\nimport clamp from 'clamp';\nimport timer from '@epok.tech/fn-time';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\nimport each from '@epok.tech/fn-lists/each';\nimport range from '@epok.tech/fn-lists/range';\n\nimport { gpgpu, extensionsFloat, extensionsHalfFloat, optionalExtensions }\n    from '../../index';\n\nimport { macroPass } from '../../macros';\nimport { getMaps } from '../../maps';\nimport { getUniforms, getDrawIndexes } from '../../inputs';\nimport indexPairs from '../../index-pairs';\n\nimport stepFrag from './step.frag.glsl';\nimport drawVert from './draw.vert.glsl';\nimport drawFrag from './draw.frag.glsl';\n\nself.gpgpu = gpgpu;\nself.macroPass = macroPass;\nself.getMaps = getMaps;\nself.getUniforms = getUniforms;\nself.getDrawIndexes = getDrawIndexes;\nself.indexPairs = indexPairs;\n\nconst extend = {\n    halfFloat: extensionsHalfFloat?.(),\n    float: extensionsFloat?.(),\n    other: optionalExtensions?.()\n};\n\nconst regl = self.regl = getRegl({\n    pixelRatio: Math.max(Math.floor(devicePixelRatio), 1.5),\n    extensions: extend.required = extend.halfFloat,\n    optionalExtensions: extend.optional = [...extend.float, ...extend.other]\n});\n\nconsole.group('Extensions');\n\nconsole.log('required', (extend.required &&\n    reduce((o, e) => o+(o && '; ')+e+': '+regl.hasExtension(e),\n        extend.required, '')));\n\nconsole.log('optional', (extend.optional &&\n    reduce((o, e) => o+(o && '; ')+e+': '+regl.hasExtension(e),\n        extend.optional, '')));\n\nconsole.groupEnd();\n\nconst canvas = document.querySelector('canvas');\n\ncanvas.classList.add('view');\n\n// How many frame-buffers are bound at a given time.\nconst bound = 1;\n\n// How many values/channels each property independently tracks.\n// The order here corresponds to the order in the shaders and generated macros,\n// though these may be `packed` across channels/textures/passes differently.\n\nconst valuesMap = (new Map())\n    .set('position', 3).set('motion', 3).set('life', 1);\n\nconst values = [];\nconst valuesIndex = {};\n\nvaluesMap.forEach((v, k) => valuesIndex[k] = values.push(v)-1);\n\n// Limits of this device and these `values`.\nconst { maxTextureUnits, maxTextureSize, lineWidthDims, pointSizeDims } =\n    regl.limits;\n\nconst limits = {\n    steps: [\n        1+bound,\n        Math.floor(maxTextureUnits/(reduce((s, v) => s+v, values, 0)/4))\n    ],\n    // Better stay farther under maximum texture size, or errors/crashes.\n    scale: [1, Math.log2(maxTextureSize)]\n};\n\nconst niceScale = clamp(8, ...limits.scale);\n\nconsole.log('limits', limits, regl.limits);\n\n// Handle query parameters.\n\nconst getQuery = (search = location.search) => new URLSearchParams(search);\n\nfunction setQuery(entries, query = getQuery()) {\n    each(([k, v = null]) => ((v === null)? query.delete(k) : query.set(k, v)),\n        entries);\n\n    return query;\n}\n\nlet query = getQuery();\n\n// 1 active state, as many others as can be bound; at least 2 past states needed\n// for Verlet integration, 1 for Euler integration.\nconst steps = Math.floor(clamp((parseInt(query.get('steps'), 10) || 1+bound),\n    ...limits.steps));\n\nconst stepsPast = steps-bound;\n\nconst scale = Math.floor(clamp((parseInt(query.get('scale'), 10) || niceScale),\n    ...limits.scale));\n\n// Trails of points if given; if not given, uses trails of lines.\nconst usePoints = query.has('points');\n\n// Constant-step (add time-step), if given; if not given, uses real-time\n// (variable delta-time).\nconst hasTimestep = query.has('timestep');\nconst timestepDef = 1e3/60;\n\nconst timestep = (hasTimestep &&\n    (parseFloat(query.get('timestep'), 10) || timestepDef));\n\nconsole.log(location.search+':\\n', ...([...query.entries()].flat()), '\\n',\n    'steps:', steps, 'scale:', scale, 'timestep:', timestep);\n\n// Set up the links.\n\ndocument.querySelector('#default').href =\n    `?${setQuery([['steps'], ['scale']])}#default`;\n\ndocument.querySelector('#verlet').href = `?${setQuery([\n        ['steps', 2+bound], ['scale', niceScale]\n    ])}#verlet`;\n\ndocument.querySelector('#long').href = `?${setQuery([\n        ['steps', limits.steps[1]],\n        ['scale', clamp(limits.scale[0]+5, limits.scale[1]-8, limits.scale[1])]\n    ])}#long`;\n\ndocument.querySelector('#max').href = `?${setQuery([\n        ['steps', Math.max(limits.steps[0], limits.steps[1]-3)],\n        ['scale', Math.max(niceScale, limits.scale[1]-5)]\n    ])}#max`;\n\ndocument.querySelector('#trails').href =\n    `?${setQuery([['points', ((usePoints)? null : '')]])}#trails`;\n\ndocument.querySelector('#timestep').href =\n    `?${setQuery([['timestep', ((timestep)? null : timestepDef)]])}#timestep`;\n\n// How values/channels map to their derivations.\n\nconst derives = [];\n\nderives[valuesIndex.position] = [\n    // Position, 2 steps past.\n    [clamp(1, 0, stepsPast-1), valuesIndex.position],\n    // Position, 1 step past.\n    valuesIndex.position,\n    valuesIndex.motion,\n    valuesIndex.life\n];\n\nderives[valuesIndex.motion] = [\n    valuesIndex.motion,\n    valuesIndex.life\n];\n\nderives[valuesIndex.life] = [\n    // Life, last step past.\n    [Math.max(stepsPast-1, 0), valuesIndex.life],\n    // Life, 1 step past.\n    valuesIndex.life\n];\n\n// Whether to allow Verlet integration.\nconst canVerlet = (stepsPast >= 2);\n\n// The main GPGPU state.\nconst state = gpgpu(regl, {\n    props: {\n        // Set up the timer.\n        timer: timer((timestep)?\n                // Constant-step (add time-step).\n                { step: timestep, dts: range(2, 0) }\n                // Real-time (variable delta-time).\n            :   { step: '-', now: () => regl.now()*1e3, dts: range(2, 0) }),\n        // Speed up or slow down the passage of time.\n        rate: 1,\n        // Loop time over this period to avoid instability of parts of the demo.\n        loop: 3e3,\n        // Range of how long a particle lives before respawning.\n        lifetime: [5e2, 3e3],\n        // Whether to use Verlet (midpoint) or Euler (forward) integration.\n        useVerlet: canVerlet,\n        // Acceleration due to gravity.\n        g: [0, -9.80665, 0],\n        // The position particles respawn from.\n        source: [0, 0, 0.5],\n        // For numeric accuracy, encoded as exponent `[b, p] => b*(10**p)`.\n        scale: [1, -7],\n\n        // One option in these arrays chosen by Euler/Verlet, respectively.\n\n        // The motion particles respawn with.\n        spout: [3e3, 2e2],\n        // Drag coefficient.\n        // drag: [range(3, 1e-3), range(3, 1e-1)]\n    },\n    bound, steps, scale, maps: { values, derives },\n    // Data type according to support.\n    type: ((extend.float.every(regl.hasExtension))? 'float' : 'half float'),\n    // Per-shader macro hooks, no macros needed for the `vert` shader.\n    macros: { vert: false },\n    step: {\n        // Per-pass macros will prepend to `frag` shader and cache in `frags`.\n        frag: stepFrag, frags: [],\n        uniforms: {\n            dt: (_, { props: { timer: { dt }, rate: r } }) => dt*r,\n            dt0: (_, { props: { timer: { dts: { 0: dt } }, rate: r } }) => dt*r,\n            dt1: (_, { props: { timer: { dts: { 1: dt } }, rate: r } }) => dt*r,\n            time: (_, { props: { timer: { time: t }, rate: r } }) => t*r,\n\n            loop: (_, { props: { timer: { time: t }, loop: l } }) =>\n                Math.sin(t/l*Math.PI)*l,\n\n            lifetime: regl.prop('props.lifetime'),\n            useVerlet: (_, { props: { useVerlet: u } }) => +u,\n            g: regl.prop('props.g'),\n            source: regl.prop('props.source'),\n            // For numeric accuracy, encoded as exponent `[b, e] => b*(10**e)`.\n            scale: regl.prop('props.scale'),\n\n            // One option in these arrays chosen by Euler/Verlet, respectively.\n            spout: (_, { props: { spout: ss, useVerlet: u } }) => ss[+u],\n            // drag: (_, { props: { drag: ds, useVerlet: u } }) => ds[+u]\n        }\n    }\n});\n\nconsole.log(self.state = state);\n\nconsole.group('How `values` are `packed` to fit texture channels efficiently');\nconsole.log(state.maps.values, '`values` (referred to by index)');\nconsole.log(state.maps.packed, '`packed` (`values` indexes)');\nconsole.log(...state.maps.textures, '`textures` (`values` indexes)');\nconsole.log(state.maps.valueToTexture, '`valueToTexture` (`textures` indexes)');\nconsole.groupEnd();\n\n// Set up rendering.\n\n// Draw count; note `state.size.count` here equals `countDrawIndexes`.\nconst drawCount = state.size.count*((usePoints)? steps : indexPairs(steps));\nconst drawIndexes = getDrawIndexes(drawCount);\n\nconst drawState = {\n    ...state,\n    drawProps: {\n        // Speed-to-colour scaling, as `[multiply, power]`.\n        // One option in these arrays chosen by Euler/Verlet, respectively.\n        pace: [[1e-3, 0.6], [3e2, 0.6]]\n    },\n    // @todo Draw all states with none bound as outputs - currently errors.\n    // bound: 0,\n    // Drawing, don't need to output any data; also don't need `frag` macros.\n    macros: { 'output': 0, 'frag': 0 },\n    // Everything mapped the same way.\n    maps: getMaps({\n        ...state.maps,\n        // This one pass can bind textures for input; not output across passes.\n        texturesMax: maxTextureUnits,\n        /**\n         * One set of reads of all values in one pass.\n         * Passing `true` adds all values at that level of nesting:\n         * `pass|[values|[value|[step, value]]]`\n         * Thus, this example means that the _first_ value derives from:\n         * - All values 1 step past (`true`).\n         * - The position value 2 steps past.\n         * Makes `reads_0_i` macros for each `i => [step, value]` of\n         * `[[0, 0], [0, 1], [0, 2], [1, 0]]`\n         */\n        derives: [[true, [clamp(1, 0, stepsPast-1), valuesIndex.position]]]\n    })\n};\n\nconst drawWidth = 2**3;\n\nconst drawCommand = {\n    // Use GPGPU macro mappings by prepending macros from a single pass.\n    vert: macroPass(drawState)+drawVert,\n    frag: drawFrag,\n    attributes: { index: drawIndexes },\n    // Hook up GPGPU uniforms by adding them here.\n    uniforms: getUniforms(drawState, {\n        ...drawState.step.uniforms,\n        scale: regl.prop('props.scale'),\n        pace: (_, { drawProps: { pace }, props: { useVerlet: u } }) => pace[+u],\n        pointSize: clamp(drawWidth, ...pointSizeDims)\n    }),\n    lineWidth: clamp(drawWidth, ...lineWidthDims),\n    count: drawCount,\n    depth: { enable: true },\n    blend: { enable: true, func: { src: 'one', dst: 'one minus src alpha' } },\n    primitive: ((usePoints || steps-drawState.bound < 2)? 'points' : 'lines')\n};\n\nconsole.log((self.drawState = drawState), (self.drawCommand = drawCommand));\n\nconst draw = regl(drawCommand);\n\nfunction stepTime(state) {\n    const { dts } = state;\n\n    dts[0] = dts[1];\n    dts[1] = timer(state).dt;\n\n    return state;\n}\n\nconst clearView = { color: [0, 0, 0, 0], depth: 1 };\n\nregl.frame(() => {\n    stepTime(state.props.timer);\n    state.step.run();\n    drawState.stepNow = state.stepNow;\n    regl.clear(clearView);\n    draw(drawState);\n});\n\n// Toggle Verlet integration, if there are enough past steps.\ncanvas.addEventListener('click', () =>\n    console.log('useVerlet',\n        (state.props.useVerlet = (canVerlet && !state.props.useVerlet))));\n\ncanvas.addEventListener('touchmove', (e) => {\n    e.stopPropagation();\n    e.preventDefault();\n});\n\ncanvas.addEventListener((('onpointermove' in self)? 'pointermove'\n        :   (('ontouchmove' in self)? 'touchmove' : 'mousemove')),\n    (e) => {\n        const { clientX: x, clientY: y } = e;\n        const { source } = state.props;\n        const size = Math.min(innerWidth, innerHeight);\n\n        source[0] = ((((x-((innerWidth-size)*0.5))/size)*2)-1);\n        source[1] = -((((y-((innerHeight-size)*0.5))/size)*2)-1);\n\n        e.stopPropagation();\n        e.preventDefault();\n    });\n\nmodule?.hot?.accept?.(() => location.reload());\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n","import defineProperty from './_define_property';\n\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import arrayWithHoles from './_array_with_holes';\nimport iterableToArrayLimit from './_iterable_to_array';\nimport nonIterableRest from './_non_iterable_rest';\n\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n","import arrayWithoutHoles from './_array_without_holes';\nimport iterableToArray from './_iterable_to_array';\nimport nonIterableSpread from './_non_iterable_spread';\n\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n","export default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n","module.exports = clamp\n\nfunction clamp(value, min, max) {\n  return min < max\n    ? (value < min ? min : value > max ? max : value)\n    : (value < max ? max : value > min ? min : value)\n}\n","/**\n * Simple time-stepping - frame, real-time, constant-step - via any API.\n */\n\nexport const steps = {\n    diff: '-', dt: '-', '⏳': '-',\n    pause: 0, '⏸': 0,\n    add: '+', '⏭': '+'\n};\n\nexport const stepDef = steps.diff;\nexport const startDef = 0;\nexport const nowDef = { [steps.diff]: Date.now, [steps.add]: 1e3/60 };\n\n/**\n * Sets up properties needed to track time, starts/steps time in various ways:\n * - Time-difference or time-advance stepping.\n * - Step forwards or backwards in time or pause it.\n * - Current time can be a number or function; or the object's fixed time-step.\n * - Override property, pass the result to new objects.\n *\n * @example\n *     // Initial call sets up properties.\n *     const diff0 = timer({ step: '-' }, 200);\n *     // => { step: '-', time: 200, dt: 200 };\n *     const add0 = timer({ step: 200 });\n *     // => { step: 200, time: 200, dt: 200 };\n *\n *     // Subsequent calls advance time and track difference.\n *\n *     // No time difference here.\n *     timer(diff0, 200); // => { step: '-', time: 200, dt: 0 };\n *     timer(add0, 0); // => { step: 200, time: 200, dt: 0 };\n *\n *     // Time-difference here with a change or step, into a new result target.\n *     const diff1 = timer(diff0, 300, {});\n *     // => { step: '-', time: 300, dt: 100 };\n *     const add1 = timer(add0, null, {});\n *     // => { step: 200, time: 400, dt: 200 };\n *\n *     diff1.time-diff0.time === diff1.dt; // => true;\n *     add1.time-add0.time === add1.dt; // => true;\n *\n * @param {object} state The state being tracked.\n * @param {number} [state.time=startDef] The initial time.\n * @param {string|number} [state.step=stepDef] How time advances:\n *     - Difference since last `time`: `'diff'`/`'dt'`/`'-'`/`'⏳'`.\n *     - Pause: `'pause'`/`'⏸'`, or number zero (`0`).\n *     - Add `time` step: `'add'`/`'+'`/`'⏭'`, or non-zero number (step size).\n * @param {number|function} [now] The time now (clock/frame/step/etc), or a\n *     function giving it; if not given, uses `state.step` if numeric or\n *     `nowDef[state.step]` otherwise.\n * @param {object|false} [out=state] The state to set up; modifies `state` if\n *     not given.\n *\n * @returns {object|number} The given `out` set up with its initial `time`; or\n *     if `out` is falsey, returns the relevant calculated unknown value:\n *     - The difference since last `time` for `diff` step.\n *     - The updated `time` for `add` or `pause` step.\n */\nexport function timer(state, now, out = state) {\n    // Get the initial time and step-step.\n    const { time: t0 = startDef, step = stepDef, now: n } = state;\n    // Get the step mode - from a key into `steps` or a numerical value.\n    const s = (steps[step] ?? step);\n    const diff = (s === steps.diff);\n    const t = (now ?? n ?? nowDef[s] ?? s);\n\n    // Step by `s`:\n    // - `0` or falsey to `pause`\n    // - `steps.diff` for difference since last `time`\n    // - `steps.add` or a number to add a `time` step\n    const t1 = ((!s)? t0 : ((diff)? 0 : t0)+((isNaN(t))? t() : t));\n    const dt = t1-t0;\n\n    // If only returning a value, return the relevant calculated unknown.\n    if(!out) { return ((diff)? dt : t1); }\n\n    out.time = t1;\n    out.dt = dt;\n    out.step = step;\n\n    return out;\n}\n\nexport default timer;\n","const r = Array.prototype.reduce;\n\n/**\n * Reduce an array-like list.\n * Similar to native, but with iteratee-first arguments.\n * Supports the native single-argument behaviour.\n *\n * @param {function} f The iteratee function, given standard arguments, and any\n *     given `to`.\n * @param {array} a The list to reduce over (array or array-like list).\n * @param {*} [to] The initial accumulator, if given; otherwise, uses standard\n *     `Array.reduce` behaviour.\n *\n * @returns {*} The result of running the reducer iteratee function over all\n *     elements of the list.\n */\nexport const reduce = (f, a, to) =>\n    // Needs separate `call` because native detects even `undefined` parameter.\n    ((to === undefined)? r.call(a, f) : r.call(a, f, to));\n\nexport default reduce;\n","import { reduce } from './reduce';\n\n/**\n * Map an array-like list.\n * Similar to native, but with iteratee-first arguments; and allows the object\n * into which properties will be mapped to be defined (a new array, by default),\n * avoiding always creating new arrays.\n *\n * @param {function} f The iteratee function, given standard `Array.map`\n *     arguments, and any given `to`.\n * @param {array} a The list to map over (array or array-like list).\n * @param {*} [to=[]] The initial accumulator, if given; `a` if falsey; or a new\n *     array if not given.\n *\n * @returns {*} The result of mapping `to` through the iteratee function over\n *     the `a` list.\n */\nexport const map = (f, a, to = []) => reduce((to, v, i) => {\n        to[i] = f(v, i, a, to);\n\n        return to;\n    },\n    a, (to || a));\n\nexport default map;\n","const e = Array.prototype.forEach;\n\n/**\n * Iterates a function over every element of a list, returning the list.\n *\n * @param {function} f The iteratee function.\n * @param {array} a A list to iterate over (array or array-like object).\n *\n * @returns {array} The given list.\n */\nexport const each = (f, a) => {\n    e.call(a, f);\n\n    return a;\n}\n\nexport default each;\n","/**\n * Creates an iterable array of the given length of empty entries, or those\n * given by optional arguments to `Array.fill`.\n *\n * @see Array.constructor\n * @see Array.fill\n *\n * @param {number} n The number of elements to create.\n * @param {*} [value] A value to fill the array with; for `Array.fill`.\n * @param {number} [start=0] Start index, inclusive; for `Array.fill`.\n * @param {number} [end=n] End index, exclusive; for `Array.fill`.\n *\n * @returns {array} An array of the given number of empty elements.\n */\nexport const range = (n, value, start, end) =>\n    Array(Math.floor(n)).fill(value, start, end);\n\nexport default range;\n","/**\n * GPGPU state-stepping: maps minimal draw passes, shaders, GL resources,\n * inputs, outputs. BYORenderer.\n *\n * Rendering approach/engine specific, decoupled from the logic code.\n * The modules and many hooks may be used as given, or piecemeal, or overridden.\n *\n * @todo Fix GLSL3/D3D error \"sampler array index must be a literal expression\".\n *     See info in `macroSamples` in `macros.js`.\n * @todo Allow passes within/across textures; separate data and texture shapes.\n */\n\nimport { getMaps } from './maps';\nimport { getState } from './state';\nimport { getStep } from './step';\n\nexport * from './const';\n\n/**\n * Sets up all the maps, inputs, resources, etc for a GPGPU process.\n *\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [mapSamples]{@link ./maps.js#mapSamples}\n * @see [getState]{@link ./step.js#getState}\n * @see [getUniforms]{@link ./step.js#getUniforms}\n * @see [getStep]{@link ./step.js#getStep}\n * @see [macroPass]{@link ./macros.js#macroPass}\n *\n * @param {object} api An API for GL resources. See `getState` and `getStep`.\n * @param {object} [api.limits=api] A map of GL resource limits.\n * @param {number} [api.limits.maxDrawbuffers] The maximum number of GL textures\n *     a framebuffer can bind in a single draw call.\n * @param {object} [state={}] State properties to set up; a new object by\n *     default. See `getState`, `getUniforms`, and `getStep`.\n * @param {object} [state.maps] How values are grouped per-texture per-pass\n *     per-step. Sets up new maps if not given or missing its mapped properties.\n *     See `mapGroups`.\n * @param {number} [state.maps.texturesMax=api.limits.maxDrawbuffers] The\n *     maximum number of textures to use per draw pass. Uses more passes above\n *     this limit.\n * @param {object} [to=state] The state object to set up. Modifies the given\n *     `state` object by default.\n */\nexport function gpgpu(api, state = {}, to = state) {\n    const { maxDrawbuffers: texturesMax, glsl } = (api.limits ?? api);\n    const { maps = {} } = state;\n\n    to.glsl = parseFloat(glsl.match(/[0-9\\.]+/)[0]);\n    maps.texturesMax ??= texturesMax;\n    to.maps = getMaps(maps);\n    getState(api, state, to).step = getStep(api, state);\n\n    return to;\n}\n\nexport default gpgpu;\n","/**\n * GPGPU mappings for step/draw shaders input/output.\n *\n * These maps show shaders how to make use of a system's supported features, how\n * to pack/unpack their data from framebuffers/textures, perform only minimal\n * needed samples to retrieve any past values they must derive from, etc.\n * Shaders may declare values they output, values they derive from, groupings of\n * in/dependent values - without handling how these concerns map to the\n * particular system resources they're using.\n * System limits/features/extensions are accounted for, to produce the most\n * efficient mappings available with the least I/O when it comes to drawing\n * (draw passes, texture samples, etc).\n *\n * @todo Allow passes within/across textures; separate data and texture shapes.\n */\n\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport each from '@epok.tech/fn-lists/each';\n\nimport { valuesDef, channelsMaxDef, texturesMaxDef } from './const';\n\nexport const cache = { packed: [] };\n\nexport const validValue = (value, channelsMax = channelsMaxDef) =>\n    ((1 <= value) || (value <= channelsMax) ||\n        !!console.error(`\\`gl-gpgpu\\`: the given value (${value}) exceeds the `+\n            `range of channels available, \\`[1, ${channelsMax}]\\` inclusive.`,\n            value, channelsMax));\n\n/**\n * Minimise resource usage, order `values` to pack into blocks of `channelsMax`;\n * interpreted as indexes into the given `values`.\n *\n * @example\n *     packValues([1, 2, 3], 4, []); // =>\n *     [2, 0, 1];\n *\n *     packValues([3, 2, 1], 4, []); // =>\n *     [0, 2, 1];\n *\n *     packValues([4, 3, 2], 4, []); // =>\n *     [0, 1, 2];\n *\n *     packValues([1, 1, 4, 2], 4, []); // =>\n *     [2, 3, 0, 1];\n *\n * @see mapGroups\n *\n * @param {array<number>} values Each entry is how many interdependent channels\n *     are grouped into one texture in one pass, separate entries may be across\n *     one or more textures/passes. See `mapGroups`.\n * @param {number} [channelsMax=channelsMaxDef] The maximum number of channels\n *     per texture. See `mapGroups`.\n * @param {array} [to=[]] An array to store the result; a new array by default.\n *\n * @returns {array<number>} `to` The indexes of the given `values`, reordered\n *     to pack into the fewest buckets of `channelsMax` size or less; stored in\n *     the given `to` array.\n */\nexport function packValues(values, channelsMax = channelsMaxDef, to = []) {\n    map((_, i) => i, values, to).length = values.length;\n\n    // Counts the number of empty channels in the current group.\n    let channels = channelsMax;\n    // How many values have already been packed.\n    let packed = 0;\n    // Tracks the value that best fits the free channels (fills it tightest).\n    let fitIndex = 0;\n    let fitSize = Infinity;\n\n    for(let i = 0; packed < values.length;) {\n        const v = packed+i;\n        const value = values[to[v]];\n\n        if(!validValue(value, channelsMax)) { return to; }\n\n        // Check how value fits the channels - valid is >= 0, perfect is 0.\n        const fit = channels-value;\n\n        if((fit >= 0) && (fit < fitSize)) {\n            fitSize = fit;\n            fitIndex = v;\n        }\n\n        // Not a perfect fit and can keep searching for better fits - continue.\n        if((fitSize !== 0) && (v < values.length-1)) { ++i; }\n        else {\n            // Got a perfect fit or the search ended - swap in best fit value.\n            const pack = to[fitIndex];\n\n            to[fitIndex] = to[packed];\n            to[packed] = pack;\n\n            // Reduce the free channels by the best value, reset if needed.\n            (((channels -= values[pack]) > 0) || (channels = channelsMax));\n            // Start the search again over the remaining unpacked entries.\n            fitIndex = ++packed;\n            fitSize = Infinity;\n            i = 0;\n        }\n    }\n\n    return to;\n}\n\n/**\n * Groups the `values` of GPGPU data items across draw passes and data textures.\n *\n * @example\n *     const x = 2;\n *     const y = 4;\n *     const z = 1;\n *     const maps = { values: [x, y, z], channelsMax: 4 };\n *\n *     // No optimisations - values not packed, single texture output per pass.\n *     mapGroups({ ...maps, texturesMax: 1, packed: false }); // =>\n *     {\n *         ...maps, packed: false,\n *         textures: [[0], [1], [2]], // length === 3\n *         passes: [[0], [1], [2]], // length === 3\n *         valueToTexture: [0, 1, 2], valueToPass: [0, 1, 2],\n *         textureToPass: [0, 1, 2]\n *     };\n *\n *     // Automatically packed values - values across fewer textures/passes.\n *     mapGroups({ ...maps, texturesMax: 1 }); // =>\n *     {\n *         ...maps, packed: [1, 0, 2],\n *         textures: [[1], [0, 2]], // length === 2\n *         passes: [[0], [1]], // length === 2\n *         valueToTexture: [1, 0, 1], valueToPass: [1, 0, 1],\n *         textureToPass: [0, 1]\n *     };\n *\n *     // Can bind more texture outputs per pass - values across fewer passes.\n *     mapGroups({ ...maps, texturesMax: 4 }); // =>\n *     {\n *         ...maps, packed: [1, 0, 2],\n *         textures: [[1], [0, 2]], // length === 2\n *         passes: [[0, 1]], // length === 1\n *         valueToTexture: [1, 0, 1], valueToPass: [0, 0, 0],\n *         textureToPass: [0, 0]\n *     };\n *\n *     // Custom packed values - fuller control.\n *     mapGroups({ ...maps, texturesMax: 4, packed: [0, 2, 1] }); // =>\n *     {\n *         ...maps, packed: [0, 2, 1],\n *         textures: [[0, 2], [1]], // length === 2\n *         passes: [[0, 1]], // length === 1\n *         valueToTexture: [0, 1, 0], valueToPass: [0, 0, 0],\n *         textureToPass: [0, 0]\n *     };\n *\n *     // Merge dependent values - fuller control, but no map for merged values.\n *     mapGroups({ ...maps, values: [x+z, y], texturesMax: 4 }); // =>\n *     {\n *         ...maps, packed: [1, 0],\n *         textures: [[1], [0]], // length === 2\n *         passes: [[0, 1]], // length === 1\n *         valueToTexture: [1, 0], valueToPass: [0, 0],\n *         textureToPass: [0, 0]\n *     };\n *\n * @see packValues\n *\n * @param {object} [maps={}] Maps and initial settings; new object if not given.\n * @param {array<number>} [maps.values=valuesDef()] An array where each number\n *     denotes how many value channels are grouped into one data texture in one\n *     draw pass (where any value map logic isn't handled here); each separate\n *     number may be computed across one or more data textures/passes.\n *     Each value denotes the number of dependent channels to compute together;\n *     separate values denote channels that are independent, and may be drawn in\n *     the same or separate passes, depending on settings/support.\n *     The order may affect the number of passes/textures needed; can maintain\n *     order as-is, or use a more efficient `packed` order. See `packValues`.\n * @param {number} [maps.channelsMax=channelsMaxDef] Maximum channels per\n *     texture.\n * @param {number} [maps.texturesMax=texturesMaxDef] Maximum textures bound per\n *     pass.\n * @param {array<number>|false} [maps.packed] An array of indexes into `values`\n *     packed into an order that best fits into blocks of `channelsMax` to\n *     minimise resources; or false-y to use `values` in their given order;\n *     uses `packValues` if not given.\n * @param {object} [to=maps] An object to contain the results; modifies `maps`\n *     if not given.\n *\n * @returns {object} `to` The given `to` object; how `values` are grouped\n *     per-texture per-pass per-step, meta information, and given parameters.\n * @returns {array<array<number>>} `to.passes` Textures grouped into passes, as\n *     arrays corresponding to framebuffers in separate draw passes; whose\n *     values are indexes into `to.textures`.\n * @returns {array<array<number>>} `to.textures` Values grouped into\n *     textures, as arrays corresponding to framebuffer attachments, into which\n *     `values` are drawn; whose values are indexes into `to.values`.\n * @returns {array<number>} `to.values` The `values`, as given.\n * @returns {number} `to.texturesMax` The max textures per pass, as given.\n * @returns {number} `to.channelsMax` The max channels per texture, as given.\n * @returns {array<number>} `to.valueToTexture` Inverse map from each index of\n *     `to.values` to the index of the data texture containing it.\n * @returns {array<number>} `to.valueToPass` Inverse map from each index of\n *     `to.values` to the index of the pass containing it.\n * @returns {array<number>} `to.textureToPass` Inverse map from each index of\n *     `to.textures` to the index of the pass containing it.\n */\nexport function mapGroups(maps = {}, to = maps) {\n    if(!maps) { return to; }\n\n    const {\n            values = valuesDef(),\n            channelsMax = channelsMaxDef, texturesMax = texturesMaxDef,\n            // Pack `values` into blocks of `channelsMax` to minimise resources.\n            packed = packValues(values, channelsMax, cache.packed)\n        } = maps;\n\n    to.values = values;\n    to.texturesMax = texturesMax;\n    to.channelsMax = channelsMax;\n    to.packed = packed;\n\n    const passes = to.passes = [[]];\n    const textures = to.textures = [[]];\n    const valueToTexture = to.valueToTexture = [];\n    const valueToPass = to.valueToPass = [];\n    const textureToPass = to.textureToPass = [];\n    // Counts the number of channels written in a single draw pass.\n    let channels = 0;\n    // Get the value, via `packed` if valid, or directly as given in `values`.\n    const getValue = ((packed)? ((_, i) => values[i]) : ((v) => v));\n    const getIndex = ((packed)? ((i) => packed[i]) : ((i) => i));\n\n    return reduce((to, v, i) => {\n            const index = getIndex(i);\n            const value = getValue(v, index);\n\n            if(!validValue(value, channelsMax)) { return to; }\n\n            let p = passes.length-1;\n            let pass = passes[p];\n            let t = textures.length-1;\n            let texture = textures[t];\n\n            if((channels += value) > channelsMax) {\n                channels = value;\n                t = textures.push(texture = [])-1;\n\n                ((pass.length >= texturesMax) &&\n                    (p = passes.push(pass = [])-1));\n\n                pass.push(t);\n                textureToPass.push(p);\n            }\n            else if(pass.length === 0) {\n                pass.push(t);\n                textureToPass.push(p);\n            }\n\n            texture.push(index);\n            valueToTexture[index] = t;\n            valueToPass[index] = p;\n\n            return to;\n        },\n        values, to);\n}\n\n/**\n * Maps the minimal set of texture reads to derive the next state of values from\n * a past state of values they depend upon.\n *\n * @example\n *     const maps = mapGroups({\n *         // See `mapGroups` examples for resulting maps.\n *         values: [2, 4, 1], channelsMax: 4, texturesMax: 1, packed: false,\n *         // Derived step/value indexes, per-value; sample entries include:\n *         derives: [\n *             // Single...\n *             2,\n *             // Empty...\n *             ,\n *             // Multiple...\n *             [\n *                 // Defined step...\n *                 [1, 0],\n *                 // All values at any given level/step...\n *                 true\n *             ]\n *         ]\n *     });\n *\n *     mapSamples(maps); // =>\n *     {\n *         ...maps,\n *         // Minimum texture samples for values; nested per-pass, per-value.\n *         // Deepest arrays are step/texture index pairs into `maps.textures`.\n *         samples: [\n *             [[0, 2]],\n *             null,\n *             [[1, 0], [0, 0], [0, 1], [0, 2]]\n *         ],\n *         // Value indexes into `to.samples`; nested per-pass, per-value.\n *         // Map from a value index to data it needs in the minimal samples.\n *         reads: [\n *             [[0]],\n *             null,\n *             [null, null, [0, 1, 2, 3]]\n *         ]\n *     };\n *\n * @see mapGroups\n *\n * @param {object} maps How values are grouped per-texture, per-pass, per-step.\n *     See `mapGroups`.\n * @param {true|array<null,true,number,array<true,number,array<true,number>>>}\n *     [maps.derives] How values derive from others.\n *     If given as an array, each entry relates the corresponding value to\n *     any past value steps/indexes it derives from - a value not derived from\n *     past values may have an empty/null entry; a value derives from past\n *     values where its entry has:\n *     - Numbers; deriving from the most recent state at the given value index.\n *     - Lists of numbers; deriving from the given past state index (1st number\n *         denotes how many steps ago), at the given value index (2nd number).\n *     The nested hierarchy is thus `pass|[values|[value|[step, value]]]`.\n *     If any level is given as `true`, maps to sample all values, at the given\n *     step (or most recent step, if none given).\n *     If no `derives` given, no samples are mapped, `to` is returned unchanged.\n * @param {array<array<number>>} maps.passes Textures grouped into passes. See\n *     `mapGroups`.\n * @param {array<array<number>>} maps.textures Values grouped into textures. See\n *     `mapGroups`.\n * @param {array<number>} maps.valueToTexture Inverse map from each value index\n *     to the data texture index containing it.\n * @param {object} [to=maps] The object to store the result in; `maps` if not\n *     given.\n *\n * @returns {object} `to` The given `to` object, with resulting maps added for\n *     any given `maps.derives`.\n * @returns {array<array<array<number>>>} `[to.samples]` Map of the minimum\n *     set of indexes into `maps.textures` that need to be sampled per-pass,\n *     to get all `derives` needed for each value of `maps.values` of each\n *     pass of `maps.passes`.\n * @returns {array<array<null,array<number>>>} `[to.reads]` Sparse map from\n *     each value of `derives` to its step and texture indexes in `to.samples`.\n * @returns {true|array<null,true,number,array<true,number,array<true,number>>>}\n *     `[to.derives]` How values are derived, as given.\n */\nexport function mapSamples(maps, to = maps) {\n    const derives = maps?.derives;\n\n    if(!derives) { return to; }\n\n    const { passes, textures, valueToTexture } = maps;\n    const reads = to.reads = [];\n    const cache = {};\n\n    to.derives = derives;\n\n    const all = (step = 0) =>\n        cache[step] ??= map((t, v) => [step, v], valueToTexture);\n\n    const getAddSample = (pass, value) => function add(set, derive, d) {\n        let step = 0;\n        let texture;\n\n        if(derive === true) { return reduce(add, all(step), set); }\n        else if(Number.isFinite(derive)) { texture = valueToTexture[derive]; }\n        else if(derive[1] === true) { return reduce(add, all(derive[0]), set); }\n        else {\n            step = derive[0];\n            texture = valueToTexture[derive[1]];\n        }\n\n        if(!Number.isFinite(step) || !Number.isFinite(texture)) {\n            return console.error('`mapSamples`: invalid map for sample',\n                derives, maps, pass, value, derive, d, step, texture);\n        }\n\n        // Create the set if not already created.\n        const to = (set || []);\n        // Check for any existing matching step/texture read in the set.\n        const i = to.findIndex(([s, t]) => (s === step) && (t === texture));\n\n        // Add the read for this value in this pass; creating any needed maps.\n        ((reads[pass] ??= [])[value] ??= [])\n            // A new read as needed, or any existing matching read.\n            .push((i < 0)? to.push([step, texture])-1 : i);\n\n        return to;\n    };\n\n    const getAddSamples = (pass) => (set, value) => {\n        const valueDerives = ((derives === true)? derives : derives[value]);\n\n        return ((!valueDerives && (valueDerives !== 0))? set\n            : (((valueDerives === true) || Number.isFinite(valueDerives))?\n                    getAddSample(pass, value)(set, valueDerives)\n                :   reduce(getAddSample(pass, value), valueDerives, set)));\n    }\n\n    to.samples = map((pass, p) => reduce((set, texture) =>\n                reduce(getAddSamples(p), textures[texture], set),\n            pass, null),\n        passes, []);\n\n    return to;\n}\n\n/**\n * Main function, creates maps for a given set of values and settings, as well\n * as maps for minimal samples and reads if new values derive from past ones.\n *\n * @see mapGroups\n * @see mapSamples\n *\n * @param {object} [maps] Maps and initial settings.\n * @param {object} [to=maps] An object to contain the results; modifies `maps`\n *     if not given.\n *\n * @returns {object} `to` The given `to` object; how `values` are grouped\n *     per-texture per-pass per-step, meta information, and given parameters;\n *     and minimal samples and reads for any given `maps.derives`.\n */\nexport const getMaps = (maps, to = maps) =>\n    mapSamples(maps, mapGroups(maps, to));\n\nexport default getMaps;\n","/**\n * Default properties for GPGPU and GL capabilities and resources.\n */\n\nimport { positions } from '@epok.tech/gl-screen-triangle';\n\n/** Default vertex shader. */\nexport { default as vertDef } from './index.vert.glsl';\n\n// The required and optional GL extensions for a GPGPU state.\n\n/** Default required extensions; none. */\nexport const extensions = () => [];\n\n/** Default required extensions to draw to `float` buffers. */\nexport const extensionsFloat = () =>\n    ['oes_texture_float', 'webgl_color_buffer_float'];\n\n/** Default required extensions to draw to `half float` buffers. */\nexport const extensionsHalfFloat = () =>\n    ['oes_texture_half_float', 'ext_color_buffer_half_float'];\n\n/** Default optional extensions; update more data in one render pass. */\nexport const optionalExtensions = () => ['webgl_draw_buffers'];\n\n/** Prefix namespace to avoid naming clashes. */\nexport const preDef = '';\n\n/**\n * The allowable range of channels for framebuffer attachments.\n * Default avoids `RGB32F` framebuffer attachments, which errors on\n * Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1448632\n */\nexport const channelsMinDef = 4;\nexport const channelsMaxDef = 4;\n\nexport const texturesMaxDef = 1;\nexport const boundDef = 1;\nexport const scaleDef = 10;\nexport const stepsDef = 2;\nexport const valuesDef = () => [channelsMaxDef];\nexport const positionsDef = () => [...positions];\n\n// Resource format defaults.\n\n/** Default texture data type. */\nexport const typeDef = 'float';\n/** Default texture minification filter. */\nexport const minDef = 'nearest';\n/** Default texture magnification filter. */\nexport const magDef = 'nearest';\n/** Default texture wrap mode. */\nexport const wrapDef = 'clamp';\n/** Default framebuffer depth attachment. */\nexport const depthDef = false;\n/** Default framebuffer stencil attachment. */\nexport const stencilDef = false;\n","/**\n * The 3 vertices of a 2D triangle covering the viewport in NDC coordinates ([-1, 1]).\n *\n * @export\n * @type {array.<array.<number>>}\n */\nexport const vertices = [[-1, -1], [-1, 4], [4, -1]];\n\nexport const count = vertices.length;\nexport const dim = 2;\n\n/**\n * The flat array of the above triangle, to be bound as a WebGL attribute buffer for\n * rendering the triangle in the vertex shader.\n * These positions will result in clipped NDC coordinates ([-1, 1]) over the\n * viewport's width and height.\n *\n * @export\n * @type {array.<number>}\n */\nexport const positions = vertices.flat();\n\nexport default positions;\n","/**\n * Default GPGPU vertex shader.\n *\n * @see @epok.tech/gl-screen-triangle/uv-texture.vert.glsl\n */\n\nprecision highp float;\n\nattribute vec2 position;\n\nuniform vec2 dataShape;\n\nvarying vec2 uv;\n\n#pragma glslify: offsetUV = require(./sample/offset-uv)\n\nvoid main() {\n    // Transform UV NDC to texture coordinates.\n    // Offset UV to sample at the texel center and avoid errors.\n    uv = offsetUV((position*0.5)+0.5, dataShape);\n    gl_Position = vec4(position, 0, 1);\n}\n","/**\n * GPGPU state and GL resources: framebuffers, textures; and meta information.\n *\n * @todo Allow passes into or across textures; separate data and texture shapes.\n * @todo In-place updates of complex resources and meta info.\n * @todo Use transform feedback instead of data textures, if supported (WebGL2)?\n */\n\nimport range from '@epok.tech/fn-lists/range';\nimport map from '@epok.tech/fn-lists/map';\nimport reduce from '@epok.tech/fn-lists/reduce';\n\nimport {\n        scaleDef, stepsDef, valuesDef, channelsMinDef,\n        typeDef, minDef, magDef, wrapDef, depthDef, stencilDef\n    } from './const';\n\n/**\n * Set up the GPGPU resources and meta information for a state of a number data.\n *\n * @todo Transform feedback.\n * @todo Reorder the given `values` into the most efficient `maps`?\n *\n * @example\n *     const api = {\n *         framebuffer: ({ depth, stencil, width, height, color }) => null,\n *         texture: ({ type, min, mag, wrap, width, height, channels }) => null\n *     };\n *\n *     // Example with `webgl_draw_buffers` extension support, for 4 buffers.\n *     let maps = mapGroups({ values: [1, 2, 3], texturesMax: 4, packed: 0 });\n *     let state = { steps: 2, side: 10, maps };\n *\n *     const s0 = getState(api, state, {}); // =>\n *     {\n *         ...state, passNow: undefined, stepNow: undefined,\n *         size: {\n *             steps: 2, passes: 2, textures: 4,\n *             width: 10, height: 10, shape: [10, 10], count: 100\n *         },\n *         steps: [\n *             [s0.passes[0][0].framebuffer], [s0.passes[1][0].framebuffer]\n *         ],\n *         // This setup results in fewer passes, as more buffers can be bound.\n *         passes: [\n *             [\n *                 {\n *                     framebuffer: api.framebuffer(s0.passes[0][0]),\n *                     color: [\n *                         s0.textures[0][0].texture, s0.textures[0][1].texture\n *                     ],\n *                     map: [0, 1], // maps.passes[0]\n *                     entry: 0, index: 0, step: 0,\n *                     depth: false, stencil: false, width: 10, height: 10\n *                 }\n *             ],\n *             [\n *                 {\n *                     framebuffer: api.framebuffer(s0.passes[1][0]),\n *                     color: [\n *                         s0.textures[1][0].texture, s0.textures[1][1].texture\n *                     ],\n *                     map: [0, 1], // maps.passes[0]\n *                     entry: 1, index: 0, step: 1,\n *                     depth: false, stencil: false, width: 10, height: 10\n *                 }\n *             ]\n *         ],\n *         textures: [\n *             [\n *                 {\n *                     texture: api.texture(s0.textures[0][0]),\n *                     map: [0, 1], // maps.textures[0]\n *                     entry: 0, index: 0, step: 0, pass: 0,\n *                     type: 'float', width: 10, height: 10, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 },\n *                 {\n *                     texture: api.texture(s0.textures[0][1]),\n *                     map: [2], // maps.textures[1]\n *                     entry: 1, index: 1, step: 0, pass: 0,\n *                     type: 'float', width: 10, height: 10, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 }\n *             ],\n *             [\n *                 {\n *                     texture: api.texture(s0.textures[1][0]),\n *                     map: [0, 1], // maps.textures[0]\n *                     entry: 2, index: 0, step: 1, pass: 0,\n *                     type: 'float', width: 10, height: 10, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 },\n *                 {\n *                     texture: api.texture(s0.textures[1][1]),\n *                     map: [2], // maps.textures[1]\n *                     entry: 3, index: 1, step: 1, pass: 0,\n *                     type: 'float', width: 10, height: 10, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 }\n *             ]\n *         ]\n *     };\n *\n *     // Example with no `webgl_draw_buffers` extension support, only 1 buffer.\n *     maps = mapGroups({ values: [1, 2, 3], texturesMax: 1, packed: 0 });\n *     state = { type: 'uint8', steps: 2, scale: 5, maps, stepNow: 1 };\n *\n *     const s1 = getState(api, state, {}); // =>\n *     {\n *         ...state, passNow: undefined, stepNow: 1,\n *         size: {\n *             steps: 2, passes: 4, textures: 4,\n *             width: 32, height: 32, shape: [32, 32], count: 1024\n *         },\n *         steps: [\n *             [s1.passes[0][0].framebuffer, s1.passes[0][1].framebuffer],\n *             [s1.passes[1][0].framebuffer, s1.passes[1][1].framebuffer]\n *         ],\n *         // This setup results in more passes, as fewer buffers can be bound.\n *         passes: [\n *             [\n *                 {\n *                     framebuffer: api.framebuffer(s1.passes[0][0]),\n *                     color: [s1.textures[0][0].texture],\n *                     map: [0], // maps.passes[0]\n *                     entry: 0, index: 0, step: 0,\n *                     depth: false, stencil: false, width: 32, height: 32\n *                 },\n *                 {\n *                     framebuffer: api.framebuffer(s1.passes[0][1]),\n *                     color: [s1.textures[0][1].texture],\n *                     map: [1], // maps.passes[1]\n *                     entry: 1, index: 1, step: 0,\n *                     depth: false, stencil: false, width: 32, height: 32\n *                 }\n *             ],\n *             [\n *                 {\n *                     framebuffer: api.framebuffer(s1.passes[1][0]),\n *                     color: [s1.textures[1][0].texture],\n *                     map: [0], // maps.passes[0]\n *                     entry: 2, index: 0, step: 1,\n *                     depth: false, stencil: false, width: 32, height: 32\n *                 },\n *                 {\n *                     framebuffer: api.framebuffer(s1.passes[1][1]),\n *                     color: [s1.textures[1][1].texture],\n *                     map: [1], // maps.passes[1]\n *                     entry: 3, index: 1, step: 1,\n *                     depth: false, stencil: false, width: 32, height: 32\n *                 }\n *             ]\n *         ],\n *         textures: [\n *             [\n *                 {\n *                     texture: api.texture(s1.textures[0][0]),\n *                     map: [0, 1], // maps.textures[0]\n *                     entry: 0, index: 0, step: 0, pass: 0,\n *                     type: 'uint8', width: 32, height: 32, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 },\n *                 {\n *                     texture: api.texture(s1.textures[0][1]),\n *                     map: [2], // maps.textures[1]\n *                     entry: 1, index: 1, step: 0, pass: 1,\n *                     type: 'uint8', width: 32, height: 32, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 }\n *             ],\n *             [\n *                 {\n *                     texture: api.texture(s1.textures[1][0]),\n *                     map: [0, 1], // maps.textures[0]\n *                     entry: 2, index: 0, step: 1, pass: 0,\n *                     type: 'uint8', width: 32, height: 32, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 },\n *                 {\n *                     texture: api.texture(s1.textures[1][1]),\n *                     map: [2], // maps.textures[1]\n *                     entry: 3, index: 1, step: 1, pass: 1,\n *                     type: 'uint8', width: 32, height: 32, channels: 4,\n *                     min: 'nearest', mag: 'nearest', wrap: 'clamp'\n *                 }\n *             ]\n *         ]\n *     };\n *\n * @see texture\n * @see framebuffer\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [mapSamples]{@link ./maps.js#mapSamples}\n * @see [getStep]{@link ./step.js#getStep}\n * @see [macroPass]{@link ./macros.js#macroPass}\n *\n * @param {object} api The API for GL resources.\n * @param {texture} [api.texture] Function to create a GL texture.\n * @param {framebuffer} [api.framebuffer] Function to create a GL framebuffer.\n * @param {object} [state={}] The state parameters.\n * @param {number} [state.width] The width of the data textures to allocate;\n *     if given, supersedes `state.side` and `state.scale`.\n * @param {number} [state.height] The height of the data textures to allocate;\n *     if given, supersedes `state.side` and `state.scale`.\n * @param {number} [state.side] The length of both sides of the data textures\n *     to allocate; if given, supersedes `state.scale`.\n * @param {number} [state.scale=scaleDef] The length of the data textures sides\n *     to allocate; gives a square power-of-two texture raising 2 to this power.\n * @param {number|array} [state.steps=stepsDef] How many steps of state to\n *     track, or the list of states if already set up.\n * @param {object} [state.maps] How `state.maps.values` are grouped per-texture\n *     per-pass per-step. See `mapGroups`.\n * @param {array<number>} [state.maps.values=valuesDef()] How values of each\n *     data item may be grouped into textures across passes; set up here if not\n *     given. See `mapGroups`.\n * @param {number} [state.maps.channelsMin=channelsMinDef] The minimum allowed\n *     channels for framebuffer attachments; allocates unused channels as needed\n *     to reach this limit.\n * @param {number} [state.maps.textures] How values are grouped into textures.\n *     See `mapGroups`.\n * @param {number} [state.stepNow] The currently active state step, if any.\n * @param {number} [state.passNow] The currently active draw pass, if any.\n * @param {string} [state.type=typeDef] Texture data type.\n * @param {string} [state.min=minDef] Texture minification filter.\n * @param {string} [state.mag=magDef] Texture magnification filter.\n * @param {string} [state.wrap=wrapDef] Texture wrap mode.\n * @param {boolean|*} [state.depth=depthDef] Framebuffer depth attachment.\n * @param {boolean|*} [state.stencil=stencilDef] Framebuffer stencil attachment.\n * @param {object} [to=state] The state object to set up. Modifies the given\n *     `state` object by default.\n *\n * @returns {object} `to` The state object, set up with the data resources and\n *     meta information, for use with `getStep` and drawing:\n * @returns {object<number,array<number,array<number>>>} `to.maps` Any given\n *     `state.maps`. See `mapGroups`.\n * @returns {array<array<object<texture,string,number,array<number>>>>}\n *     `to.textures` Textures per step, as arrays of objects of `texture`s, and\n *     meta info. See `to.maps.textures`.\n * @returns {array<array<object<framebuffer,number,array<number>>>>}\n *     `to.passes` Passes per step, as arrays of objects of `framebuffer`s,\n *     referencing `to.textures`, and meta info. See `to.maps.passes`.\n * @returns {array<framebuffer<array<texture>>>} `to.steps`\n *     Hierarchy of steps of state, as an array of `framebuffer`s from\n *     `to.passes`, with arrays of `texture`s from `to.textures`, and meta\n *     information; set up here, or the given `state.steps` if it's an array.\n *     State data may be drawn into the framebuffers accordingly.\n *     See `mapGroups` and `getStep`.\n * @returns {object<number,string,array<number>>} `to.size` Size/type\n *     information about the created data resources.\n * @returns {number} `to.stepNow` The currently active state step, as given.\n * @returns {number} `to.passNow` The currently active draw pass, as given.\n */\nexport function getState({ texture, framebuffer }, state = {}, to = state) {\n    const {\n            steps = stepsDef, stepNow, passNow, maps, side, scale = scaleDef,\n            // Just `state.scale` ensures square power-of-two; for e.g: mipmaps.\n            width = (side ?? 2**scale), height = (side ?? 2**scale),\n            // Resource format settings.\n            type = typeDef, min = minDef, mag = magDef, wrap = wrapDef,\n            depth = depthDef, stencil = stencilDef\n        } = state;\n\n    to.maps = maps;\n    to.stepNow = stepNow;\n    to.passNow = passNow;\n\n    const {\n            values = valuesDef(),\n            channelsMin = channelsMinDef, textures: texturesMap\n        } = maps;\n\n    maps.channelsMin = channelsMin;\n    maps.values = values;\n\n    // Size of the created resources.\n    const size = to.size = {\n        steps: (steps.length ?? steps), textures: 0, passes: 0,\n        width, height, shape: [width, height], count: width*height\n    };\n\n    const textures = to.textures = [];\n    const passes = to.passes = [];\n\n    const addTexture = (step, pass, props) => (index) =>\n        ((textures[step] ??= [])[index] = {\n            // Meta info.\n            ...props,\n            entry: size.textures++, step, pass, index, map: texturesMap[index],\n            // Resources.\n            texture: texture?.(props)\n        })\n        .texture;\n\n    const addPass = (step) => (pass, index) => {\n        // All framebuffer color attachments need the same number of channels.\n        const textureProps = {\n            type, min, mag, wrap, width, height,\n            channels: reduce((max, t) =>\n                    reduce((max, v) => Math.max(max, values[v]),\n                        texturesMap[t], max),\n                pass, channelsMin)\n        };\n\n        const textures = map(addTexture(step, index, textureProps), pass);\n        const props = { depth, stencil, width, height, color: textures };\n\n        return ((passes[step] ??= [])[index] = {\n                // Meta info.\n                ...props, entry: size.passes++, step, index, map: pass,\n                // Resources.\n                framebuffer: framebuffer?.(props)\n            })\n            .framebuffer;\n    };\n\n    // Set up resources we'll need to store data per-texture per-pass per-step.\n    to.steps = map((passes, step) =>\n            // Use any given passes or create a new list of them.\n            (passes || map(addPass(step), maps.passes)),\n        // Use any given steps or create a new list of them.\n        ((Number.isFinite(steps))? range(steps) : steps), 0);\n\n    return to;\n}\n\n/**\n * Function to create a GL texture.\n *\n * @callback texture\n *\n * @param {string} type\n * @param {string} min\n * @param {string} mag\n * @param {string} wrap\n * @param {number} width\n * @param {number} height\n * @param {number} channels\n *\n * @returns {*} A GL texture, or an object serving that purpose.\n */\n\n/**\n * Function to create a GL framebuffer.\n *\n * @callback framebuffer\n *\n * @param {boolean} depth\n * @param {boolean} stencil\n * @param {number} width\n * @param {number} height\n * @param {array<texture>} color\n *\n * @returns {*} A GL framebuffer, or an object serving that purpose.\n */\n\nexport default getState;\n","/**\n * GPGPU update step.\n */\n\nimport each from '@epok.tech/fn-lists/each';\nimport { wrapGet } from '@epok.tech/fn-lists/wrap-index';\n\nimport { macroPass } from './macros';\nimport { getUniforms } from './inputs';\nimport { vertDef, positionsDef, preDef } from './const';\n\nconst scale = { vec2: 0.5 };\n\n/**\n * Creates a GPGPU update step function, for use with a GPGPU state object.\n *\n * @todo Optional transform feedback instead of GPGPU textures, where available\n *     (needs vertex draw, instead of texture draw).\n * @todo Make this fully extensible in state.\n *\n * @see [getState]{@link ./state.js#getState}\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [macroPass]{@link ./macros.js#macroPass}\n * @see [getUniforms]{@link ./inputs.js#getUniforms}\n *\n * @todo @example\n *\n * @param {object} api An API for GL resources.\n * @param {buffer} [api.buffer] Function to set up a GL buffer.\n * @param {command} [api.command=api] Function to create a GL render pass, given\n *     options, to be called later with options.\n * @param {object} state The GPGPU state to use. See `getState` and `mapGroups`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<number>>} state.passes How textures are grouped into\n *     passes. See `mapGroups`.\n * @param {string} [state.pre=preDef] The namespace prefix; `preDef` by default.\n * @param {object} [state.step=to] The properties for the step GL command.\n * @param {string} [state.step.vert=vertDef] The step vertex shader GLSL; a\n *     simple flat screen shader if not given.\n * @param {string} state.step.frag The step fragment shader GLSL.\n * @param {object} [state.step.uniforms=getUniforms(state)] The step uniforms;\n *     modifies any given. See `getUniforms`.\n * @param {array<number>|buffer} [state.step.positions=positionsDef()] The step\n *     position attributes; 3 points of a large flat triangle if not given.\n * @param {number} [state.step.count=state.step.positions.length*scale.vec2] The\n *     number of elements/attributes to draw.\n * @param {object} [state.step.passCommand] Any GL command properties to mix in\n *     over the default ones here, and passed to `api.command`.\n * @param {string} [state.step.vert=vertDef] Vertex shader GLSL to add code to.\n * @param {array} [state.step.verts] Preprocesses and caches vertex GLSL code\n *     per-pass if given, otherwise processes it just-in-time before each pass.\n * @param {string} [state.step.frag] Fragment shader GLSL to add code to.\n * @param {array} [state.step.frags] Preprocesses and caches fragment GLSL code\n *     per-pass, otherwise processes it just-in-time before each pass.\n * @param {onStep} [onStep] Callback upon each step.\n * @param {onPass} [onPass] Callback upon each pass.\n * @param {object} [to=(state.step ?? {})] The results object; `state.step` or\n *     a new object if not given.\n *\n * @returns {object} `to` The given `to` object; containing a GPGPU update\n *     step function and related properties, to be passed a GPGPU state.\n * @returns {string} `to.vert` The given/new `state.vert` vertex shader GLSL.\n * @returns {string} `to.frag` The given `state.frag` fragment shader GLSL.\n * @returns {array.string} `[to.verts]` Any cached pre-processed vertex shaders\n *     GLSL, if `state.step.verts` was given.\n * @returns {array.string} `[to.frags]` Any cached pre-processed fragment\n *     shaders GLSL, if `state.step.verts` was enabled.\n * @returns {object} `to.uniforms` The given `state.uniforms`.\n * @returns {number} `to.count` The given/new `state.count`.\n * @returns {buffer} `to.positions` The given/new `state.positions`; via\n *     `api.buffer`.\n * @returns {command} `to.pass` A GL command function to draw a given pass; via\n *     `api.command`.\n * @returns {function} `to.run` The main step function, which performs all the\n *     draw pass GL commands for a given state step.\n */\nexport function getStep(api, state, to = (state.step ?? {})) {\n    const { buffer, command = api } = api;\n    const { maps: { passes }, pre = preDef, step = to } = state;\n    let { positions = positionsDef() } = step;\n\n    const {\n            passCommand, vert = vertDef, verts, frag, frags, uniforms,\n            count = positions.length*scale.vec2\n        } = step;\n\n    to.vert = vert;\n    to.frag = frag;\n    to.uniforms = getUniforms(state, uniforms);\n    to.count = count;\n    positions = to.positions = buffer(positions);\n\n    if(verts || frags) {\n        // Pre-process the shaders needed for all the passes.\n        const stateCache = { ...state };\n\n        (verts && (to.verts = verts));\n        (frags && (to.frags = frags));\n\n        each((pass, p) => {\n                stateCache.passNow = p;\n                (verts && (verts[p] = macroPass(stateCache, 'vert')+vert));\n                (frags && (frags[p] = macroPass(stateCache, 'frag')+frag));\n            },\n            passes);\n    }\n\n    to.pass = command(to.passCommand = {\n        // Uses the full-screen vertex shader state by default.\n        vert(_, props) {\n            const { passNow: p, step } = props;\n            const { vert: v = vert, verts: vs = verts } = step;\n\n            // Specify the shader type, for per-shader macro hooks.\n            return vs?.[p] ?? macroPass(props, 'vert')+v;\n        },\n        frag(_, props) {\n            const { passNow: p, step } = props;\n            const { frag: f = frag, frags: fs = frags } = step;\n\n            // Specify the shader type, for per-shader macro hooks.\n            return fs?.[p] ?? macroPass(props, 'frag')+f;\n        },\n        attributes: {\n            [pre+'position']: (_, { step: { positions: p = positions } }) => p\n        },\n        uniforms, count,\n        depth: { enable: false },\n        framebuffer: (_, { steps: ss, stepNow: s, passNow: p }) =>\n            wrapGet(s, ss)[p],\n        ...passCommand\n    });\n\n    to.run = (props = state) => {\n        const { steps, step } = props;\n        const stepNow = props.stepNow = (props.stepNow+1 || 0);\n        const { pass, onPass, onStep } = step;\n        const stepProps = (onStep?.(props, wrapGet(stepNow, steps)) ?? props);\n\n        each((p, i) => {\n                stepProps.passNow = i;\n                pass(onPass?.(stepProps, p) ?? stepProps);\n            },\n            stepProps.maps.passes);\n\n        return props;\n    };\n\n    return to;\n}\n\n/**\n * Function to set up a GL buffer.\n *\n * @callback buffer\n *\n * @param {array<number>|buffer} [state.step.positions] The step position\n *     attributes.\n *\n * @returns {*} A GL buffer to use for vertex attributes, or an object serving\n *     that purpose.\n */\n\n/**\n * Function to create a GL render pass, given options, to be called later with\n * options.\n *\n * @see [getUniforms]{@link ./step.js#getUniforms}\n * @see [framebuffer]{@link ./state.js#framebuffer}\n *\n * @callback command\n *\n * @param {object} passCommand The properties from which to create the GL render\n *     function for a given pass.\n * @param {function} [passCommand.vert] Function hook returning the vertex\n *     shader GLSL string for the next render pass.\n * @param {function} [passCommand.frag] Function hook returning the fragment\n *     shader GLSL string for the next render pass.\n * @param {object<buffer>} [passCommand.attributes] The vertex attributes for\n *     the next render pass.\n * @param {object<function>} [passCommand.uniforms] The uniform hooks for the\n *     given `props`. See `getUniforms`.\n * @param {number} [passCommand.count] The number of elements to draw.\n * @param {object<boolean,*>} [passCommand.depth] An object describing the depth\n *     settings for the next render pass; e.g: `passCommand.depth.enable` flag.\n * @param {function} [passCommand.framebuffer] Function hook returning the\n *     `framebuffer` to draw to in the next render pass. See `framebuffer`.\n *\n * @returns {function} Function to execute a GL render pass, with options, for\n *     a given render pass.\n */\n\n/**\n * Callback upon each step.\n *\n * @see [getState]{@link ./state.js#getState}\n * @see [framebuffer]{@link ./state.js#framebuffer}\n *\n * @callback onStep\n *\n * @param {object} [props] The `props` passed to `run`.\n * @param {array<framebuffer>} step The `framebuffer`s for `props.stepNow` from\n *     `props.steps`, where the next state step will be drawn. See `getState`.\n *\n * @returns {object} A `stepProps` to use for each of the step's next passes; or\n *     nullish to use the given `props`.\n */\n\n/**\n * Callback upon each pass.\n *\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n *\n * @callback onPass\n *\n * @param {object} [stepProps] The `props` passed to `run` via any `onStep`.\n * @param {array<number>} pass The maps for the next pass. See `mapGroups`.\n *\n * @returns {object} A `passProps` to use for the render `command` call; or\n *     nullish to use the given `stepProps`.\n */\n\nexport default getStep;\n","/**\n * Wraps an index within a given length, so that indexes greater than the length\n * loop back past 0, and indexes less than 0 loop backward from the length.\n * Similar to the indexing behaviour of `Array.slice`.\n *\n * @param {number} i The index to wrap.\n * @param {number} l The length to wrap the index within.\n *\n * @returns {number} The index wrapped within the length.\n */\nexport const wrapIndex = (i, l) => ((i%l)+l)%l;\n\n/**\n * Gives the entry at a wrapped index of a given list, never exceeds its bounds.\n *\n * @see wrapIndex\n *\n * @param {number} i The index to wrap.\n * @param {array} a A list to index (array or array-like list).\n * @param {number} a.length The length property of the given list.\n *\n * @returns {*} The entry at the wrapped index of the given list.\n */\nexport const wrapGet = (i, a) => a[wrapIndex(i, a.length)];\n\nexport const wrap = { index: wrapIndex, get: wrapGet };\n\nexport default wrap;\n","/**\n * GPGPU GLSL preprocessor macros for each part of the state.\n *\n * Careful defining these, as each set of different macros will result in new\n * shaders and compilations, missing the cache here and in the rendering system.\n * So, as few unique macros as possible should be created for a given set of\n * inputs, for efficiency.\n *\n * @todo Allow passes into or across textures; separate data and texture shapes.\n */\n\nimport reduce from '@epok.tech/fn-lists/reduce';\nimport map from '@epok.tech/fn-lists/map';\nimport { type } from '@epok.tech/is-type/type';\n\nimport { preDef, boundDef } from './const';\n\nexport const rgba = 'rgba';\nexport const cache = {};\n\n// Keys for each part of the macro handling process available to hooks.\nexport const hooks = {\n    // The full set of macros.\n    macroPass: '',\n    // Each part of the set of macros.\n    macroValues: 'values', macroOutput: 'output',\n    macroSamples: 'samples', macroSamplesTap: 'tap'\n};\n\n/**\n * Whether macros should be handled here; or the result of handling them by a\n * given named hook.\n * Allows macros of the given key to be handled by external named hooks, to\n * replace any part of the functionality here.\n *\n * @example\n *     // Macros to be handled here, the default.\n *     [hasMacros(), hasMacros({}), hasMacros({ macros: true })]]\n *         .every((m) => m === null);\n *\n *     // Macros to be handled here, with prefix `'pre_'` instead of `'preDef'`.\n *     hasMacros({ pre: 'pre_' }) === null;\n *\n *     // Macros not created.\n *     [hasMacros({ macros: false }), hasMacros({ macros: 0 })]\n *         .every((m) => m === '');\n *\n *     // Macros for 'a' handled by external static hook, not here.\n *     hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'a') === '//A\\n';\n *     // Macros for 'b' handled by external function hook, not here.\n *     hasMacros({ macros: { a: '//A\\n', b: () => '//B\\n' } }, 'b') === '//B\\n';\n *     // Macros specified `on` a 'frag' not created.\n *     hasMacros({ macros: { frag: 0 } }, '', 'frag') === '';\n *     // Macros specified `on` a 'vert' handled here.\n *     hasMacros({ macros: { frag: 0, a_vert: 0 } }, '', 'vert') === null;\n *     // Macros for hook `'a'` specified `on` a 'vert' not created.\n *     hasMacros({ macros: { frag: 0, a_vert: 0 } }, 'a', 'vert') === '';\n *\n * @param {object} [props] The properties handling macros.\n * @param {string} [key] The name for which macros should be handled.\n * @param {string} [on=''] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [macros=props.macros] Whether and how\n *     GLSL preprocessor macros should be handled:\n *     - If it's false-y and non-nullish, no macros are handled here.\n *     - If it's a string, no macros are handled here as it's used instead.\n *     - If it's a function, it's passed the given `props`, `key`, `macros`, and\n *         the returned result is used.\n *     - If it's an object, any value at the given `key` is entered recursively,\n *         with the given `props`, `key`, and `macros[key]`.\n *     - Otherwise, returns `null` to indicate macros should be handled here.\n *\n * @returns {string|null|*} Either the result of the macros handled elsewhere,\n *     or `null` if macros should be handled here.\n */\nexport function hasMacros(props, key, on = '', macros = props?.macros) {\n    if((macros ?? true) === true) { return null; }\n    else if(!macros) { return ''; }\n\n    const t = type(macros);\n\n    return ((t === 'Function')? macros(props, key, on, macros)\n        : ((t === 'String')? macros\n        : (((macros instanceof Object) && (key in macros))?\n            hasMacros(props, key, on, macros[key])\n        : ((on)? hasMacros(props, ((key)? key+'_' : '')+on, '', macros)\n        :   null))));\n}\n\n/**\n * Generates an array-like declaration, as a GLSL syntax string compatible with\n * all versions.\n * Workaround for lack of `const` arrays in GLSL < 3.\n * Used as the base for the other GLSL version list types, ensuring a standard\n * basis while offering further language features where available.\n *\n * @example\n *     getGLSLListBase('float', 'list', [0, 1, 2], 'const'); // =>\n *     'const int list_l = 3; '+\n *     'const int list_0 = float(0); '+\n *     'const int list_1 = float(1); '+\n *     'const int list_2 = float(2);';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array-like declaration string.\n */\nexport const getGLSLListBase = (type, name, a, qualify = '', init = type) =>\n    `const int ${name}_l = ${a.length};`+\n    reduce((s, v, i) =>\n            `${s} ${(qualify && qualify+' ')+type} ${name}_${i} = ${\n                init}(${v.join?.(', ') ?? v});`,\n        a, '');\n\n/**\n * Generates an array-like declaration, as a GLSL 1 syntax string.\n * Workaround for lack of `const` arrays in GLSL < 3.\n * Adds a lookup macro function; slow here, but standard.\n *\n * @example\n *     getGLSL1ListLike('float', 'list', [0, 1, 2], 'const'); // =>\n *     'const int list_l = 3; '+\n *     'const int list_0 = float(0); '+\n *     'const int list_1 = float(1); '+\n *     'const int list_2 = float(2);\\n'+\n *     '// `list_i` index macro (e.g: `list_i(0)`) may be slow, `+\n *         'prefer direct reference (e.g: `list_0`) where possible.\\n'+\n *     '#define list_i(i) ((i == 2)? list_2 : ((i == 1)? list_1 : list_0))\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array-like declaration string.\n */\nexport const getGLSL1ListLike = (type, name, a, qualify = '', init = type) =>\n    getGLSLListBase(type, name, a, qualify, init)+'\\n'+\n    // @todo Would ideally use the concatenation macro, but can't in GLSL 1.\n    // `#define ${name}_i(i) ${name}_##i`;\n    `// \\`${name}_i\\` index macro (e.g: \\`${name}_i(0)\\`) may be slow, `+\n        `prefer direct reference (e.g: \\`${name}_0\\`) where possible.\\n`+\n    `#define ${name}_i(i) ${reduce((s, v, i) =>\n            ((i)? `((i == ${i})? ${name}_${i} : ${s})` : `${name}_${i}`),\n        a, '')}\\n`;\n\n/**\n * Generates an array declaration, as a GLSL 1 syntax string.\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @example\n *     getGLSL1ListArray('vec3', 'list', [[1, 0, 0], [0, 2, 0], [0, 0, 3]]);\n *     // =>\n *     'const int list_l = 3; '+\n *     'vec3 list_0 = vec3(1, 0, 0); '+\n *     'vec3 list_1 = vec3(0, 2, 0); '+\n *     'vec3 list_2 = vec3(0, 0, 3); '+\n *     'vec3 list[list_l]; '+\n *     'list[0] = list_0; '+\n *     'list[1] = list_1; '+\n *     'list[2] = list_2;\\n'+\n *     '#define list_i(i) list[i]\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 1 array declaration string.\n */\nexport const getGLSL1ListArray = (type, name, a, qualify = '', init = type) =>\n    getGLSLListBase(type, name, a, qualify, init)+' '+\n    (qualify && qualify+' ')+`${type} ${name}[${name}_l];`+\n    reduce((s, _, i) => `${s} ${name}[${i}] = ${name}_${i};`, a, '')+'\\n'+\n    `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Generates an array declaration, as a GLSL 3 syntax string.\n * Lookup and meta macros are added for consistency with other versions.\n *\n * @example\n *     getGLSL3List('int', 'list', [0, 1, 2], 'const'); // =>\n *     'const int list_l = 3; '+\n *     'const int list_0 = int(0); '+\n *     'const int list_1 = int(1); '+\n *     'const int list_2 = int(2); '+\n *     'const int list[list_l] = int[list_l](list_0, list_1, list_2);\\n'+\n *     '#define list_i(i) list[i]\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed.\n * @param {string} [init=type] A data-type initialiser, `type` by default.\n *\n * @returns {string} The GLSL 3 array declaration string.\n */\nexport const getGLSL3List = (type, name, a, qualify = '', init = type) =>\n    getGLSLListBase(type, name, a, qualify, init)+' '+\n    `${(qualify && qualify+' ')+type} ${name}[${name}_l] = ${init}[${name}_l](${\n        reduce((s, _, i) => (s && s+', ')+name+'_'+i, a, '')});\\n`+\n    `#define ${name}_i(i) ${name}[i]\\n`;\n\n/**\n * Creates a GLSL definition of an array, and initialises it with the given\n * values, type, and variable name.\n * The initialisation is valid GLSL 1.0 or greater syntax; but is written with\n * escaped new-lines so it may be used in a single-line - e.g: for preprocessor\n * macros.\n * For a `qualify` of `const` on any `glsl` less than `3`, falls back to using\n * non-array variables with the index appended to `name`, since `const` arrays\n * aren't supported before GLSL 3.0.\n *\n * @example\n *     getGLSLList('int', 'test', [0, 1]); // =>\n *     'const int test_l = 2; '+\n *     'int test_0 = int(0); '+\n *     'int test_1 = int(1); '+\n *     'int test[test_l]; '+\n *     'test[0] = test_0; '+\n *     'test[1] = test_1;\\n'+\n *     '#define test_i(i) test[i]\\n';\n *\n *     getGLSLList('ivec2', 'vecs', [[1, 0], [0, 1]], 'const', 3); // =>\n *     'const int vecs_l = 2; '+\n *     'ivec2 vecs_0 = ivec2(1, 0); '+\n *     'ivec2 vecs_1 = ivec2(0, 1); '+\n *     'const ivec2 vecs[vecs_l] = ivec2[vecs_l](vecs_0, vecs_1);\\n'+\n *     '#define vecs_i(i) vecs[i]\\n';\n *\n *     getGLSLList('int', 'listLike', [0, 1], 'const', 1); // =>\n *     'const int listLike_l = 2; '+\n *     'const int listLike_0 = int(0); '+\n *     'const int listLike_1 = int(1);\\n'+\n *     '// `listLike_i` index macro (e.g: `listLike_i(0)`) may be slow, `+\n *         'prefer direct reference (e.g: `listLike_0`) where possible.\\n'+\n *     '#define listLike_i(i) ((i == 1)? listLike_1 : listLike_0)\\n';\n *\n * @param {string} type The GLSL list data-type.\n * @param {string} name The name of the GLSL list variable.\n * @param {array<number,array<number>>} a The list of GLSL values.\n * @param {string} [qualify=''] A GLSL qualifier, if needed (e.g: `const`).\n * @param {number} [glsl=1] The GLSL version to target, if specified.\n * @param {string} [init] A data-type initialiser.\n *\n * @returns {string} The GLSL (1 or 3) array or array-like declaration string.\n */\nexport const getGLSLList = (type, name, a, qualify = '', glsl = 1, init) =>\n    ((glsl >= 3)? getGLSL3List\n    : ((qualify.trim() === 'const')? getGLSL1ListLike\n    :   getGLSL1ListArray))(type, name, a, qualify, init);\n\n/**\n * Defines the values within textures per-step, as GLSL preprocessor macros.\n * These macros define mappings from values to their textures and channels.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const maps = { values: [2, 4, 1], channelsMax: 4 };\n *\n *     // No optimisations - values not packed, single texture output per pass.\n *     const state = {\n *         steps: 2, maps: mapGroups({ ...maps, texturesMax: 1, packed: 0 })\n *     };\n *\n *     macroValues(state); // =>\n *     '#define texture_0 0\\n'+\n *     '#define channels_0 rg\\n'+\n *     '\\n'+\n *     '#define texture_1 1\\n'+\n *     '#define channels_1 rgba\\n'+\n *     '\\n'+\n *     '#define texture_2 2\\n'+\n *     '#define channels_2 r\\n'+\n *     '\\n'+\n *     '#define textures 3\\n'+\n *     '#define passes 3\\n'+\n *     '#define stepsPast 1\\n'+\n *     '#define steps 2\\n';\n *\n *     // Automatically packed values - values across fewer textures/passes.\n *     state.maps = mapGroups({ ...maps, texturesMax: 1 });\n *     state.size = { count: 2**5 };\n *     macroValues(state); // =>\n *     '#define texture_1 0\\n'+\n *     '#define channels_1 rgba\\n'+\n *     '\\n'+\n *     '#define texture_0 1\\n'+\n *     '#define channels_0 rg\\n'+\n *     '\\n'+\n *     '#define texture_2 1\\n'+\n *     '#define channels_2 b\\n'+\n *     '\\n'+\n *     '#define count 32\\n'+\n *     '#define textures 2\\n'+\n *     '#define passes 2\\n'+\n *     '#define stepsPast 1\\n'+\n *     '#define steps 2\\n';\n *\n *     // Can bind more texture outputs per pass - values across fewer passes.\n *     state.maps = mapGroups({ ...maps, texturesMax: 4 });\n *     macroValues(state); // =>\n *     '#define texture_1 0\\n'+\n *     '#define channels_1 rgba\\n'+\n *     '\\n'+\n *     '#define texture_0 1\\n'+\n *     '#define channels_0 rg\\n'+\n *     '\\n'+\n *     '#define texture_2 1\\n'+\n *     '#define channels_2 b\\n'+\n *     '\\n'+\n *     '#define count 32\\n'+\n *     '#define textures 2\\n'+\n *     '#define passes 1\\n'+\n *     '#define stepsPast 1\\n'+\n *     '#define steps 2\\n';\n *\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled\n *     or prefixed. See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step.\n * @param {array<number>} state.maps.values How values of each data item are\n *     grouped into textures. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures The groupings of values\n *     into textures. See `mapGroups`.\n * @param {array} state.maps.passes Passes drawn per-step. See `mapGroups`.\n * @param {array|number} state.steps States drawn across frames. See `getState`.\n * @param {number} [state.bound=boundDef] How many steps are bound as outputs,\n *     unavailable as inputs.\n * @param {object} [state.size] Any size information about the GL resources.\n * @param {number} [state.size.count] The number of data entries per texture\n *     (the texture's area), if given. See `getState`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings from\n *     values to textures/channels.\n */\nexport function macroValues(state, on) {\n    const key = hooks.macroValues;\n    const hook = hasMacros(state, key, on);\n\n    if(hook !== null) { return hook; }\n\n    const { maps, steps, bound = boundDef, size, pre: n = preDef } = state;\n    const { values, textures, passes: { length: passesL } } = maps;\n    const stepsL = (steps.length ?? steps);\n    const count = size?.count;\n\n    const c = key+':'+\n        JSON.stringify({ n, bound, values, textures, stepsL, passesL, count });\n\n    return (cache[c] ??=\n        reduce((s, texture, t, _, i = 0) => reduce((s, v) => s+\n                    `#define ${n}texture_${v} ${t}\\n`+\n                    `#define ${n}channels_${v} ${\n                        rgba.slice(i, (i += values[v]))}\\n\\n`,\n                texture, s),\n            textures, '')+\n        ((count)? `#define count ${count}\\n` : '')+\n        `#define ${n}textures ${textures.length}\\n`+\n        `#define ${n}passes ${passesL}\\n`+\n        `#define ${n}stepsPast ${stepsL-bound}\\n`+\n        `#define ${n}steps ${stepsL}\\n`);\n}\n\n/**\n * Defines the outputs being drawn to per-pass, as GLSL preprocessor macros.\n * These macros define mappings from values to their outputs, if bound.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const maps = { values: [2, 4, 1], channelsMax: 4 };\n *\n *     // No optimisations - values not packed, single texture output per pass.\n *     const state = {\n *         passNow: 0, maps: mapGroups({ ...maps, texturesMax: 1, packed: 0 })\n *     };\n *\n *     macroOutput(state); // =>\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_0 0\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rg\\n';\n *\n *     // Automatically packed values - values across fewer textures/passes.\n *     state.maps = mapGroups({ ...maps, texturesMax: 1 });\n *     macroOutput(state); // =>\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_1 0\\n'+\n *     '#define attach_1 0\\n'+\n *     '#define output_1 gl_FragData[attach_1].rgba\\n';\n *\n *     // Next pass in this step.\n *     ++state.passNow;\n *     macroOutput(state); // =>\n *     '#define passNow 1\\n'+\n *     '\\n'+\n *     '#define bound_0 1\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rg\\n'+\n *     '\\n'+\n *     '#define bound_2 1\\n'+\n *     '#define attach_2 0\\n'+\n *     '#define output_2 gl_FragData[attach_2].b\\n';\n *\n *     // Can bind more texture outputs per pass - values across fewer passes.\n *     state.maps = mapGroups({ ...maps, texturesMax: 4 });\n *     state.passNow = 0;\n *     macroOutput(state); // =>\n *     '#define passNow 0\\n'+\n *     '\\n'+\n *     '#define bound_1 0\\n'+\n *     '#define attach_1 0\\n'+\n *     '#define output_1 gl_FragData[attach_1].rgba\\n'+\n *     '\\n'+\n *     '#define bound_0 1\\n'+\n *     '#define attach_0 1\\n'+\n *     '#define output_0 gl_FragData[attach_0].rg\\n'+\n *     '\\n'+\n *     '#define bound_2 1\\n'+\n *     '#define attach_2 1\\n'+\n *     '#define output_2 gl_FragData[attach_2].b\\n';\n *\n * @param {object} state Properties for generating the macros. See `getState`:\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *     See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `pre` if not given.\n * @param {number} state.passNow The index of the currently active pass.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<number>} state.maps.values How values of each data item may be\n *     grouped into textures across passes. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures The groupings of values\n *     into textures. See `mapGroups`.\n * @param {array<array<number>>} state.maps.passes The groupings of textures\n *     into passes. See `mapGroups`.\n *\n * @returns {string} The GLSL preprocessor macros for the pass's bound outputs.\n */\nexport function macroOutput(state, on) {\n    const key = hooks.macroOutput;\n    const hook = hasMacros(state, key, on);\n\n    if(hook !== null) { return hook; }\n\n    const { passNow: p, maps, pre: n = preDef } = state;\n    const { values, textures, passes } = maps;\n    const pass = passes[p];\n    const c = key+':'+JSON.stringify({ n, p, values, textures, passes });\n\n    return (cache[c] ??=\n        `#define ${n}passNow ${p}\\n`+\n        reduce((s, texture, bound, _, i = 0) => reduce((s, v) => `${s}\\n`+\n                    `#define ${n}bound_${v} ${texture}\\n`+\n                    `#define ${n}attach_${v} ${bound}\\n`+\n                    `#define ${n}output_${v} gl_FragData[${n}attach_${v}].${\n                        rgba.slice(i, (i += values[v]))}\\n`,\n                textures[texture], s),\n            pass, ''));\n}\n\n/**\n * Defines the texture samples/reads per-pass, as GLSL preprocessor macros.\n * The macros define the mapping between the values and the minimum texture\n * samples for the data they derive from. They're set up as function-like macros\n * that may be called from the shader to initialise the mappings arrays with a\n * given name.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see getGLSLList\n * @see [getMaps]{@link ./maps.js#getMaps}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const values = [2, 4, 1];\n *     const derives = [2, , [[1, 0], true]];\n *     const maps = { values, derives, channelsMax: 4 };\n *\n *     // No optimisations - values not packed, single texture output per pass.\n *     const state = { maps: getMaps({ ...maps, texturesMax: 1, packed: 0 }) };\n *\n *     state.passNow = 0;\n *     macroSamples(state); // =>\n *     '#define useSamples '+\n *         'const int samples_l = 1; '+\n *         'const ivec2 samples_0 = ivec2(0, 2);\\n'+\n *     '// `samples_i` index macro (e.g: `samples_i(0)`) may be slow, '+\n *         'prefer direct reference (e.g: `samples_0`) where possible.\\n'+\n *     '#define samples_i(i) samples_0\\n'+\n *     '\\n'+\n *     '#define tapSamples(states, uv, textures) '+\n *         'const int data_l = 1; '+\n *         'vec4 data_0 = vec4(texture2D('+\n *             'states[(int(samples_0.s)*int(textures))+int(samples_0.t)], '+\n *             'vec2(uv))); '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = data_0;\\n'+\n *     '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define tapSamplesShift(states, uv, textures, byS, byT) '+\n *         'const int data_l = 1; '+\n *         'vec4 data_0 = vec4(texture2D('+\n *             'states[((int(samples_0.s)+int(byS))*int(textures))+'+\n *                 'int(samples_0.t)+int(byT)], '+\n *             'vec2(uv))); '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = data_0;\\n'+\n *     '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '\\n'+\n *     '#define useReads_0 '+\n *         'const int reads_0_l = 1; '+\n *         'const int reads_0_0 = int(0);\\n'+\n *     '// `reads_0_i` index macro (e.g: `reads_0_i(0)`) may be slow, '+\n *         'prefer direct reference (e.g: `reads_0_0`) where possible.\\n'+\n *     '#define reads_0_i(i) reads_0_0\\n';\n *\n *     // Next pass in this step - no derives, no samples nor reads.\n *     ++state.passNow;\n *     macroSamples(state); // =>\n *     '';\n *\n *     // Next pass in this step.\n *     ++state.passNow;\n *     macroSamples(state); // =>\n *     '#define useSamples '+\n *         'const int samples_l = 4; '+\n *         'const ivec2 samples_0 = ivec2(1, 0); '+\n *         'const ivec2 samples_1 = ivec2(0, 0); '+\n *         'const ivec2 samples_2 = ivec2(0, 1); '+\n *         'const ivec2 samples_3 = ivec2(0, 2);\\n'+\n *     '// `samples_i` index macro (e.g: `samples_i(0)`) may be slow, '+\n *         'prefer direct reference (e.g: `samples_0`) where possible.\\n'+\n *     '#define samples_i(i) ((i == 3)? samples_3 : ((i == 2)? samples_2 '+\n *         ': ((i == 1)? samples_1 : samples_0)))\\n'+\n *     '\\n'+\n *     '#define tapSamples(states, uv, textures) '+\n *         'const int data_l = 4; '+\n *         'vec4 data_0 = vec4(texture2D('+\n *             'states[(int(samples_0.s)*int(textures))+int(samples_0.t)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_1 = vec4(texture2D('+\n *             'states[(int(samples_1.s)*int(textures))+int(samples_1.t)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_2 = vec4(texture2D('+\n *             'states[(int(samples_2.s)*int(textures))+int(samples_2.t)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_3 = vec4(texture2D('+\n *             'states[(int(samples_3.s)*int(textures))+int(samples_3.t)], '+\n *             'vec2(uv))); '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = data_0; '+\n *         'data[1] = data_1; '+\n *         'data[2] = data_2; '+\n *         'data[3] = data_3;\\n'+\n *     '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define tapSamplesShift(states, uv, textures, byS, byT) '+\n *         'const int data_l = 4; '+\n *         'vec4 data_0 = vec4(texture2D('+\n *             'states[((int(samples_0.s)+int(byS))*int(textures))+'+\n *                 'int(samples_0.t)+int(byT)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_1 = vec4(texture2D('+\n *             'states[((int(samples_1.s)+int(byS))*int(textures))+'+\n *                 'int(samples_1.t)+int(byT)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_2 = vec4(texture2D('+\n *             'states[((int(samples_2.s)+int(byS))*int(textures))+'+\n *                 'int(samples_2.t)+int(byT)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_3 = vec4(texture2D('+\n *             'states[((int(samples_3.s)+int(byS))*int(textures))+'+\n *                 'int(samples_3.t)+int(byT)], '+\n *             'vec2(uv))); '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = data_0; '+\n *         'data[1] = data_1; '+\n *         'data[2] = data_2; '+\n *         'data[3] = data_3;\\n'+\n *     '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '\\n'+\n *     '#define useReads_2 '+\n *         'const int reads_2_l = 4; '+\n *         'const int reads_2_0 = int(0); '+\n *         'const int reads_2_1 = int(1); '+\n *         'const int reads_2_2 = int(2); '+\n *         'const int reads_2_3 = int(3);\\n'+\n *     '// `reads_2_i` index macro (e.g: `reads_2_i(0)`) may be slow, '+\n *         'prefer direct reference (e.g: `reads_2_0`) where possible.\\n'+\n *     '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *         ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n *     '\\n';\n *\n *     // Automatically packed values - values across fewer textures/passes.\n *     // Can bind more texture outputs per pass - values across fewer passes.\n *     // Also fewer samples where values share derives or textures.\n *     state.maps = mapGroups({ ...maps, texturesMax: 4 });\n *     state.passNow = 0;\n *     macroSamples(state); // =>\n *     '#define useSamples '+\n *         'const int samples_l = 3; '+\n *         'const ivec2 samples_0 = ivec2(0, 1); '+\n *         'const ivec2 samples_1 = ivec2(1, 1); '+\n *         'const ivec2 samples_2 = ivec2(0, 0);\\n'+\n *     '// `samples_i` index macro (e.g: `samples_i(0)`) may be slow, '+\n *         'prefer direct reference (e.g: `samples_0`) where possible.\\n'+\n *     '#define samples_i(i) '+\n *         '((i == 2)? samples_2 : ((i == 1)? samples_1 : samples_0))\\n'+\n *     '\\n'+\n *     '#define tapSamples(states, uv, textures) '+\n *         'const int data_l = 3; '+\n *         'vec4 data_0 = vec4(texture2D('+\n *             'states[(int(samples_0.s)*int(textures))+int(samples_0.t)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_1 = vec4(texture2D('+\n *             'states[(int(samples_1.s)*int(textures))+int(samples_1.t)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_2 = vec4(texture2D('+\n *             'states[(int(samples_2.s)*int(textures))+int(samples_2.t)], '+\n *             'vec2(uv))); '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = data_0; '+\n *         'data[1] = data_1; '+\n *         'data[2] = data_2;\\n'+\n *     '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define tapSamplesShift(states, uv, textures, byS, byT) '+\n *         'const int data_l = 3; '+\n *         'vec4 data_0 = vec4(texture2D('+\n *             'states[((int(samples_0.s)+int(byS))*int(textures))+'+\n *                 'int(samples_0.t)+int(byT)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_1 = vec4(texture2D('+\n *             'states[((int(samples_1.s)+int(byS))*int(textures))+'+\n *                 'int(samples_1.t)+int(byT)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_2 = vec4(texture2D('+\n *             'states[((int(samples_2.s)+int(byS))*int(textures))+'+\n *                 'int(samples_2.t)+int(byT)], '+\n *             'vec2(uv))); '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = data_0; '+\n *         'data[1] = data_1; '+\n *         'data[2] = data_2;\\n'+\n *     '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '\\n'+\n *     '#define useReads_0 '+\n *         'const int reads_0_l = 1; '+\n *         'const int reads_0_0 = int(0);\\n'+\n *     '// `reads_0_i` index macro (e.g: `reads_0_i(0)`) may be slow, '+\n *         'prefer direct reference (e.g: `reads_0_0`) where possible.\\n'+\n *     '#define reads_0_i(i) reads_0_0\\n'+\n *     '\\n'+\n *     '#define useReads_2 '+\n *         'const int reads_2_l = 4; '+\n *         'const int reads_2_0 = int(1); '+\n *         'const int reads_2_1 = int(0); '+\n *         'const int reads_2_2 = int(2); '+\n *         'const int reads_2_3 = int(0);\\n'+\n *     '// `reads_2_i` index macro (e.g: `reads_2_i(0)`) may be slow, '+\n *         'prefer direct reference (e.g: `reads_2_0`) where possible.\\n'+\n *     '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *         ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n *     '\\n';\n *\n * @param {object} state Properties used to generate the macros. See `getState`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n * @param {string|function|object|false} [state.macros] How macros are handled.\n *     See `hasMacros`.\n * @param {string} [state.pre=preDef] Macros prefix; `preDef` if not given.\n * @param {number} state.passNow The index of the currently active pass.\n * @param {object} state.maps  How `values` are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<array<number>>>} [state.maps.samples] The minimal set of\n *     texture samples to use. See `mapSamples`.\n * @param {array<array<array<number>>>} [state.maps.reads] The mappings from\n *     values to the corresponding `state.samples`. See `mapSamples`.\n * @param {number} [state.glsl=1] The GLSL language version. See `getGLSLList`.\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings for\n *     samples and reads, for each value.\n */\nexport function macroSamples(state, on) {\n    const key = hooks.macroSamples;\n    const hook = hasMacros(state, key, on);\n\n    if(hook !== null) { return hook; }\n\n    const { passNow: p = 0, maps, glsl, pre: n = preDef } = state;\n    const { samples, reads } = maps;\n    const passSamples = samples?.[p];\n    const passReads = reads?.[p];\n    // Whether to generate GLSL preprocessor macros for the lookup logic.\n    const tap = hasMacros(state, hooks.macroSamplesTap, on);\n\n    const c = key+':'+\n        JSON.stringify({ n, p, passSamples, passReads, glsl, tap });\n\n    return (cache[c] ??=\n        ((!passSamples)? ''\n        :   `#define ${n}useSamples ${\n                getGLSLList('ivec2', n+'samples', passSamples, 'const', glsl)\n            }\\n`+\n            // The texture-sampling logic.\n            /**\n             * @todo Fix GLSL3/D3D error \"sampler array index must be a literal\n             *     expression\".\n             *     Caused by need for vertex attribute to look up sampler array;\n             *     as it's a non-constant expression; this is also a limitation\n             *     in the GLSL3 spec:\n             *     (a) Combine texture steps into one map would work around it,\n             *     avoiding sampler arrays entirely; maybe usage-specific/heavy;\n             *     could have 1 framebuffer, copy pixels into its offset in\n             *     1 big past states texture (merge the current sampler array);\n             *     analogous to GLSL3 `sampler2DArray` and `sampler3D`.\n             *     (b) Maybe `gl_VertexID` could work around this; only GLSL 3+.\n             *     (c) Maybe try a list-like instead of a sampler array; e.g:\n             *     `uniform sampler2D state_0;` etc; instead of the current\n             *     `uniform sampler2D states[stepsPast*textures];`; updates to\n             *     both inputs and macros; how can lookups be quick without loop\n             *     or nested `((i == 1)? state_1 : state_0)`?\n             *     Of these options, (a) seems to be the best, most future-proof\n             *     and in line with the specs, cross-platform, while avoiding\n             *     awkward workarounds.\n             *\n             * @see https://stackoverflow.com/a/60110986/716898\n             * @see https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_2d_array.html\n             * @see https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_3d.html\n             */\n            (tap ??\n                `#define ${n}tapSamples(states, uv, textures) `+\n                    // 2D-to-1D indexing, as textures are a flat array.\n                    getGLSLList('vec4', n+'data',\n                            map((_, s) =>\n                                'texture2D(states['+\n                                    `(int(${n}samples_${s}.s)*int(textures))+`+\n                                    `int(${n}samples_${s}.t)`+\n                                '], vec2(uv))',\n                            passSamples),\n                        '', glsl)+'\\n'+\n                // Data may also be sampled by adding step/texture lookup shift.\n                `#define ${n}tapSamplesShift(states, uv, textures, byS, byT) `+\n                    // 2D-to-1D indexing, as textures are a flat array.\n                    getGLSLList('vec4', n+'data',\n                            map((_, s) =>\n                                'texture2D(states['+\n                                    `((int(${n}samples_${s}.s)+int(byS))*`+\n                                        'int(textures))+'+\n                                    `int(${n}samples_${s}.t)+int(byT)`+\n                                '], vec2(uv))',\n                            passSamples),\n                        '', glsl)+'\\n'+\n                '\\n'))+\n        ((!passReads)? ''\n        :   reduce((s, reads, v) =>\n                    `${s}#define ${n}useReads_${v} ${\n                        getGLSLList('int', n+'reads_'+v, reads, 'const', glsl)\n                    }\\n`,\n                passReads, '')));\n}\n\n/**\n * Defines all GLSL preprocessor macro values, texture samples, and outputs for\n * the active pass.\n * The macros define the mapping between the active values, their textures and\n * channels, bound outputs, and other macros useful for a draw pass.\n * Caches the result if `macros` generation is enabled, to help reuse shaders.\n *\n * @see hasMacros\n * @see macroValues\n * @see macroOutput\n * @see macroSamples\n * @see [getMaps]{@link ./maps.js#getMaps}\n * @see [getState]{@link ./state.js#getState}\n *\n * @example\n *     const values = [2, 4, 1];\n *     const derives = [2, , [[1, 0], true]];\n *\n *     // Automatically packed values - values across fewer textures/passes.\n *     // Only a single texture output per pass - values across more passes.\n *     const state = {\n *         passNow: 0, steps: 2, size: { count: 2**5 }, pre: 'gpgpu_',\n *         maps: getMaps({ values, derives, channelsMax: 4, texturesMax: 1 })\n *     };\n *\n *     macroPass(state); // =>\n *     '#define gpgpu_texture_1 0\\n'+\n *     '#define gpgpu_channels_1 rgba\\n'+\n *     '\\n'+\n *     '#define gpgpu_texture_0 1\\n'+\n *     '#define gpgpu_channels_0 rg\\n'+\n *     '\\n'+\n *     '#define gpgpu_texture_2 1\\n'+\n *     '#define gpgpu_channels_2 b\\n'+\n *     '\\n'+\n *     '#define count 32\\n'+\n *     '#define gpgpu_textures 2\\n'+\n *     '#define gpgpu_passes 2\\n'+\n *     '#define gpgpu_stepsPast 1\\n'+\n *     '#define gpgpu_steps 2\\n'+\n *     '\\n'+\n *     '#define gpgpu_passNow 0\\n'+\n *     '\\n'+\n *     '#define gpgpu_bound_1 0\\n'+\n *     '#define gpgpu_attach_1 0\\n'+\n *     '#define gpgpu_output_1 gl_FragData[gpgpu_attach_1].rgba\\n'+\n *     '\\n';\n *\n *     // Next pass and extra step.\n *     ++state.steps;\n *     ++state.passNow;\n *     state.pre = '';\n *     macroPass(state); // =>\n *     '#define texture_1 0\\n'+\n *     '#define channels_1 rgba\\n'+\n *     '\\n'+\n *     '#define texture_0 1\\n'+\n *     '#define channels_0 rg\\n'+\n *     '\\n'+\n *     '#define texture_2 1\\n'+\n *     '#define channels_2 b\\n'+\n *     '\\n'+\n *     '#define count 32\\n'+\n *     '#define textures 2\\n'+\n *     '#define passes 2\\n'+\n *     '#define stepsPast 2\\n'+\n *     '#define steps 3\\n'+\n *     '\\n'+\n *     '#define passNow 1\\n'+\n *     '\\n'+\n *     '#define bound_0 1\\n'+\n *     '#define attach_0 0\\n'+\n *     '#define output_0 gl_FragData[attach_0].rg\\n'+\n *     '\\n'+\n *     '#define bound_2 1\\n'+\n *     '#define attach_2 0\\n'+\n *     '#define output_2 gl_FragData[attach_2].b\\n'+\n *     '\\n'+\n *     '#define useSamples '+\n *         'const int samples_l = 3; '+\n *         'const ivec2 samples_0 = ivec2(0, 1); '+\n *         'const ivec2 samples_1 = ivec2(1, 1); '+\n *         'const ivec2 samples_2 = ivec2(0, 0);\\n'+\n *     '// `samples_i` index macro (e.g: `samples_i(0)`) may be slow, '+\n *         'prefer direct reference (e.g: `samples_0`) where possible.\\n'+\n *     '#define samples_i(i) '+\n *         '((i == 2)? samples_2 : ((i == 1)? samples_1 : samples_0))\\n'+\n *     '\\n'+\n *     '#define tapSamples(states, uv, textures) '+\n *         'const int data_l = 3; '+\n *         'vec4 data_0 = vec4(texture2D('+\n *             'states[(int(samples_0.s)*int(textures))+int(samples_0.t)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_1 = vec4(texture2D('+\n *             'states[(int(samples_1.s)*int(textures))+int(samples_1.t)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_2 = vec4(texture2D('+\n *             'states[(int(samples_2.s)*int(textures))+int(samples_2.t)], '+\n *             'vec2(uv))); '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = data_0; '+\n *         'data[1] = data_1; '+\n *         'data[2] = data_2;\\n'+\n *     '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '#define tapSamplesShift(states, uv, textures, byS, byT) '+\n *         'const int data_l = 3; '+\n *         'vec4 data_0 = vec4(texture2D('+\n *             'states[((int(samples_0.s)+int(byS))*int(textures))+'+\n *                 'int(samples_0.t)+int(byT)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_1 = vec4(texture2D('+\n *             'states[((int(samples_1.s)+int(byS))*int(textures))+'+\n *                 'int(samples_1.t)+int(byT)], '+\n *             'vec2(uv))); '+\n *         'vec4 data_2 = vec4(texture2D('+\n *             'states[((int(samples_2.s)+int(byS))*int(textures))+'+\n *                 'int(samples_2.t)+int(byT)], '+\n *             'vec2(uv))); '+\n *         'vec4 data[data_l]; '+\n *         'data[0] = data_0; '+\n *         'data[1] = data_1; '+\n *         'data[2] = data_2;\\n'+\n *     '#define data_i(i) data[i]\\n'+\n *     '\\n'+\n *     '\\n'+\n *     '#define useReads_0 '+\n *         'const int reads_0_l = 1; '+\n *         'const int reads_0_0 = int(0);\\n'+\n *     '// `reads_0_i` index macro (e.g: `reads_0_i(0)`) may be slow, '+\n *         'prefer direct reference (e.g: `reads_0_0`) where possible.\\n'+\n *     '#define reads_0_i(i) reads_0_0\\n'+\n *     '\\n'+\n *     '#define useReads_2 '+\n *         'const int reads_2_l = 4; '+\n *         'const int reads_2_0 = int(1); '+\n *         'const int reads_2_1 = int(0); '+\n *         'const int reads_2_2 = int(2); '+\n *         'const int reads_2_3 = int(0);\\n'+\n *     '// `reads_2_i` index macro (e.g: `reads_2_i(0)`) may be slow, '+\n *         'prefer direct reference (e.g: `reads_2_0`) where possible.\\n'+\n *     '#define reads_2_i(i) ((i == 3)? reads_2_3 : ((i == 2)? reads_2_2 '+\n *         ': ((i == 1)? reads_2_1 : reads_2_0)))\\n'+\n *     '\\n';\n *\n * @param {object} state Properties for generating the macros. See `getState`\n *     and `mapGroups`.\n * @param {string} [on] Any further macro `hooks` specifier; if given, both\n *     the hook key and this specifier are checked (e.g: `key` and `key_on`).\n *\n * @returns {string} The GLSL preprocessor macros defining the mappings for\n *     values, textures, channels, bound outputs of the active pass, etc. See\n *     `macroValues`, `macroOutput`, and `macroSamples`.\n */\nexport const macroPass = (state, on) =>\n    (hasMacros(state, hooks.macroPass, on) ??\n        macroValues(state)+'\\n'+macroOutput(state)+'\\n'+macroSamples(state));\n\nexport default macroPass;\n","const [{ length: start}, { length: end }] = '[object {type}]'.split('{type}');\n\n/**\n * Gives the type of a given input.\n *\n * @see https://stackoverflow.com/a/17772086/716898\n *\n * @param {*} x Any input to test.\n *\n * @returns {string} The type of `x`.\n */\nexport const type = (x) => toString.call(x).slice(start, -end);\n\nexport default type;\n","/**\n * GPGPU inputs (uniforms, attributes, indexes, etc).\n */\n\nimport { setC2 } from '@thi.ng/vectors/setc';\nimport map from '@epok.tech/fn-lists/map';\nimport range from '@epok.tech/fn-lists/range';\nimport each from '@epok.tech/fn-lists/each';\nimport wrap from '@epok.tech/fn-lists/wrap-index';\n\nimport { boundDef, preDef } from './const';\n\n/**\n * Uniform inputs for GPGPU calls, such as in `getStep`.\n * Uniforms are defined as callback hooks called at each pass, using properties\n * from given global context and local state objects, allowing different APIs or\n * author-defined hooks.\n *\n * @example\n *     const state = { steps: 2, maps: getMaps({ values: [1, 2, 3] };\n *\n *     getUniforms(state); // =>\n *     {\n *         stepNow: (context, state) => {},\n *         dataShape: (context, state) => {},\n *         viewShape: (context, state) => {},\n *         // Data textures for the 1st step ago not bound as an output.\n *         'states[0]': (context, state) => {},\n *         'states[1]': (context, state) => {}\n *     };\n *\n *     getUniforms({ ...state, steps: 3 }); // =>\n *     {\n *         stepNow: (context, state) => {},\n *         dataShape: (context, state) => {},\n *         viewShape: (context, state) => {},\n *         // Data textures for the 1st step ago not bound as an output.\n *         'states[0]': (context, state) => {},\n *         'states[1]': (context, state) => {}\n *         // Data textures for the 2nd step ago not bound as an output.\n *         'states[2]': (context, state) => {},\n *         'states[3]': (context, state) => {}\n *     };\n *\n * @see [getStep]{@link ./step.js#getStep}\n * @see [getState]{@link ./state.js#getState}\n * @see [mapGroups]{@link ./maps.js#mapGroups}\n *\n * @param {object} state The GPGPU state to use. See `getState` and `mapGroups`.\n * @param {array|number} state.steps The array of steps, or number of steps.\n *     See `getState`.\n * @param {object} state.maps How values are grouped per-texture per-pass\n *     per-step. See `mapGroups`.\n * @param {array<array<number>>} state.maps.textures How values are grouped into\n *     textures. See `mapGroups`.\n * @param {number} [state.bound=boundDef] How many steps are bound as outputs,\n *     unavailable as input; for platforms forbidding read/write of same buffer.\n * @param {string} [state.pre=preDef] Namespace prefix; `preDef` if not given.\n * @param {object} [to=(state.uniforms ?? {})] The object to contain the\n *     uniforms; `state.uniforms` or a new object if not given.\n *\n * @returns {object<function>} `to` The uniform hooks for the given `state`.\n *     Each is a function called on each pass, taking 2 arguments:\n *     - Object of general/global properties; containing e.g: `viewportWidth`.\n *     - Object of local properties; e.g: the given `state`.\n */\nexport function getUniforms(state, to = (state.uniforms ?? {})) {\n    const {\n            bound = boundDef, pre: n = preDef, steps,\n            steps: { length: stepsL = steps }, maps: { textures: textureMap }\n        } = state;\n\n    const texturesL = textureMap.length;\n    const cache = { viewShape: [] };\n\n    to[n+'stepNow'] = (_, { stepNow: s }) => s;\n    to[n+'dataShape'] = (_, { size: { shape: s } }) => s;\n\n    to[n+'viewShape'] = ({ viewportWidth: w, viewportHeight: h }) =>\n        setC2(cache.viewShape, w, h);\n\n    /**\n     * Set up the ago steps, as the number of steps ago from the currently\n     * bound step `[0,... stepsL-1-bound]`.\n     */\n    const addTexture = (ago, texture) =>\n        // Hook to pull a given texture from the latest `props`.\n        to[`${n}states[${(ago*texturesL)+texture}]`] =\n            (_, { stepNow: s, bound: b = bound, textures }) =>\n                wrap.get(s-b-ago, textures)[texture].texture;\n\n    // Flatten all input textures, as uniforms are stored in flat arrays.\n    for(let ago = 0, pl = stepsL-bound; ago < pl; ++ago) {\n        each((_, texture) => addTexture(ago, texture), textureMap);\n    }\n\n    return to;\n}\n\n/**\n * Gives the number of indexes to draw a full state, for various parameters.\n * Effectively equivalent to `gl_VertexID` in WebGL2.\n *\n * @see [getState]{@link ./state.js#getState}\n *\n * @param {object|array<number>|number} size Size/type information of data\n *     resources, or a shape array of width and height numbers, or width if\n *     height is given as a second parameter.\n * @param {number} [size.count] The number of entries of each data-texture.\n * @param {array<number>} [size] The width/height of each data-texture.\n * @param {number} [size.width] The width of each data-texture.\n * @param {number} [size.height] The height of each data-texture.\n * @param {number} [size.x] The width of each data-texture.\n * @param {number} [size.y] The height of each data-texture.\n * @param {number} [size.shape] The shape of each data-texture.\n * @param {array<number>} [size.shape] The width/height of each data-texture.\n *\n * @param {number} [height] The height of each data-texture.\n *\n * @returns {number} The number of indexes needed to draw a full state; each\n *     entry of a data-texture (its area, equivalent to `state.size.count`).\n */\nexport const countDrawIndexes = (size, height) => (size.count ??\n    ((size[0] ?? size.width ?? size.x ?? size.shape?.[0] ?? size)*\n        (size[1] ?? size.height ?? size.y ?? size.shape?.[1] ?? height ?? 1)));\n\n/**\n * Gives the array of indexes needed to draw a full state.\n *\n * @param {number|object<number>} size The number of entries in each\n *     data-texture; or an object of size/type information on data resources.\n *\n * @returns {array<number>} An array of indexes for drawing all data-texture\n *     entries, numbered `0` to `size-1`.\n */\nexport const getDrawIndexes = (size) => map((_, i) => i,\n    range(Number.isInteger(size)? size : countDrawIndexes(size)), 0);\n","export const setC2 = (out, x, y) => (!out && (out = []), (out[0] = x), (out[1] = y), out);\nexport const setC3 = (out, x, y, z) => (!out && (out = []), (out[0] = x), (out[1] = y), (out[2] = z), out);\nexport const setC4 = (out, x, y, z, w) => (!out && (out = []),\n    (out[0] = x),\n    (out[1] = y),\n    (out[2] = z),\n    (out[3] = w),\n    out);\nexport const setC6 = (out, a, b, c, d, e, f) => (!out && (out = []),\n    (out[0] = a),\n    (out[1] = b),\n    (out[2] = c),\n    (out[3] = d),\n    (out[4] = e),\n    (out[5] = f),\n    out);\nexport const setC = (out, ...xs) => {\n    !out && (out = []);\n    for (let i = 0, n = xs.length; i < n; i++) {\n        out[i] = xs[i];\n    }\n    return out;\n};\n","/**\n * How many vertexes for pairs of line segments linking each entry's states,\n * using `gl.LINES`.\n * If fewer than 2 states are given, lines can't be drawn, assumes `gl.POINTS`.\n * Every pair of indexes is a line-segment connecting each state to its past\n * state, making one continuous line back through steps using `gl.LINES`;\n * iterating each start index and its past index.\n * Corresponds to the indexing logic in the `indexPairs` GLSL function.\n *\n * @see [readme]{@link ./readme.md}\n * @see `gl.LINES` at https://webglfundamentals.org/webgl/lessons/webgl-points-lines-triangles.html\n * @see [indexPairs]{@link ./index.glsl#indexPairs}\n *\n * @param {number} states The number of steps of state to link by pairs of line\n *     segments.\n *\n * @returns {number} The number of points needed to link all steps of state\n *     by pairs of line segments. May be multiplied with the number of entries\n *     in each step.\n */\nexport const indexPairs = (states) => Math.max(1, (states-1)*2);\n\nexport default indexPairs;\n","/**\n * The update step for a GPGPU particle simulation.\n * Requires setup with preprocessor macros - see `macroPass`.\n * Executed in one or more passes; each chunk depending on a `gpgpu` macro may\n * be combined with others into one pass or separated into its own pass; `gpgpu`\n * preprocessor macros control the combination according to which `values` are\n * currently bound for `output` to the next `state`.\n *\n * @see [getStep]{@link ../../step.js#getStep}\n * @see [macroPass]{@link ../../macros.js#macroPass}\n */\n\n#ifdef GL_EXT_draw_buffers\n    #extension GL_EXT_draw_buffers : require\n#endif\n\nprecision highp float;\n\n// Setting up the macros and aliases.\n// Note that these `texture_i`/`channels_i`/`reads_i_j` indexes correspond to\n// the value at that index in the `values`/`derives` arrays provided to `gpgpu`;\n// they are defined here to match the arrangement in `./index.js`.\n\n// The texture channels each of the `values` is stored in.\n#define positionChannels channels_0\n#define motionChannels channels_1\n#define lifeChannels channels_2\n\n// Set up sampling logic.\nuseSamples\n\n// Set up minimal texture reads logic; only read what a value with a currently\n// bound output `derives` from other `values` for its next state.\n// See `derives` for indexing `reads_${bound value index}_${derives index}`.\n#ifdef output_0\n    #define positionOutput output_0\n    useReads_0\n    #define positionReadPosition0 reads_0_0\n    #define positionReadPosition1 reads_0_1\n    #define positionReadMotion reads_0_2\n    #define positionReadLife reads_0_3\n#endif\n#ifdef output_1\n    #define motionOutput output_1\n    useReads_1\n    #define motionReadMotion reads_1_0\n    #define motionReadLife reads_1_1\n#endif\n#ifdef output_2\n    #define lifeOutput output_2\n    useReads_2\n    #define lifeReadLifeLast reads_2_0\n    #define lifeReadLife1 reads_2_1\n#endif\n\n// The main shader.\n\n// States from `gl-gpgpu`.\nuniform sampler2D states[stepsPast*textures];\nuniform vec2 dataShape;\n// Custom inputs for this demo.\nuniform float dt0;\nuniform float dt1;\nuniform float loop;\nuniform vec2 lifetime;\nuniform float useVerlet;\nuniform vec3 g;\nuniform vec3 source;\nuniform vec2 scale;\nuniform float spout;\n// uniform vec3 drag;\n\nvarying vec2 uv;\n\n#pragma glslify: map = require(glsl-map)\n#pragma glslify: le = require(glsl-conditionals/when_le)\n\n#ifdef positionOutput\n    // @todo Try Velocity Verlet integration.\n    #pragma glslify: verlet = require(@epok.tech/glsl-verlet/p-p-a)\n#endif\n\n#ifdef motionOutput\n    #pragma glslify: tau = require(glsl-constants/TWO_PI)\n\n    // @see https://observablehq.com/@rreusser/equally-distributing-points-on-a-sphere\n    vec3 randomOnSphere(float randomAngle, float randomDepth) {\n        float a = randomAngle*tau;\n        float u = (randomDepth*2.0)-1.0;\n\n        return vec3(sqrt(1.0-(u*u))*vec2(cos(a), sin(a)), u);\n    }\n#endif\n\n#if defined(motionOutput) || defined(lifeOutput)\n    #pragma glslify: random = require(glsl-random)\n#endif\n\n// Drag acceleration, constrained within the given velocity.\n// @see https://en.wikipedia.org/wiki/Verlet_integration#Algorithmic_representation\n// vec3 dragAcc(vec3 velocity, vec3 drag) {\n//     vec3 l = abs(velocity);\n\n//     return clamp(-0.5*sign(velocity)*dot(velocity, velocity)*drag, -l, l);\n// }\n\nvoid main() {\n    // Sample the desired state values - creates the `data` array.\n    tapSamples(states, uv, textures)\n\n    // Read values.\n\n    #ifdef positionOutput\n        vec3 position0 = data[positionReadPosition0].positionChannels;\n        vec3 position1 = data[positionReadPosition1].positionChannels;\n    #endif\n\n    // If reads all map to the same value sample, any of them will do.\n    #if defined(positionOutput) || defined(motionOutput)\n        #if defined(positionOutput)\n            #define readMotion positionReadMotion\n        #elif defined(motionOutput)\n            #define readMotion motionReadMotion\n        #endif\n\n        vec3 motion = data[readMotion].motionChannels;\n    #endif\n\n    // If reads all map to the same value sample, any of them will do.\n    #if defined(positionOutput)\n        #define readLife positionReadLife\n    #elif defined(lifeOutput)\n        #define readLife lifeReadLife\n    #elif defined(motionOutput)\n        #define readLife motionReadLife\n    #endif\n\n    float life = data[readLife].lifeChannels;\n\n    #ifdef lifeOutput\n        float lifeLast = data[lifeReadLifeLast].lifeChannels;\n    #endif\n\n    // Update and output values.\n    // Note that the update/output logic components within each `#if` macro\n    // block from `gpgpu` are independent modules, as the `gpgpu` macros\n    // determine whether they're executed across one or more passes - they could\n    // also be coded in separate files called from here, however for brevity and\n    // easy access to shared variables they're coded inline.\n\n    // Whether the particle is ready to respawn.\n    float spawn = le(life, 0.0);\n\n    #if defined(positionOutput) || defined(motionOutput)\n        // Workaround for switching Euler/Verlet; interpret `motion` data as\n        // acceleration/velocity, respectively.\n        vec3 velocity = motion;\n        vec3 acceleration = motion;\n    #endif\n\n    #ifdef positionOutput\n        // For numeric accuracy, encoded as exponent `[b, p] => b*(10**p)`.\n        float size = scale.s*pow(10.0, scale.t);\n\n        // Use either Euler integration...\n        vec3 positionTo = mix(position1+(velocity*dt1*size),\n            // ... or Verlet integration...\n            verlet(position0, position1, acceleration*size, dt0, dt1),\n            // ... according to which is currently active.\n            useVerlet);\n\n        positionOutput = mix(positionTo, source, spawn);\n    #endif\n    #ifdef motionOutput\n        // The new acceleration is just constant acceleration due to gravity.\n        acceleration = g;\n        // Can also combine other forces, e.g: drag.\n        // acceleration = g+\n        //     dragAcc(mix(velocity, acceleration*dt1, useVerlet), drag);\n\n        vec3 motionTo = mix(velocity+(acceleration*dt1), acceleration,\n            useVerlet);\n\n        vec3 motionNew = spout*random(loop-(uv*dt0))*\n            randomOnSphere(random((uv+loop)/dt1), random((uv-loop)*dt0));\n\n        motionOutput = mix(motionTo, motionNew, spawn);\n    #endif\n    #ifdef lifeOutput\n        float lifeTo = max(life-dt1, 0.0);\n        float lifeNew = map(random(uv*loop), 0.0, 1.0, lifetime.s, lifetime.t);\n        // Whether the oldest of this trail has faded.\n        float faded = le(lifeLast, 0.0);\n\n        // Only spawn life once the oldest step reaches the end of its lifetime\n        // (past and current life are both 0).\n        lifeOutput = mix(lifeTo, lifeNew, spawn*faded);\n    #endif\n}\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see [macroPass]{@link ../../macros.js#macroPass}\n * @see [macroValues]{@link ../../macros.js#macroValues}\n */\n\nprecision highp float;\n\n// The texture channels each of the `values` is stored in.\n#define positionChannels channels_0\n#define motionChannels channels_1\n#define lifeChannels channels_2\n// Set up sampling logic.\nuseSamples\n// Only the first value derives from all values, giving these minimal `reads`.\nuseReads_0\n// All `derives` here are in one pass (`0`), and in the same order as `values`.\n// See `values` for indexing `reads_0_${derives index == values index}`.\n#define readPosition1 reads_0_0\n#define readMotion reads_0_1\n#define readLife reads_0_2\n#define readPosition0 reads_0_3\n\nattribute float index;\n\nuniform sampler2D states[stepsPast*textures];\nuniform vec2 dataShape;\nuniform vec2 viewShape;\nuniform float pointSize;\nuniform float dt;\nuniform vec2 lifetime;\nuniform vec2 pace;\nuniform float useVerlet;\n\nvarying vec4 color;\n\n#pragma glslify: aspect = require(@epok.tech/glsl-aspect/contain)\n#pragma glslify: gt = require(glsl-conditionals/when_gt)\n\n#pragma glslify: indexUV = require(../../sample/index-uv)\n\n#if stepsPast > 1\n    // If multiple steps are given, shift into past steps.\n    #pragma glslify: indexPairs = require(../../index-pairs)\n#endif\n\nvoid main() {\n    #if stepsPast > 1\n        // If multiple steps are given, find past step and entry.\n        vec2 stepEntry = indexPairs(index, stepsPast);\n        float stepPast = stepEntry.s;\n        float entry = stepEntry.t;\n    #else\n        // If only 1 step is given, past step and entry are known.\n        float stepPast = 0.0;\n        float entry = index;\n    #endif\n\n    // Turn the 1D index into a 2D texture UV; offset to sample at the texel\n    // center and avoid errors.\n    vec2 st = indexUV(entry+0.5, dataShape);\n\n    // Can also use the `reads` logic to take the minimum possible samples here.\n    // Sample the desired state values - creates the `data` array.\n    #if stepsPast > 1\n        // Shift into past steps.\n        tapSamplesShift(states, st, textures, stepPast, 0)\n        /**\n         * @todo Fix GLSL3/D3D error \"sampler array index must be a literal\n         *     expression\". See info in `macroSamples` in `macros.js`.\n         */\n        // #define modConst(x, y) (x-(y*(x/y)))\n        // #define pairStepConst(i, s) ((modConst(i, ((s-1)*2))+1)/2)\n\n        // tapSamplesShift(states, st, textures,\n        //     pairStepConst(int(index), stepsPast),\n        //     // pairStepConst(gl_VertexID, stepsPast),\n        //     0)\n    #else\n        // No past steps, no shift.\n        tapSamples(states, st, textures)\n    #endif\n\n    // Read values.\n    vec3 position0 = data[readPosition0].positionChannels;\n    vec3 position1 = data[readPosition1].positionChannels;\n    vec3 velocity = data[readMotion].motionChannels;\n    float life = data[readLife].lifeChannels;\n\n    #if stepsPast > 1\n        float ratioNow = 1.0-(stepPast/float(stepsPast-1));\n    #else\n        float ratioNow = 1.0;\n    #endif\n\n    float alive = gt(life, 0.0);\n    vec2 ar = aspect(viewShape);\n    vec4 vertex = vec4(position1.xy*ar, position1.z, 1.0);\n    float depth = clamp(1.0-(vertex.z/vertex.w), 0.1, 1.0);\n\n    gl_Position = alive*vertex;\n    gl_PointSize = alive*pointSize*depth*mix(0.1, 1.0, ratioNow);\n\n    float a = pow(life/lifetime.t, 0.3)*pow(ratioNow, 0.3);\n    float speed = length(mix(velocity, position1-position0, useVerlet)/dt);\n\n    color = a*vec4(mix(0.2, 1.0, ratioNow), mix(0.2, 1.0, entry/float(count)),\n        clamp(pow(speed*pace.s, pace.t), 0.0, 1.0), a);\n}\n","/**\n * Drawing a GPGPU particle simulation.\n * Requires setup with preprocessor macros. See `macroPass` and `macroValues`.\n *\n * @see [macroPass]{@link ../../macros.js#macroPass}\n * @see [macroValues]{@link ../../macros.js#macroValues}\n */\n\nprecision highp float;\n\nvarying vec4 color;\n\nvoid main() { gl_FragColor = color; }\n"],"names":["_console","_console1","ref","ref1","self","gpgpu","$e3wLf","macroPass","$1tr74","getMaps","$4MXss","getUniforms","$gyl7y","getDrawIndexes","indexPairs","$i7NAh","default","extend","halfFloat","$hBMe5","extensionsHalfFloat","float","extensionsFloat","other","optionalExtensions","regl","$parcel$interopDefault","$3Cmit","pixelRatio","Math","max","floor","devicePixelRatio","extensions","required","optional","$kxEDL","concat","console","group","log","$ksHHi","o","e","hasExtension","groupEnd","canvas","document","querySelector","classList","add","valuesMap","Map","set","values","valuesIndex","forEach","v","k","push","_limits","limits","maxTextureUnits","maxTextureSize","lineWidthDims","pointSizeDims","steps","s","scale","log2","niceScale","$lKPpF","apply","getQuery","param","search","location","URLSearchParams","setQuery","entries","param1","query","$9yAa9","_param","tmp","delete","query1","parseInt","get","stepsPast","usePoints","has","timestepDef","timestep","parseFloat","flat","href","derives","position","motion","life","canVerlet","state1","props","timer","$8g7pT","step","dts","$88hlK","now","rate","loop","lifetime","useVerlet","g","source","spout","bound","maps","type","every","macros","vert","frag","$jYFPA","frags","uniforms","dt","_","_props","dt0","dt1","time","t","l","sin","PI","prop","state","packed","textures","valueToTexture","drawCount","size","count","drawIndexes","drawState","$9BYky","drawProps","pace","output","texturesMax","drawWidth","drawCommand","$57MSl","$7Lnkd","attributes","index","pointSize","lineWidth","depth","enable","blend","func","src","dst","primitive","draw","clearView","color","frame","run","stepNow","clear","addEventListener","stopPropagation","preventDefault","x","clientX","y","clientY","min","innerWidth","innerHeight","module","hot","accept","call","reload","obj","key","value","Object","defineProperty","enumerable","configurable","writable","target","i","arguments","length","ownKeys","keys","getOwnPropertySymbols","filter","sym","getOwnPropertyDescriptor","$gHSxu","arr","$km6mS","$3rVPa","$iWEHp","Array","isArray","iter","Symbol","iterator","prototype","toString","from","TypeError","$kJ5JC","$f24YN","arr2","exports","$60359228a7d3fb28$export$be3f796aed065412","diff","pause","$60359228a7d3fb28$export$7548f4bc1b09ff22","$60359228a7d3fb28$export$85b884786400d38f","$60359228a7d3fb28$export$eb8a9b7a1ebec59a","Date","$60359228a7d3fb28$export$2e2bcd8739ae039","out","t0","n","_step","t1","isNaN","$ee5851911330bf41$var$r","reduce","$ee5851911330bf41$export$533b26079ad0b4b","f","a","to","undefined","$ee5851911330bf41$export$2e2bcd8739ae039","$6d8e5906de1cf303$export$2e2bcd8739ae039","to1","$6f535731e26073af$var$e","$6f535731e26073af$export$2e2bcd8739ae039","$5ebc876929a0439f$export$2e2bcd8739ae039","start","end","fill","_maps1","$a3bac22a2cec4520$export$a8489f67fe30ef76","api","maxDrawbuffers","glsl","_maps","match","_texturesMax","$20H3c","getState","$4NSvD","getStep","_cache","_reads","_ref","$37c9c43fd5907c13$export$69a3209f1a06c04d","$37c9c43fd5907c13$export$5ca26c99531348ec","channelsMax","channelsMaxDef","error","$37c9c43fd5907c13$export$96707a1f51900f3d","param2","_values","valuesDef","_channelsMax","texturesMaxDef","_packed","$9pabq","channels","fitIndex","fitSize","Infinity","i1","fit","pack","$37c9c43fd5907c13$export$9d1d9285bd6d8c57","passes","valueToPass","textureToPass","getValue","getIndex","p","pass","texture","$37c9c43fd5907c13$export$574963e692b662ec","param3","to2","reads","cache","all","getAddSample","derive","d","Number","isFinite","findIndex","_pass","_value","samples","valueDerives","getAddSamples","$37c9c43fd5907c13$export$e8886fdb6718f96","$cd1b4d1540633814$export$ac0cd3cc21f80dfc","$cd1b4d1540633814$export$5d97924d29f48e83","$cd1b4d1540633814$export$4bceda1224fc5ab8","$cd1b4d1540633814$export$b4781c2237bde956","$cd1b4d1540633814$export$26945b8c914b7fc","$cd1b4d1540633814$export$154f256b9eac9103","$cd1b4d1540633814$export$4d253b84ce5f5f8e","$cd1b4d1540633814$export$b029aceb5666f022","$cd1b4d1540633814$export$71c6d8e332d66a75","$cd1b4d1540633814$export$617a37502ff8853","$cd1b4d1540633814$export$ff01eb58fe4e69","$cd1b4d1540633814$export$cfdc3a7c4cb854c6","$fAgvn","positions","$cd1b4d1540633814$export$27fb0dad99ae5dd2","$cd1b4d1540633814$export$47b10f415de592b1","$cd1b4d1540633814$export$1fb689c67b965bff","$cd1b4d1540633814$export$8d7f4a48e1f2b2a","$cd1b4d1540633814$export$a211ab2c8ecded9a","$cd1b4d1540633814$export$a1b7c201e9365814","$b587055a99d7210b$export$ba60520149d1328e","$b587055a99d7210b$export$878041e1e4cd4218","_textures","_passes","$176cf9cb32bd006b$export$50fdfeece43146fd","framebuffer","_steps","stepsDef","passNow","side","_scale","scaleDef","_width","width","pow","_height","height","_type","typeDef","_min","minDef","_mag","mag","magDef","_wrap","wrap","wrapDef","_depth","depthDef","_stencil","stencil","stencilDef","_length","_channelsMin","channelsMin","channelsMinDef","texturesMap","shape","textures1","passes1","addPass","textureProps","max1","_step1","entry","map","addTexture","_step2","$37f6056e300b6832$var$scale","$37f6056e300b6832$export$89e7bec3b8bce705","buffer","_command","command","_pre","pre","preDef","step1","_positions","positionsDef","passCommand","_vert","$2Be0R","verts","_count","stateCache","_obj","tmp1","vs","tmp2","fs","ss","$6qjSx","wrapGet","onPass","onStep","stepProps","$4ad49746d3e88695$export$acb6ab09ed1b7b8b","$4ad49746d3e88695$export$ea134dcc07e79c49","$4ad49746d3e88695$export$2e2bcd8739ae039","_cache1","_cache2","$112d87fa33ebb5f5$export$4e46ac54fc82cf3b","$112d87fa33ebb5f5$export$69a3209f1a06c04d","$112d87fa33ebb5f5$export$11949c6f5fba7dcd","$112d87fa33ebb5f5$export$feaf5ffc92c2af94","on","$ayMqI","$112d87fa33ebb5f5$export$83d01c7b88bc16d5","name","qualify","init","ref2","join","$112d87fa33ebb5f5$export$45db4de6da38aa8d","$112d87fa33ebb5f5$export$3df19e70a88cb8cd","param4","$112d87fa33ebb5f5$export$1c7039c93eddfba","param5","$112d87fa33ebb5f5$export$c346962e7dd3191","param6","trim","$112d87fa33ebb5f5$export$d38b14fb9031108e","hook","_bound","boundDef","passesL","stepsL","c","JSON","stringify","_c","s1","slice","$112d87fa33ebb5f5$export$84186522bf5a7d4d","s2","$112d87fa33ebb5f5$export$49873e279ff642c0","reads1","passSamples","passReads","tap","$112d87fa33ebb5f5$export$9cb6037fa2a40c2e","$7b02a589e8d7c18a$var$start","$7b02a589e8d7c18a$var$end","split","$7b02a589e8d7c18a$export$bf9fb029d174d554","_uniforms","ref3","ref4","ref5","ref6","ref7","ref8","$c0d0347db9b941ce$export$4e06fab977536f8e","ago","textureMap","texturesL","w","viewportWidth","h","viewportHeight","$fnH3v","setC2","b","pl","_loop","$c0d0347db9b941ce$export$87ed20f81f3c66ff","isInteger","ref10","ref9","$c0d0347db9b941ce$export$a495db45d4904b10","$b32a66f4c5b7b75f$export$dcfbb7940cfb3a48","$0367bb3900f2b1c9$export$2e2bcd8739ae039","states"],"version":3,"file":"index.2c67378e.js.map"}